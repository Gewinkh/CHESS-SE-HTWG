2024.04.25 22:21:21 INFO  Started: Metals version 1.3.0 in folders 'C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG' for client Visual Studio Code 1.88.1.
SLF4J: Class path contains multiple SLF4J providers.
SLF4J: Found provider [scribe.slf4j.ScribeServiceProvider@5c1ecd53]
SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@682033bf]
SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual provider is of type [scribe.slf4j.ScribeServiceProvider@5c1ecd53]
2024.04.25 22:21:21 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.04.25 22:21:33 INFO  no build target found for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Chess.scala. Using presentation compiler with project's scala-library version: 3.3.3
Apr. 25, 2024 10:21:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2
2024.04.25 22:21:33 WARN  no build target for: C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Chess.scala
2024.04.25 22:21:34 INFO  running 'C:\Program Files\Java\jdk-19\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\GEWINS~1\AppData\Local\Temp\metals8970638068580177062\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.25 22:21:36 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 19)
2024.04.25 22:21:37 INFO  [info] loading global plugins from C:\Users\Gewin Singh\.sbt\1.0\plugins
2024.04.25 22:21:40 INFO  [info] loading settings for project chess-se-htwg-build-build-build from metals.sbt ...
2024.04.25 22:21:40 INFO  [info] loading project definition from C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\project\project
2024.04.25 22:21:42 INFO  [info] loading settings for project chess-se-htwg-build-build from metals.sbt ...
2024.04.25 22:21:42 INFO  [info] loading project definition from C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\project
2024.04.25 22:21:46 INFO  [success] Generated .bloop\chess-se-htwg-build-build.json
2024.04.25 22:21:46 INFO  [success] Total time: 4 s, completed 25.04.2024, 22:21:46
2024.04.25 22:21:47 INFO  [info] loading settings for project chess-se-htwg-build from metals.sbt,plugins.sbt ...
2024.04.25 22:21:47 INFO  [info] loading project definition from C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project
2024.04.25 22:21:54 INFO  [success] Generated .bloop\chess-se-htwg-build.json
2024.04.25 22:21:54 INFO  [success] Total time: 7 s, completed 25.04.2024, 22:21:54
2024.04.25 22:21:56 INFO  [info] loading settings for project root from build.sbt ...
2024.04.25 22:21:56 INFO  [info] set current project to CHESS-SE-HTWG (in build file:/C:/Users/Gewin%20Singh/Desktop/S/AIN3/SE/CHESS-SE-HTWG/)
2024.04.25 22:21:56 INFO  [success] Generated .bloop\root.json
2024.04.25 22:21:56 INFO  [success] Generated .bloop\root-test.json
2024.04.25 22:21:56 INFO  [success] Total time: 0 s, completed 25.04.2024, 22:21:57
2024.04.25 22:21:57 INFO  time: ran 'sbt bloopInstall' in 23s
2024.04.25 22:21:57 INFO  Attempting to connect to the build server...
2024.04.25 22:21:57 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 22:21:57 INFO  Attempting to connect to the build server...
2024.04.25 22:21:57 INFO  Attempting to connect to the build server...
2024.04.25 22:21:57 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\project\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 22:21:57 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 22:21:57 INFO  time: Connected to build server in 0.43s
2024.04.25 22:21:57 INFO  Connected to Build server: Bloop v1.5.17
2024.04.25 22:21:58 INFO  time: Imported build in 0.32s
2024.04.25 22:22:03 ERROR error processing file:///C:/Users/Gewin%20Singh/AppData/Local/Coursier/Cache/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-core_3/3.2.18/scalatest-core_3-3.2.18-sources.jar
org.h2.jdbc.JdbcBatchUpdateException: Eindeutiger Index oder Primärschlüssel verletzt: "PUBLIC.PRIMARY_KEY_3 ON PUBLIC.TOPLEVEL_SYMBOL(JAR, PATH, SYMBOL) VALUES ( /* key:3194 */ 4, '/org/scalatest/enablers/TableAsserting.scala', 'org/scalatest/enablers/ForResult#')"
Unique index or primary key violation: "PUBLIC.PRIMARY_KEY_3 ON PUBLIC.TOPLEVEL_SYMBOL(JAR, PATH, SYMBOL) VALUES ( /* key:3194 */ 4, '/org/scalatest/enablers/TableAsserting.scala', 'org/scalatest/enablers/ForResult#')"; SQL statement:
insert into toplevel_symbol (symbol, path, jar) values (?, ?, ?) [23505-224]
	at org.h2.jdbc.JdbcPreparedStatement.executeBatch(JdbcPreparedStatement.java:1282)
	at scala.meta.internal.metals.JarTopLevels.putToplevels(JarTopLevels.scala:177)
	at scala.meta.internal.metals.JarTopLevels.putJarIndexingInfo(JarTopLevels.scala:128)
	at scala.meta.internal.metals.Indexer.addSourceJarSymbols(Indexer.scala:657)
	at scala.meta.internal.metals.Indexer.$anonfun$indexDependencySources$5(Indexer.scala:487)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:935)
	at scala.collection.IterableOps$WithFilter.foreach(Iterable.scala:905)
	at scala.meta.internal.metals.Indexer.$anonfun$indexDependencySources$1(Indexer.scala:478)
	at scala.meta.internal.metals.Indexer.$anonfun$indexDependencySources$1$adapted(Indexer.scala:477)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:935)
	at scala.meta.internal.metals.Indexer.indexDependencySources(Indexer.scala:477)
	at scala.meta.internal.metals.Indexer.$anonfun$indexWorkspace$24(Indexer.scala:396)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.Indexer.$anonfun$indexWorkspace$23(Indexer.scala:389)
	at scala.meta.internal.metals.Indexer.$anonfun$indexWorkspace$23$adapted(Indexer.scala:385)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.metals.Indexer.indexWorkspace(Indexer.scala:385)
	at scala.meta.internal.metals.Indexer.$anonfun$profiledIndexWorkspace$2(Indexer.scala:172)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.Indexer.$anonfun$profiledIndexWorkspace$1(Indexer.scala:172)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.25 22:22:05 INFO  compiling root (4 scala sources)
2024.04.25 22:22:10 INFO  time: indexed workspace in 11s
2024.04.25 22:22:10 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 12.516s)
2024.04.25 22:22:10 INFO  compiling root (4 scala sources)
2024.04.25 22:22:19 INFO  time: compiled root in 9.12s
2024.04.25 22:22:19 INFO  compiling root (4 scala sources)
2024.04.25 22:22:23 INFO  time: compiled root in 4.23s
2024.04.25 22:22:23 INFO  compiling root (4 scala sources)
2024.04.25 22:22:24 INFO  time: code lens generation in 5.1s
2024.04.25 22:22:26 INFO  time: compiled root in 2.89s
2024.04.25 22:23:34 INFO  compiling root (4 scala sources)
2024.04.25 22:23:35 INFO  time: compiled root in 1.18s
2024.04.25 22:23:37 INFO  compiling root (4 scala sources)
2024.04.25 22:23:39 INFO  time: compiled root in 1.42s
Apr. 25, 2024 10:23:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 284
Apr. 25, 2024 10:24:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 332
Apr. 25, 2024 10:24:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 333
Apr. 25, 2024 10:24:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 430
Apr. 25, 2024 10:24:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 464
2024.04.25 22:25:32 WARN  Using indexes to guess the definition of KNIGHT
2024.04.25 22:25:33 WARN  Using indexes to guess the definition of KNIGHT
2024.04.25 22:25:33 INFO  compiling root (4 scala sources)
2024.04.25 22:25:33 INFO  time: compiled root in 0.92s
Apr. 25, 2024 10:25:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 532
Apr. 25, 2024 10:25:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 578
2024.04.25 22:25:56 INFO  compiling root (4 scala sources)
2024.04.25 22:25:57 INFO  time: compiled root in 1.02s
Apr. 25, 2024 10:26:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 619
2024.04.25 22:26:28 INFO  compiling root (4 scala sources)
2024.04.25 22:26:29 INFO  time: compiled root in 1.04s
Apr. 25, 2024 10:26:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 717
2024.04.25 22:26:37 INFO  compiling root (4 scala sources)
2024.04.25 22:26:37 INFO  time: compiled root in 0.9s
Apr. 25, 2024 10:26:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 748
Apr. 25, 2024 10:26:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 772
Apr. 25, 2024 10:26:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 781
Apr. 25, 2024 10:26:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 784
2024.04.25 22:27:11 INFO  compiling root (4 scala sources)
2024.04.25 22:27:11 INFO  time: compiled root in 0.74s
Apr. 25, 2024 10:27:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 834
2024.04.25 22:27:57 INFO  compiling root (4 scala sources)
2024.04.25 22:27:57 INFO  time: compiled root in 0.76s
2024.04.25 22:29:02 WARN  Using indexes to guess the definition of BLACK
2024.04.25 22:29:07 WARN  Using indexes to guess the definition of Chesspiece
2024.04.25 22:29:07 WARN  Using indexes to guess the definition of Chesspiece
2024.04.25 22:29:07 INFO  compiling root (4 scala sources)
2024.04.25 22:29:07 INFO  time: compiled root in 0.68s
2024.04.25 22:29:24 INFO  compiling root (4 scala sources)
2024.04.25 22:29:24 INFO  time: compiled root in 0.39s
2024.04.25 22:29:37 INFO  compiling root (4 scala sources)
2024.04.25 22:29:37 INFO  time: compiled root in 0.47s
2024.04.25 22:29:51 WARN  Using indexes to guess the definition of BISHOP
2024.04.25 22:29:53 INFO  compiling root (4 scala sources)
2024.04.25 22:29:53 INFO  time: compiled root in 0.35s
Apr. 25, 2024 10:29:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2292
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2292
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2292
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:55)
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:52)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:213)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:210)
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:98)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckFromToIndex(Preconditions.java:112)
	at java.base/jdk.internal.util.Preconditions.checkFromToIndex(Preconditions.java:349)
	at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4602)
	at java.base/java.lang.String.substring(String.java:2715)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.25 22:29:58 WARN  Using indexes to guess the definition of KNIGHT
2024.04.25 22:29:59 WARN  Using indexes to guess the definition of KNIGHT
Apr. 25, 2024 10:30:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2292
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2292
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2292
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:55)
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:52)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:213)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:210)
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:98)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckFromToIndex(Preconditions.java:112)
	at java.base/jdk.internal.util.Preconditions.checkFromToIndex(Preconditions.java:349)
	at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4602)
	at java.base/java.lang.String.substring(String.java:2715)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.25 22:30:01 WARN  Using indexes to guess the definition of KNIGHT
Apr. 25, 2024 10:30:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2303
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2303
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2303
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:55)
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:52)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:213)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:210)
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:98)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckFromToIndex(Preconditions.java:112)
	at java.base/jdk.internal.util.Preconditions.checkFromToIndex(Preconditions.java:349)
	at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4602)
	at java.base/java.lang.String.substring(String.java:2715)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.25 22:30:02 WARN  Using indexes to guess the definition of Chesspiece
Apr. 25, 2024 10:30:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1066
Apr. 25, 2024 10:30:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2303
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2303
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2303
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:55)
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:52)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:213)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:210)
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:98)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckFromToIndex(Preconditions.java:112)
	at java.base/jdk.internal.util.Preconditions.checkFromToIndex(Preconditions.java:349)
	at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4602)
	at java.base/java.lang.String.substring(String.java:2715)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.25 22:30:02 WARN  Using indexes to guess the definition of BISHOP
Apr. 25, 2024 10:30:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1072
2024.04.25 22:30:03 WARN  Using indexes to guess the definition of QUEEN
Apr. 25, 2024 10:30:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2314
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2314
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2314
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:55)
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:52)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:213)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:210)
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:98)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckFromToIndex(Preconditions.java:112)
	at java.base/jdk.internal.util.Preconditions.checkFromToIndex(Preconditions.java:349)
	at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4602)
	at java.base/java.lang.String.substring(String.java:2715)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.25 22:30:03 WARN  Using indexes to guess the definition of QUEEN
Apr. 25, 2024 10:30:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2314
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2314
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.StringIndexOutOfBoundsException: Range [2308, 2325) out of bounds for length 2314
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:55)
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:52)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:213)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:210)
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:98)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckFromToIndex(Preconditions.java:112)
	at java.base/jdk.internal.util.Preconditions.checkFromToIndex(Preconditions.java:349)
	at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4602)
	at java.base/java.lang.String.substring(String.java:2715)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.25 22:30:04 WARN  Using indexes to guess the definition of Chesspiece
2024.04.25 22:30:05 WARN  Using indexes to guess the definition of KING
2024.04.25 22:30:05 WARN  Using indexes to guess the definition of PAWN
2024.04.25 22:30:06 WARN  Using indexes to guess the definition of PAWN
2024.04.25 22:30:06 WARN  Using indexes to guess the definition of Chesspiece
2024.04.25 22:30:07 INFO  compiling root (4 scala sources)
2024.04.25 22:30:07 INFO  time: compiled root in 0.33s
Apr. 25, 2024 10:30:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.StringIndexOutOfBoundsException: Index 2406 out of bounds for length 2347
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: Index 2406 out of bounds for length 2347
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.StringIndexOutOfBoundsException: Index 2406 out of bounds for length 2347
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:55)
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:52)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:213)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:210)
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:98)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:106)
	at java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:302)
	at java.base/java.lang.String.checkIndex(String.java:4570)
	at java.base/java.lang.StringLatin1.charAt(StringLatin1.java:46)
	at java.base/java.lang.String.charAt(String.java:1527)
	at scala.collection.StringOps$.apply$extension(StringOps.scala:190)
	at scala.meta.internal.metals.codeactions.ExtractValueCodeAction.$anonfun$contribute$13(ExtractValueCodeAction.scala:60)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.ExtractValueCodeAction.$anonfun$contribute$12(ExtractValueCodeAction.scala:57)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.ExtractValueCodeAction.$anonfun$contribute$9(ExtractValueCodeAction.scala:55)
	at scala.Option$WithFilter.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.ExtractValueCodeAction.$anonfun$contribute$7(ExtractValueCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.ExtractValueCodeAction.$anonfun$contribute$6(ExtractValueCodeAction.scala:51)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.metals.codeactions.ExtractValueCodeAction.$anonfun$contribute$1(ExtractValueCodeAction.scala:49)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.25 22:30:47 INFO  compiling root (4 scala sources)
2024.04.25 22:30:47 INFO  time: compiled root in 0.32s
2024.04.25 22:31:04 INFO  compiling root (4 scala sources)
2024.04.25 22:31:04 INFO  time: compiled root in 0.42s
2024.04.25 22:31:30 INFO  compiling root (4 scala sources)
2024.04.25 22:31:30 INFO  time: compiled root in 0.37s
2024.04.25 22:31:34 INFO  compiling root (4 scala sources)
2024.04.25 22:31:34 INFO  time: compiled root in 0.33s
2024.04.25 22:31:43 INFO  compiling root (4 scala sources)
2024.04.25 22:31:43 INFO  time: compiled root in 0.34s
2024.04.25 22:31:45 INFO  compiling root (4 scala sources)
2024.04.25 22:31:45 INFO  time: compiled root in 0.34s
Apr. 25, 2024 10:31:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1362
2024.04.25 22:32:38 INFO  compiling root (4 scala sources)
2024.04.25 22:32:38 INFO  time: compiled root in 0.33s
Apr. 25, 2024 10:32:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1477
2024.04.25 22:33:11 INFO  compiling root (4 scala sources)
2024.04.25 22:33:11 INFO  time: compiled root in 0.3s
2024.04.25 22:33:16 INFO  compiling root (4 scala sources)
2024.04.25 22:33:16 INFO  time: compiled root in 0.34s
2024.04.25 22:34:05 INFO  compiling root (4 scala sources)
2024.04.25 22:34:05 INFO  time: compiled root in 0.29s
Apr. 25, 2024 10:37:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2211
2024.04.25 22:39:16 INFO  compiling root (4 scala sources)
2024.04.25 22:39:16 INFO  time: compiled root in 0.36s
2024.04.25 22:39:22 INFO  compiling root (4 scala sources)
2024.04.25 22:39:22 INFO  time: compiled root in 0.28s
2024.04.25 22:39:51 INFO  compiling root (4 scala sources)
2024.04.25 22:39:51 INFO  time: compiled root in 0.31s
Apr. 25, 2024 10:40:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2463
Apr. 25, 2024 10:40:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2479
Apr. 25, 2024 10:40:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2499
2024.04.25 22:40:46 INFO  compiling root (4 scala sources)
2024.04.25 22:40:46 INFO  time: compiled root in 0.31s
2024.04.25 22:41:02 INFO  compiling root (4 scala sources)
2024.04.25 22:41:02 INFO  time: compiled root in 0.24s
Apr. 25, 2024 10:41:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2549
2024.04.25 22:41:55 INFO  compiling root (4 scala sources)
2024.04.25 22:41:55 INFO  time: compiled root in 0.26s
2024.04.25 22:41:57 INFO  compiling root (4 scala sources)
2024.04.25 22:41:57 INFO  time: compiled root in 0.27s
2024.04.25 22:41:58 INFO  compiling root (4 scala sources)
2024.04.25 22:41:58 INFO  time: compiled root in 0.28s
2024.04.25 22:42:10 INFO  compiling root (4 scala sources)
2024.04.25 22:42:10 INFO  time: compiled root in 0.3s
2024.04.25 22:42:20 INFO  compiling root (4 scala sources)
2024.04.25 22:42:20 INFO  time: compiled root in 0.2s
2024.04.25 22:42:43 INFO  compiling root (4 scala sources)
2024.04.25 22:42:43 INFO  time: compiled root in 0.22s
2024.04.25 22:42:46 WARN  Using indexes to guess the definition of x
2024.04.25 22:43:44 INFO  compiling root (4 scala sources)
2024.04.25 22:43:44 INFO  time: compiled root in 0.28s
2024.04.25 22:44:30 INFO  compiling root (4 scala sources)
2024.04.25 22:44:30 INFO  time: compiled root in 0.29s
2024.04.25 22:44:35 WARN  Using indexes to guess the definition of int
2024.04.25 22:44:35 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar!/scala/compiletime/ops/int.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar!/scala/compiletime/ops/int.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 25, 2024 10:44:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar%21/scala/compiletime/ops/int.scala",
      "languageId": "scala",
      "version": 1,
      "text": "package scala.compiletime\npackage ops\n\nobject int:\n  /** Successor of a natural number where zero is the type 0 and successors are reduced as if the definition was:\n   *\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  type S[N \u003c: Int] \u003c: Int \u003d N match {\n   *    case 0 \u003d\u003e 1\n   *    case 1 \u003d\u003e 2\n   *    case 2 \u003d\u003e 3\n   *    // ...\n   *    case 2147483646 \u003d\u003e 2147483647\n   *  }\n   *  ```\n   *  @syntax markdown\n   */\n  type S[N \u003c: Int] \u003c: Int\n\n  /** Addition of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val sum: 2 + 2 \u003d 4\n   *  ```\n   *  @syntax markdown\n   */\n  type +[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Subtraction of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val sub: 4 - 2 \u003d 2\n   *  ```\n   *  @syntax markdown\n   */\n  type -[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Multiplication of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val mul: 4 * 2 \u003d 8\n   *  ```\n   *  @syntax markdown\n   */\n  type *[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Integer division of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val div: 5 / 2 \u003d 2\n   *  ```\n   *  @syntax markdown\n   */\n  type /[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Remainder of the division of `X` by `Y`.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val mod: 5 % 2 \u003d 1\n   *  ```\n   *  @syntax markdown\n   */\n  type %[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Binary left shift of `X` by `Y`.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val lshift: 1 \u003c\u003c 2 \u003d 4\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003c\u003c[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Binary right shift of `X` by `Y`.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val rshift: 10 \u003e\u003e 1 \u003d 5\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003e\u003e[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Binary right shift of `X` by `Y`, filling the left with zeros.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val rshiftzero: 10 \u003e\u003e\u003e 1 \u003d 5\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003e\u003e\u003e[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Bitwise xor of `X` and `Y`.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val xor: 10 ^ 30 \u003d 20\n   *  ```\n   *  @syntax markdown\n   */\n  type ^[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Less-than comparison of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val lt1: 4 \u003c 2 \u003d false\n   *  val lt2: 2 \u003c 4 \u003d true\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003c[X \u003c: Int, Y \u003c: Int] \u003c: Boolean\n\n  /** Greater-than comparison of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val gt1: 4 \u003e 2 \u003d true\n   *  val gt2: 2 \u003e 2 \u003d false\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003e[X \u003c: Int, Y \u003c: Int] \u003c: Boolean\n\n  /** Greater-or-equal comparison of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val ge1: 4 \u003e\u003d 2 \u003d true\n   *  val ge2: 2 \u003e\u003d 3 \u003d false\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003e\u003d[X \u003c: Int, Y \u003c: Int] \u003c: Boolean\n\n  /** Less-or-equal comparison of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val lt1: 4 \u003c\u003d 2 \u003d false\n   *  val lt2: 2 \u003c\u003d 2 \u003d true\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003c\u003d[X \u003c: Int, Y \u003c: Int] \u003c: Boolean\n\n  /** Bitwise and of `X` and `Y`.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val and1: BitwiseAnd[4, 4] \u003d 4\n   *  val and2: BitwiseAnd[10, 5] \u003d 0\n   *  ```\n   *  @syntax markdown\n   */\n  type BitwiseAnd[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Bitwise or of `X` and `Y`.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val or: BitwiseOr[10, 11] \u003d 11\n   *  ```\n   *  @syntax markdown\n   */\n  type BitwiseOr[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Absolute value of an `Int` singleton type.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val abs: Abs[-1] \u003d 1\n   *  ```\n   *  @syntax markdown\n   */\n  type Abs[X \u003c: Int] \u003c: Int\n\n  /** Negation of an `Int` singleton type.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val neg1: Negate[-1] \u003d 1\n   *  val neg2: Negate[1] \u003d -1\n   *  ```\n   *  @syntax markdown\n   */\n  type Negate[X \u003c: Int] \u003c: Int\n\n  /** Minimum of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val min: Min[-1, 1] \u003d -1\n   *  ```\n   *  @syntax markdown\n   */\n  type Min[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Maximum of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val max: Max[-1, 1] \u003d 1\n   *  ```\n   *  @syntax markdown\n   */\n  type Max[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** String conversion of an `Int` singleton type.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val abs: ToString[1] \u003d \"1\"\n   *  ```\n   *  @syntax markdown\n   */\n  @deprecated(\"Use compiletime.ops.any.ToString instead.\",\"3.2.0\")\n  type ToString[X \u003c: Int] \u003c: String\n\n  /** Long conversion of an `Int` singleton type.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val x: ToLong[1] \u003d 1L\n   *  ```\n   *  @syntax markdown\n   */\n  type ToLong[X \u003c: Int] \u003c: Long\n\n  /** Float conversion of an `Int` singleton type.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val x: ToFloat[1] \u003d 1.0f\n   *  ```\n   *  @syntax markdown\n   */\n  type ToFloat[X \u003c: Int] \u003c: Float\n\n  /** Double conversion of an `Int` singleton type.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val x: ToDouble[1] \u003d 1.0\n   *  ```\n   *  @syntax markdown\n   */\n  type ToDouble[X \u003c: Int] \u003c: Double\n\n  /** Number of zero bits preceding the highest-order (\"leftmost\")\n   * one-bit in the two\u0027s complement binary representation of the specified `Int` singleton type.\n   * Returns 32 if the specified singleton type has no one-bits in its two\u0027s complement representation,\n   * in other words if it is equal to zero.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val zero_lzc: NumberOfLeadingZeros[0] \u003d 32\n   *  val eight_lzc: NumberOfLeadingZeros[8] \u003d 28\n   *  type Log2[N \u003c: Int] \u003d 31 - NumberOfLeadingZeros[N]\n   *  val log2of8: Log2[8] \u003d 3\n   *  ```\n   *  @syntax markdown\n   */\n  type NumberOfLeadingZeros[X \u003c: Int] \u003c: Int\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar!/scala/compiletime/ops/int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar!/scala/compiletime/ops/int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 25, 2024 10:44:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar%21/scala/compiletime/ops/int.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar!/scala/compiletime/ops/int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar!/scala/compiletime/ops/int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.25 22:44:35 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar!/scala/compiletime/ops/int.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar!/scala/compiletime/ops/int.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 25, 2024 10:44:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar%21/scala/compiletime/ops/int.scala",
      "languageId": "scala",
      "version": 1,
      "text": "package scala.compiletime\npackage ops\n\nobject int:\n  /** Successor of a natural number where zero is the type 0 and successors are reduced as if the definition was:\n   *\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  type S[N \u003c: Int] \u003c: Int \u003d N match {\n   *    case 0 \u003d\u003e 1\n   *    case 1 \u003d\u003e 2\n   *    case 2 \u003d\u003e 3\n   *    // ...\n   *    case 2147483646 \u003d\u003e 2147483647\n   *  }\n   *  ```\n   *  @syntax markdown\n   */\n  type S[N \u003c: Int] \u003c: Int\n\n  /** Addition of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val sum: 2 + 2 \u003d 4\n   *  ```\n   *  @syntax markdown\n   */\n  type +[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Subtraction of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val sub: 4 - 2 \u003d 2\n   *  ```\n   *  @syntax markdown\n   */\n  type -[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Multiplication of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val mul: 4 * 2 \u003d 8\n   *  ```\n   *  @syntax markdown\n   */\n  type *[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Integer division of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val div: 5 / 2 \u003d 2\n   *  ```\n   *  @syntax markdown\n   */\n  type /[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Remainder of the division of `X` by `Y`.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val mod: 5 % 2 \u003d 1\n   *  ```\n   *  @syntax markdown\n   */\n  type %[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Binary left shift of `X` by `Y`.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val lshift: 1 \u003c\u003c 2 \u003d 4\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003c\u003c[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Binary right shift of `X` by `Y`.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val rshift: 10 \u003e\u003e 1 \u003d 5\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003e\u003e[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Binary right shift of `X` by `Y`, filling the left with zeros.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val rshiftzero: 10 \u003e\u003e\u003e 1 \u003d 5\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003e\u003e\u003e[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Bitwise xor of `X` and `Y`.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val xor: 10 ^ 30 \u003d 20\n   *  ```\n   *  @syntax markdown\n   */\n  type ^[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Less-than comparison of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val lt1: 4 \u003c 2 \u003d false\n   *  val lt2: 2 \u003c 4 \u003d true\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003c[X \u003c: Int, Y \u003c: Int] \u003c: Boolean\n\n  /** Greater-than comparison of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val gt1: 4 \u003e 2 \u003d true\n   *  val gt2: 2 \u003e 2 \u003d false\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003e[X \u003c: Int, Y \u003c: Int] \u003c: Boolean\n\n  /** Greater-or-equal comparison of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val ge1: 4 \u003e\u003d 2 \u003d true\n   *  val ge2: 2 \u003e\u003d 3 \u003d false\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003e\u003d[X \u003c: Int, Y \u003c: Int] \u003c: Boolean\n\n  /** Less-or-equal comparison of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val lt1: 4 \u003c\u003d 2 \u003d false\n   *  val lt2: 2 \u003c\u003d 2 \u003d true\n   *  ```\n   *  @syntax markdown\n   */\n  type \u003c\u003d[X \u003c: Int, Y \u003c: Int] \u003c: Boolean\n\n  /** Bitwise and of `X` and `Y`.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val and1: BitwiseAnd[4, 4] \u003d 4\n   *  val and2: BitwiseAnd[10, 5] \u003d 0\n   *  ```\n   *  @syntax markdown\n   */\n  type BitwiseAnd[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Bitwise or of `X` and `Y`.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val or: BitwiseOr[10, 11] \u003d 11\n   *  ```\n   *  @syntax markdown\n   */\n  type BitwiseOr[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Absolute value of an `Int` singleton type.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val abs: Abs[-1] \u003d 1\n   *  ```\n   *  @syntax markdown\n   */\n  type Abs[X \u003c: Int] \u003c: Int\n\n  /** Negation of an `Int` singleton type.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val neg1: Negate[-1] \u003d 1\n   *  val neg2: Negate[1] \u003d -1\n   *  ```\n   *  @syntax markdown\n   */\n  type Negate[X \u003c: Int] \u003c: Int\n\n  /** Minimum of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val min: Min[-1, 1] \u003d -1\n   *  ```\n   *  @syntax markdown\n   */\n  type Min[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** Maximum of two `Int` singleton types.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val max: Max[-1, 1] \u003d 1\n   *  ```\n   *  @syntax markdown\n   */\n  type Max[X \u003c: Int, Y \u003c: Int] \u003c: Int\n\n  /** String conversion of an `Int` singleton type.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val abs: ToString[1] \u003d \"1\"\n   *  ```\n   *  @syntax markdown\n   */\n  @deprecated(\"Use compiletime.ops.any.ToString instead.\",\"3.2.0\")\n  type ToString[X \u003c: Int] \u003c: String\n\n  /** Long conversion of an `Int` singleton type.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val x: ToLong[1] \u003d 1L\n   *  ```\n   *  @syntax markdown\n   */\n  type ToLong[X \u003c: Int] \u003c: Long\n\n  /** Float conversion of an `Int` singleton type.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val x: ToFloat[1] \u003d 1.0f\n   *  ```\n   *  @syntax markdown\n   */\n  type ToFloat[X \u003c: Int] \u003c: Float\n\n  /** Double conversion of an `Int` singleton type.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val x: ToDouble[1] \u003d 1.0\n   *  ```\n   *  @syntax markdown\n   */\n  type ToDouble[X \u003c: Int] \u003c: Double\n\n  /** Number of zero bits preceding the highest-order (\"leftmost\")\n   * one-bit in the two\u0027s complement binary representation of the specified `Int` singleton type.\n   * Returns 32 if the specified singleton type has no one-bits in its two\u0027s complement representation,\n   * in other words if it is equal to zero.\n   *  ```scala\n   *  //{\n   *  import compiletime.ops.int.*\n   *  //}\n   *  val zero_lzc: NumberOfLeadingZeros[0] \u003d 32\n   *  val eight_lzc: NumberOfLeadingZeros[8] \u003d 28\n   *  type Log2[N \u003c: Int] \u003d 31 - NumberOfLeadingZeros[N]\n   *  val log2of8: Log2[8] \u003d 3\n   *  ```\n   *  @syntax markdown\n   */\n  type NumberOfLeadingZeros[X \u003c: Int] \u003c: Int\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar!/scala/compiletime/ops/int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar!/scala/compiletime/ops/int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.25 22:45:04 INFO  compiling root (4 scala sources)
2024.04.25 22:45:04 INFO  time: compiled root in 0.28s
2024.04.25 22:45:36 INFO  compiling root (4 scala sources)
2024.04.25 22:45:36 INFO  time: compiled root in 0.23s
2024.04.25 22:45:39 INFO  compiling root (4 scala sources)
2024.04.25 22:45:39 INFO  time: compiled root in 0.24s
2024.04.25 22:45:53 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:56: error: unclosed string interpolation
    println(s"$colorText $pieceTypeText auf Position (${piece.getCords})
                                                                       ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:666)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:252)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.25 22:46:00 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:56: error: unclosed string literal
    println(s"$colorText $pieceTypeText auf Position (${piece.getCords}, ${piece..")
                                                                                  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.25 22:46:00 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:56: error: unclosed string interpolation
    println(s"$colorText $pieceTypeText auf Position (${piece.getCords}, ${piec")
                                                                                ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:666)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:364)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.25 22:46:01 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:56: error: unclosed string literal
    println(s"$colorText $pieceTypeText auf Position (${piece.getCords}, ${")
                                                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

Apr. 25, 2024 10:46:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3347
2024.04.25 22:46:38 INFO  compiling root (4 scala sources)
2024.04.25 22:46:38 INFO  time: compiled root in 0.25s
2024.04.25 22:47:17 INFO  compiling root (4 scala sources)
2024.04.25 22:47:17 INFO  time: compiled root in 0.2s
2024.04.25 22:47:22 INFO  compiling root (4 scala sources)
2024.04.25 22:47:22 INFO  time: compiled root in 0.2s
Apr. 25, 2024 10:47:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar%21/scala/compiletime/ops/int.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar!/scala/compiletime/ops/int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.4.1/scala3-library_3-3.4.1-sources.jar!/scala/compiletime/ops/int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.25 22:47:37 WARN  Using indexes to guess the definition of Pieces
2024.04.25 22:47:37 WARN  Using indexes to guess the definition of Chesspiece
2024.04.25 22:48:09 INFO  compiling root (4 scala sources)
2024.04.25 22:48:09 INFO  time: compiled root in 0.16s
2024.04.25 22:48:11 INFO  compiling root (4 scala sources)
2024.04.25 22:48:11 INFO  time: compiled root in 0.11s
2024.04.25 22:48:11 INFO  compiling root (4 scala sources)
2024.04.25 22:48:11 INFO  time: compiled root in 0.14s
2024.04.25 22:48:18 WARN  Using indexes to guess the definition of Pieces
2024.04.25 22:48:18 WARN  Using indexes to guess the definition of Chesspiece
2024.04.25 22:48:19 WARN  Using indexes to guess the definition of Chesspiece
2024.04.25 22:48:20 INFO  compiling root (4 scala sources)
2024.04.25 22:48:21 INFO  time: compiled root in 1.49s
Apr. 25, 2024 10:48:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3587
Apr. 25, 2024 10:49:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3609
2024.04.25 22:49:56 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:53: error: illegal character '\ufe0f'
      case Chesspiece.BISHOP => "Läufer"♟️
                                         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:476)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:481)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.25 22:50:05 INFO  compiling root (1 scala source)
2024.04.25 22:50:05 INFO  time: compiled root in 0.31s
2024.04.25 22:51:10 INFO  compiling root (1 scala source)
2024.04.25 22:51:10 INFO  time: compiled root in 0.27s
Apr. 25, 2024 10:51:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3764
2024.04.25 22:52:43 INFO  compiling root (1 scala source)
2024.04.25 22:52:43 INFO  time: compiled root in 0.24s
2024.04.25 22:52:47 INFO  compiling root (1 scala source)
2024.04.25 22:52:47 INFO  time: compiled root in 0.28s
2024.04.25 22:53:11 INFO  compiling root (1 scala source)
2024.04.25 22:53:11 INFO  time: compiled root in 0.24s
Apr. 25, 2024 10:53:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3910
2024.04.25 22:53:48 INFO  compiling root (1 scala source)
2024.04.25 22:53:48 INFO  time: compiled root in 0.23s
2024.04.25 22:53:48 INFO  compiling root (1 scala source)
2024.04.25 22:53:48 INFO  time: compiled root in 0.25s
2024.04.25 22:54:23 INFO  compiling root (1 scala source)
2024.04.25 22:54:23 INFO  time: compiled root in 0.33s
Apr. 25, 2024 10:54:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4001
2024.04.25 22:54:40 INFO  compiling root (2 scala sources)
2024.04.25 22:54:40 INFO  time: compiled root in 0.58s
Apr. 25, 2024 10:55:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4105
2024.04.25 22:55:31 INFO  compiling root (1 scala source)
2024.04.25 22:55:31 INFO  time: compiled root in 0.61s
2024.04.25 22:55:50 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.25 22:55:50 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.25 22:55:50 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.25 22:55:52 INFO  Loaded expression compiler in 1 second
2024.04.25 22:55:53 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\ch\epfl\scala\scala-debug-decoder_3\4.0.4\scala-debug-decoder_3-4.0.4.jar
2024.04.25 22:55:53 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala3-library_3\3.4.0\scala3-library_3-3.4.0.jar
2024.04.25 22:55:53 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\ch\epfl\scala\tasty-query_3\1.3.0\tasty-query_3-1.3.0.jar
2024.04.25 22:55:53 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\ow2\asm\asm\9.6\asm-9.6.jar
2024.04.25 22:55:53 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\ow2\asm\asm-util\9.6\asm-util-9.6.jar
2024.04.25 22:55:53 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.12\scala-library-2.13.12.jar
2024.04.25 22:55:53 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\ow2\asm\asm-tree\9.6\asm-tree-9.6.jar
2024.04.25 22:55:53 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\ow2\asm\asm-analysis\9.6\asm-analysis-9.6.jar
2024.04.25 22:55:53 INFO  Loaded step filter in 1 second
2024.04.25 22:55:56 INFO  Loaded all sources and classes in 2 seconds
2024.04.25 22:55:57 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:54260 .
2024.04.25 22:55:57 INFO  Attaching to debuggee VM succeeded.
2024.04.25 22:55:57 INFO  Closing debug server tcp://0.0.0.0:54257
2024.04.25 22:55:57 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.25 22:56:52 INFO  compiling root (1 scala source)
2024.04.25 22:56:52 INFO  time: compiled root in 0.14s
2024.04.25 22:56:54 INFO  compiling root (1 scala source)
2024.04.25 22:56:54 INFO  time: compiled root in 0.28s
2024.04.25 22:57:16 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 25, 2024 10:57:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\nimport scala.annotation.migration\n\n/**\n * Core Scala types. They are always available without an explicit import.\n * @contentDiagram hideNodes \"scala.Serializable\"\n */\npackage object scala {\n  type Cloneable    \u003d java.lang.Cloneable\n  type Serializable \u003d java.io.Serializable\n\n  type Throwable \u003d java.lang.Throwable\n  type Exception \u003d java.lang.Exception\n  type Error     \u003d java.lang.Error\n\n  type RuntimeException                \u003d java.lang.RuntimeException\n  type NullPointerException            \u003d java.lang.NullPointerException\n  type ClassCastException              \u003d java.lang.ClassCastException\n  type IndexOutOfBoundsException       \u003d java.lang.IndexOutOfBoundsException\n  type ArrayIndexOutOfBoundsException  \u003d java.lang.ArrayIndexOutOfBoundsException\n  type StringIndexOutOfBoundsException \u003d java.lang.StringIndexOutOfBoundsException\n  type UnsupportedOperationException   \u003d java.lang.UnsupportedOperationException\n  type IllegalArgumentException        \u003d java.lang.IllegalArgumentException\n  type NoSuchElementException          \u003d java.util.NoSuchElementException\n  type NumberFormatException           \u003d java.lang.NumberFormatException\n  type AbstractMethodError             \u003d java.lang.AbstractMethodError\n  type InterruptedException            \u003d java.lang.InterruptedException\n\n  // A dummy used by the specialization annotation.\n  val AnyRef \u003d new Specializable {\n    override def toString \u003d \"object AnyRef\"\n  }\n\n  @deprecated(\"Use IterableOnce instead of TraversableOnce\", \"2.13.0\")\n  type TraversableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  type IterableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  type Traversable[+A] \u003d scala.collection.Iterable[A]\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  val Traversable \u003d scala.collection.Iterable\n\n  type Iterable[+A] \u003d scala.collection.Iterable[A]\n  val Iterable \u003d scala.collection.Iterable\n\n  @migration(\"scala.Seq is now scala.collection.immutable.Seq instead of scala.collection.Seq\", \"2.13.0\")\n  type Seq[+A] \u003d scala.collection.immutable.Seq[A]\n  val Seq \u003d scala.collection.immutable.Seq\n\n  @migration(\"scala.IndexedSeq is now scala.collection.immutable.IndexedSeq instead of scala.collection.IndexedSeq\", \"2.13.0\")\n  type IndexedSeq[+A] \u003d scala.collection.immutable.IndexedSeq[A]\n  val IndexedSeq \u003d scala.collection.immutable.IndexedSeq\n\n  type Iterator[+A] \u003d scala.collection.Iterator[A]\n  val Iterator \u003d scala.collection.Iterator\n\n  @deprecated(\"Use scala.collection.BufferedIterator instead of scala.BufferedIterator\", \"2.13.0\")\n  type BufferedIterator[+A] \u003d scala.collection.BufferedIterator[A]\n\n  type List[+A] \u003d scala.collection.immutable.List[A]\n  val List \u003d scala.collection.immutable.List\n\n  val Nil \u003d scala.collection.immutable.Nil\n\n  type ::[+A] \u003d scala.collection.immutable.::[A]\n  val :: \u003d scala.collection.immutable.::\n\n  val +: \u003d scala.collection.+:\n  val :+ \u003d scala.collection.:+\n\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  type Stream[+A] \u003d scala.collection.immutable.Stream[A]\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  val Stream \u003d scala.collection.immutable.Stream\n\n  type LazyList[+A] \u003d scala.collection.immutable.LazyList[A]\n  val LazyList \u003d scala.collection.immutable.LazyList\n  // This should be an alias to LazyList.#:: but we need to support Stream, too\n  //val #:: \u003d scala.collection.immutable.LazyList.#::\n  object #:: {\n    def unapply[A](s: LazyList[A]): Option[(A, LazyList[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n    @deprecated(\"Prefer LazyList instead\", since \u003d \"2.13.0\")\n    def unapply[A](s: Stream[A]): Option[(A, Stream[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n  }\n\n  type Vector[+A] \u003d scala.collection.immutable.Vector[A]\n  val Vector \u003d scala.collection.immutable.Vector\n\n  type StringBuilder \u003d scala.collection.mutable.StringBuilder\n  val StringBuilder \u003d scala.collection.mutable.StringBuilder\n\n  type Range \u003d scala.collection.immutable.Range\n  val Range \u003d scala.collection.immutable.Range\n\n  // Numeric types which were moved into scala.math.*\n\n  type BigDecimal \u003d scala.math.BigDecimal\n  val BigDecimal \u003d scala.math.BigDecimal\n\n  type BigInt \u003d scala.math.BigInt\n  val BigInt \u003d scala.math.BigInt\n\n  type Equiv[T] \u003d scala.math.Equiv[T]\n  val Equiv \u003d scala.math.Equiv\n\n  type Fractional[T] \u003d scala.math.Fractional[T]\n  val Fractional \u003d scala.math.Fractional\n\n  type Integral[T] \u003d scala.math.Integral[T]\n  val Integral \u003d scala.math.Integral\n\n  type Numeric[T] \u003d scala.math.Numeric[T]\n  val Numeric \u003d scala.math.Numeric\n\n  type Ordered[T] \u003d scala.math.Ordered[T]\n  val Ordered \u003d scala.math.Ordered\n\n  type Ordering[T] \u003d scala.math.Ordering[T]\n  val Ordering \u003d scala.math.Ordering\n\n  type PartialOrdering[T] \u003d scala.math.PartialOrdering[T]\n  type PartiallyOrdered[T] \u003d scala.math.PartiallyOrdered[T]\n\n  type Either[+A, +B] \u003d scala.util.Either[A, B]\n  val Either \u003d scala.util.Either\n\n  type Left[+A, +B] \u003d scala.util.Left[A, B]\n  val Left \u003d scala.util.Left\n\n  type Right[+A, +B] \u003d scala.util.Right[A, B]\n  val Right \u003d scala.util.Right\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 25, 2024 10:57:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.25 22:57:16 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 25, 2024 10:57:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\nimport scala.annotation.migration\n\n/**\n * Core Scala types. They are always available without an explicit import.\n * @contentDiagram hideNodes \"scala.Serializable\"\n */\npackage object scala {\n  type Cloneable    \u003d java.lang.Cloneable\n  type Serializable \u003d java.io.Serializable\n\n  type Throwable \u003d java.lang.Throwable\n  type Exception \u003d java.lang.Exception\n  type Error     \u003d java.lang.Error\n\n  type RuntimeException                \u003d java.lang.RuntimeException\n  type NullPointerException            \u003d java.lang.NullPointerException\n  type ClassCastException              \u003d java.lang.ClassCastException\n  type IndexOutOfBoundsException       \u003d java.lang.IndexOutOfBoundsException\n  type ArrayIndexOutOfBoundsException  \u003d java.lang.ArrayIndexOutOfBoundsException\n  type StringIndexOutOfBoundsException \u003d java.lang.StringIndexOutOfBoundsException\n  type UnsupportedOperationException   \u003d java.lang.UnsupportedOperationException\n  type IllegalArgumentException        \u003d java.lang.IllegalArgumentException\n  type NoSuchElementException          \u003d java.util.NoSuchElementException\n  type NumberFormatException           \u003d java.lang.NumberFormatException\n  type AbstractMethodError             \u003d java.lang.AbstractMethodError\n  type InterruptedException            \u003d java.lang.InterruptedException\n\n  // A dummy used by the specialization annotation.\n  val AnyRef \u003d new Specializable {\n    override def toString \u003d \"object AnyRef\"\n  }\n\n  @deprecated(\"Use IterableOnce instead of TraversableOnce\", \"2.13.0\")\n  type TraversableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  type IterableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  type Traversable[+A] \u003d scala.collection.Iterable[A]\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  val Traversable \u003d scala.collection.Iterable\n\n  type Iterable[+A] \u003d scala.collection.Iterable[A]\n  val Iterable \u003d scala.collection.Iterable\n\n  @migration(\"scala.Seq is now scala.collection.immutable.Seq instead of scala.collection.Seq\", \"2.13.0\")\n  type Seq[+A] \u003d scala.collection.immutable.Seq[A]\n  val Seq \u003d scala.collection.immutable.Seq\n\n  @migration(\"scala.IndexedSeq is now scala.collection.immutable.IndexedSeq instead of scala.collection.IndexedSeq\", \"2.13.0\")\n  type IndexedSeq[+A] \u003d scala.collection.immutable.IndexedSeq[A]\n  val IndexedSeq \u003d scala.collection.immutable.IndexedSeq\n\n  type Iterator[+A] \u003d scala.collection.Iterator[A]\n  val Iterator \u003d scala.collection.Iterator\n\n  @deprecated(\"Use scala.collection.BufferedIterator instead of scala.BufferedIterator\", \"2.13.0\")\n  type BufferedIterator[+A] \u003d scala.collection.BufferedIterator[A]\n\n  type List[+A] \u003d scala.collection.immutable.List[A]\n  val List \u003d scala.collection.immutable.List\n\n  val Nil \u003d scala.collection.immutable.Nil\n\n  type ::[+A] \u003d scala.collection.immutable.::[A]\n  val :: \u003d scala.collection.immutable.::\n\n  val +: \u003d scala.collection.+:\n  val :+ \u003d scala.collection.:+\n\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  type Stream[+A] \u003d scala.collection.immutable.Stream[A]\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  val Stream \u003d scala.collection.immutable.Stream\n\n  type LazyList[+A] \u003d scala.collection.immutable.LazyList[A]\n  val LazyList \u003d scala.collection.immutable.LazyList\n  // This should be an alias to LazyList.#:: but we need to support Stream, too\n  //val #:: \u003d scala.collection.immutable.LazyList.#::\n  object #:: {\n    def unapply[A](s: LazyList[A]): Option[(A, LazyList[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n    @deprecated(\"Prefer LazyList instead\", since \u003d \"2.13.0\")\n    def unapply[A](s: Stream[A]): Option[(A, Stream[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n  }\n\n  type Vector[+A] \u003d scala.collection.immutable.Vector[A]\n  val Vector \u003d scala.collection.immutable.Vector\n\n  type StringBuilder \u003d scala.collection.mutable.StringBuilder\n  val StringBuilder \u003d scala.collection.mutable.StringBuilder\n\n  type Range \u003d scala.collection.immutable.Range\n  val Range \u003d scala.collection.immutable.Range\n\n  // Numeric types which were moved into scala.math.*\n\n  type BigDecimal \u003d scala.math.BigDecimal\n  val BigDecimal \u003d scala.math.BigDecimal\n\n  type BigInt \u003d scala.math.BigInt\n  val BigInt \u003d scala.math.BigInt\n\n  type Equiv[T] \u003d scala.math.Equiv[T]\n  val Equiv \u003d scala.math.Equiv\n\n  type Fractional[T] \u003d scala.math.Fractional[T]\n  val Fractional \u003d scala.math.Fractional\n\n  type Integral[T] \u003d scala.math.Integral[T]\n  val Integral \u003d scala.math.Integral\n\n  type Numeric[T] \u003d scala.math.Numeric[T]\n  val Numeric \u003d scala.math.Numeric\n\n  type Ordered[T] \u003d scala.math.Ordered[T]\n  val Ordered \u003d scala.math.Ordered\n\n  type Ordering[T] \u003d scala.math.Ordering[T]\n  val Ordering \u003d scala.math.Ordering\n\n  type PartialOrdering[T] \u003d scala.math.PartialOrdering[T]\n  type PartiallyOrdered[T] \u003d scala.math.PartiallyOrdered[T]\n\n  type Either[+A, +B] \u003d scala.util.Either[A, B]\n  val Either \u003d scala.util.Either\n\n  type Left[+A, +B] \u003d scala.util.Left[A, B]\n  val Left \u003d scala.util.Left\n\n  type Right[+A, +B] \u003d scala.util.Right[A, B]\n  val Right \u003d scala.util.Right\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.25 22:57:38 INFO  compiling root (2 scala sources)
2024.04.25 22:57:38 INFO  time: compiled root in 0.47s
2024.04.25 22:57:48 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 35m 50.477s)
2024.04.25 22:57:48 INFO  compiling root-test (3 scala sources)
2024.04.25 22:57:48 INFO  time: compiled root-test in 0.64s
2024.04.25 22:57:49 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.25 22:57:49 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.25 22:57:49 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.25 22:57:48 INFO  Loaded expression compiler in 0 milliseconds
2024.04.25 22:57:48 INFO  Loaded step filter in 0 milliseconds
2024.04.25 22:57:50 INFO  Loaded all sources and classes in 1 second
2024.04.25 22:57:50 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:54324 .
2024.04.25 22:57:50 INFO  Attaching to debuggee VM succeeded.
2024.04.25 22:57:51 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.25 22:57:51 INFO  Closing debug server tcp://0.0.0.0:54322
2024.04.25 22:58:31 WARN  Could not find semantic tokens for: file:///C:/Users/Gewin%20Singh/Desktop/S/AIN3/SE/CHESS-SE-HTWG/src/main/scala/Chess/Chess.scala
2024.04.25 22:58:36 WARN  Could not find semantic tokens for: file:///C:/Users/Gewin%20Singh/Desktop/S/AIN3/SE/CHESS-SE-HTWG/src/main/scala/Chess/Chess.scala
2024.04.25 22:58:40 INFO  compiling root (1 scala source)
2024.04.25 22:58:40 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 36m 42.541s)
2024.04.25 22:58:40 INFO  time: compiled root in 0.18s
2024.04.25 22:58:40 INFO  compiling root (1 scala source)
2024.04.25 22:58:40 INFO  time: compiled root in 16ms
2024.04.25 22:58:40 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 36m 42.628s)
2024.04.25 22:58:40 INFO  compiling root (1 scala source)
2024.04.25 22:58:40 INFO  compiling root (1 scala source)
2024.04.25 22:58:40 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Chess.scala
scala.meta.tokenizers.TokenizeException: <input>:31: error: illegal character '\u0000'
  
^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:476)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:481)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.25 22:58:40 INFO  time: compiled root in 0.14s
2024.04.25 22:58:40 INFO  {
  "jsonrpc": "2.0",
  "id": "277",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.25 22:58:40 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:509)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:509)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:484)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.25 22:58:40 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Chess.scala
scala.meta.tokenizers.TokenizeException: <input>:31: error: illegal character '\u0000'
  
^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:476)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:481)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.25 22:58:49 INFO  compiling root (1 scala source)
2024.04.25 22:58:49 INFO  time: compiled root in 0.1s
2024.04.25 22:58:49 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Chess.scala
scala.meta.tokenizers.TokenizeException: <input>:31: error: illegal character '\u0000'
  
^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:476)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:481)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.25 22:58:55 WARN  Could not find semantic tokens for: file:///C:/Users/Gewin%20Singh/Desktop/S/AIN3/SE/CHESS-SE-HTWG/src/main/scala/Chess/Chess.scala
2024.04.25 22:58:56 WARN  Could not find semantic tokens for: file:///C:/Users/Gewin%20Singh/Desktop/S/AIN3/SE/CHESS-SE-HTWG/src/main/scala/Chess/Chess.scala
2024.04.25 22:58:56 INFO  compiling root (1 scala source)
2024.04.25 22:58:56 INFO  time: compiled root in 0.11s
2024.04.25 22:58:56 INFO  compiling root (1 scala source)
2024.04.25 22:58:57 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Chess.scala
scala.meta.tokenizers.TokenizeException: <input>:31: error: illegal character '\u0000'
  
^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:476)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:481)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.25 22:58:56 INFO  time: compiled root in 0.24s
2024.04.25 22:58:57 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Chess.scala
scala.meta.tokenizers.TokenizeException: <input>:31: error: illegal character '\u0000'
  
^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:476)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:481)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.25 22:59:06 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Chess.scala
scala.meta.tokenizers.TokenizeException: <input>:31: error: illegal character '\u0000'
  
^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:476)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:481)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.25 22:59:09 INFO  compiling root (1 scala source)
2024.04.25 22:59:09 INFO  time: compiled root in 0.18s
2024.04.25 22:59:10 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Chess.scala
scala.meta.tokenizers.TokenizeException: <input>:31: error: illegal character '\u0000'
  
^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:476)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:481)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.25 22:59:36 INFO  compiling root (1 scala source)
2024.04.25 22:59:36 INFO  time: compiled root in 79ms
2024.04.25 22:59:36 INFO  compiling root (1 scala source)
2024.04.25 22:59:36 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 37m 38.565s)
2024.04.25 22:59:36 INFO  compiling root (1 scala source)
2024.04.25 22:59:36 INFO  time: compiled root in 0.22s
2024.04.25 22:59:36 INFO  compiling root-test (3 scala sources)
2024.04.25 22:59:36 INFO  time: compiled root-test in 0.33s
2024.04.25 22:59:39 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 37m 41.698s)
2024.04.25 22:59:39 INFO  compiling root-test (3 scala sources)
2024.04.25 22:59:39 INFO  time: compiled root-test in 0.3s
2024.04.25 22:59:39 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.25 22:59:39 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.25 22:59:40 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.25 22:59:39 INFO  Loaded expression compiler in 0 milliseconds
2024.04.25 22:59:39 INFO  Loaded step filter in 0 milliseconds
2024.04.25 22:59:41 INFO  Loaded all sources and classes in 1 second
2024.04.25 22:59:41 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:54397 .
2024.04.25 22:59:41 INFO  Attaching to debuggee VM succeeded.
2024.04.25 22:59:41 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.25 22:59:41 INFO  Closing debug server tcp://0.0.0.0:54378
2024.04.25 22:59:50 WARN  Could not find semantic tokens for: file:///C:/Users/Gewin%20Singh/Desktop/S/AIN3/SE/CHESS-SE-HTWG/src/main/scala/Chess/Chess.scala
2024.04.25 22:59:57 WARN  Could not find semantic tokens for: file:///C:/Users/Gewin%20Singh/Desktop/S/AIN3/SE/CHESS-SE-HTWG/src/main/scala/Chess/Chess.scala
2024.04.25 23:00:08 INFO  compiling root-test (3 scala sources)
2024.04.25 23:00:08 INFO  time: compiled root-test in 0.26s
2024.04.25 23:00:08 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.25 23:00:08 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.25 23:00:08 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.25 23:00:08 INFO  Loaded expression compiler in 1 millisecond
2024.04.25 23:00:08 INFO  Loaded step filter in 0 milliseconds
2024.04.25 23:00:09 INFO  Loaded all sources and classes in 1 second
2024.04.25 23:00:09 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:54427 .
2024.04.25 23:00:09 INFO  Attaching to debuggee VM succeeded.
2024.04.25 23:00:10 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.25 23:00:09 INFO  Closing debug server tcp://0.0.0.0:54424
Apr. 25, 2024 11:00:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.25 23:00:26 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 38m 28.529s)
2024.04.25 23:00:26 INFO  compiling root-test (3 scala sources)
2024.04.25 23:00:26 INFO  time: compiled root-test in 0.27s
2024.04.25 23:00:26 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.25 23:00:26 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.25 23:00:26 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.25 23:00:26 INFO  Loaded expression compiler in 0 milliseconds
2024.04.25 23:00:26 INFO  Loaded step filter in 0 milliseconds
2024.04.25 23:00:28 INFO  Loaded all sources and classes in 1 second
2024.04.25 23:00:28 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:54440 .
2024.04.25 23:00:28 INFO  Attaching to debuggee VM succeeded.
2024.04.25 23:00:28 INFO  Closing debug server tcp://0.0.0.0:54438
2024.04.25 23:00:29 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.25 23:06:17 INFO  Started: Metals version 1.3.0 in folders 'C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG' for client Visual Studio Code 1.88.1.
SLF4J: Class path contains multiple SLF4J providers.
SLF4J: Found provider [scribe.slf4j.ScribeServiceProvider@5c4e4666]
SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@798b636b]
SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual provider is of type [scribe.slf4j.ScribeServiceProvider@5c4e4666]
2024.04.25 23:06:21 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
Apr. 25, 2024 11:06:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3
Apr. 25, 2024 11:06:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4
2024.04.25 23:06:22 WARN  no build target for: C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
2024.04.25 23:06:22 INFO  Attempting to connect to the build server...
2024.04.25 23:06:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 23:06:27 INFO  Attempting to connect to the build server...
2024.04.25 23:06:27 INFO  Attempting to connect to the build server...
2024.04.25 23:06:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\project\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 23:06:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 23:06:27 INFO  time: Connected to build server in 5.28s
2024.04.25 23:06:27 INFO  Connected to Build server: Bloop v1.5.17
2024.04.25 23:06:27 INFO  time: Imported build in 0.42s
2024.04.25 23:06:35 INFO  no build target found for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.04.25 23:06:43 INFO  no build target found for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.04.25 23:07:04 INFO  time: indexed workspace in 28s
2024.04.25 23:07:04 INFO  compiling root-test (3 scala sources)
2024.04.25 23:07:08 INFO  time: compiled root-test in 3.5s
Apr. 25, 2024 11:07:22 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
2024.04.25 23:11:06 INFO  compiling root-test (3 scala sources)
2024.04.25 23:11:08 INFO  time: compiled root-test in 1.14s
2024.04.25 23:11:08 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.25 23:11:08 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.25 23:11:08 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.25 23:11:09 INFO  Loaded expression compiler in 719 milliseconds
2024.04.25 23:11:09 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\ch\epfl\scala\scala-debug-decoder_3\4.0.4\scala-debug-decoder_3-4.0.4.jar
2024.04.25 23:11:09 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala3-library_3\3.4.0\scala3-library_3-3.4.0.jar
2024.04.25 23:11:09 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\ch\epfl\scala\tasty-query_3\1.3.0\tasty-query_3-1.3.0.jar
2024.04.25 23:11:09 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\ow2\asm\asm\9.6\asm-9.6.jar
2024.04.25 23:11:09 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\ow2\asm\asm-util\9.6\asm-util-9.6.jar
2024.04.25 23:11:09 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.12\scala-library-2.13.12.jar
2024.04.25 23:11:09 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\ow2\asm\asm-tree\9.6\asm-tree-9.6.jar
2024.04.25 23:11:09 INFO  C:\Users\Gewin Singh\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\ow2\asm\asm-analysis\9.6\asm-analysis-9.6.jar
2024.04.25 23:11:09 INFO  Loaded step filter in 72 milliseconds
2024.04.25 23:11:11 INFO  Loaded all sources and classes in 2 seconds
2024.04.25 23:11:11 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:50480 .
2024.04.25 23:11:11 INFO  Attaching to debuggee VM succeeded.
2024.04.25 23:11:13 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.25 23:11:13 INFO  Closing debug server tcp://0.0.0.0:50477
2024.04.25 23:13:57 INFO  compiling root (1 scala source)
2024.04.25 23:13:58 INFO  time: compiled root in 1.46s
Apr. 25, 2024 11:14:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 268
Apr. 25, 2024 11:14:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 338
2024.04.25 23:14:50 INFO  compiling root (1 scala source)
2024.04.25 23:14:50 INFO  time: compiled root in 0.38s
Apr. 25, 2024 11:15:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 474
2024.04.25 23:17:30 INFO  compiling root (1 scala source)
2024.04.25 23:17:30 INFO  time: compiled root in 0.64s
Apr. 25, 2024 11:17:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 645
Apr. 25, 2024 11:18:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 653
2024.04.25 23:58:46 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Array.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Array.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 25, 2024 11:58:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Array.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\n//import scala.collection.generic._\nimport scala.collection.{Factory, immutable, mutable}\nimport mutable.ArrayBuilder\nimport immutable.ArraySeq\nimport scala.language.implicitConversions\nimport scala.reflect.{ClassTag, classTag}\nimport scala.runtime.BoxedUnit\nimport scala.runtime.ScalaRunTime\nimport scala.runtime.ScalaRunTime.{array_apply, array_update}\n\n/** Utility methods for operating on arrays.\n *  For example:\n *  {{{\n *  val a \u003d Array(1, 2)\n *  val b \u003d Array.ofDim[Int](2)\n *  val c \u003d Array.concat(a, b)\n *  }}}\n *  where the array objects `a`, `b` and `c` have respectively the values\n *  `Array(1, 2)`, `Array(0, 0)` and `Array(1, 2, 0, 0)`.\n */\nobject Array {\n  val emptyBooleanArray \u003d new Array[Boolean](0)\n  val emptyByteArray    \u003d new Array[Byte](0)\n  val emptyCharArray    \u003d new Array[Char](0)\n  val emptyDoubleArray  \u003d new Array[Double](0)\n  val emptyFloatArray   \u003d new Array[Float](0)\n  val emptyIntArray     \u003d new Array[Int](0)\n  val emptyLongArray    \u003d new Array[Long](0)\n  val emptyShortArray   \u003d new Array[Short](0)\n  val emptyObjectArray  \u003d new Array[Object](0)\n\n  /** Provides an implicit conversion from the Array object to a collection Factory */\n  implicit def toFactory[A : ClassTag](dummy: Array.type): Factory[A, Array[A]] \u003d new ArrayFactory(dummy)\n  @SerialVersionUID(3L)\n  private class ArrayFactory[A : ClassTag](dummy: Array.type) extends Factory[A, Array[A]] with Serializable {\n    def fromSpecific(it: IterableOnce[A]): Array[A] \u003d Array.from[A](it)\n    def newBuilder: mutable.Builder[A, Array[A]] \u003d Array.newBuilder[A]\n  }\n\n  /**\n   * Returns a new [[scala.collection.mutable.ArrayBuilder]].\n   */\n  def newBuilder[T](implicit t: ClassTag[T]): ArrayBuilder[T] \u003d ArrayBuilder.make[T](t)\n\n  /** Build an array from the iterable collection.\n   *\n   *  {{{\n   *  scala\u003e val a \u003d Array.from(Seq(1, 5))\n   *  val a: Array[Int] \u003d Array(1, 5)\n   *\n   *  scala\u003e val b \u003d Array.from(Range(1, 5))\n   *  val b: Array[Int] \u003d Array(1, 2, 3, 4)\n   *  }}}\n   *\n   *  @param  it the iterable collection\n   *  @return    an array consisting of elements of the iterable collection\n   */\n  def from[A : ClassTag](it: IterableOnce[A]): Array[A] \u003d it match {\n    case it: Iterable[A] \u003d\u003e it.toArray[A]\n    case _ \u003d\u003e it.iterator.toArray[A]\n  }\n\n  private def slowcopy(src : AnyRef,\n                       srcPos : Int,\n                       dest : AnyRef,\n                       destPos : Int,\n                       length : Int): Unit \u003d {\n    var i \u003d srcPos\n    var j \u003d destPos\n    val srcUntil \u003d srcPos + length\n    while (i \u003c srcUntil) {\n      array_update(dest, j, array_apply(src, i))\n      i +\u003d 1\n      j +\u003d 1\n    }\n  }\n\n  /** Copy one array to another.\n   *  Equivalent to Java\u0027s\n   *    `System.arraycopy(src, srcPos, dest, destPos, length)`,\n   *  except that this also works for polymorphic and boxed arrays.\n   *\n   *  Note that the passed-in `dest` array will be modified by this call.\n   *\n   *  @param src the source array.\n   *  @param srcPos  starting position in the source array.\n   *  @param dest destination array.\n   *  @param destPos starting position in the destination array.\n   *  @param length the number of array elements to be copied.\n   *\n   *  @see `java.lang.System#arraycopy`\n   */\n  def copy(src: AnyRef, srcPos: Int, dest: AnyRef, destPos: Int, length: Int): Unit \u003d {\n    val srcClass \u003d src.getClass\n    if (srcClass.isArray \u0026\u0026 dest.getClass.isAssignableFrom(srcClass))\n      java.lang.System.arraycopy(src, srcPos, dest, destPos, length)\n    else\n      slowcopy(src, srcPos, dest, destPos, length)\n  }\n\n  /** Copy one array to another, truncating or padding with default values (if\n    * necessary) so the copy has the specified length.\n    *\n    * Equivalent to Java\u0027s\n    *   `java.util.Arrays.copyOf(original, newLength)`,\n    * except that this works for primitive and object arrays in a single method.\n    *\n    * @see `java.util.Arrays#copyOf`\n    */\n  def copyOf[A](original: Array[A], newLength: Int): Array[A] \u003d ((original: @unchecked) match {\n    case x: Array[BoxedUnit]  \u003d\u003e newUnitArray(newLength).asInstanceOf[Array[A]]\n    case x: Array[AnyRef]     \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Int]        \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Double]     \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Long]       \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Float]      \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Char]       \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Byte]       \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Short]      \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Boolean]    \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n  }).asInstanceOf[Array[A]]\n\n  /** Copy one array to another, truncating or padding with default values (if\n    * necessary) so the copy has the specified length. The new array can have\n    * a different type than the original one as long as the values are\n    * assignment-compatible. When copying between primitive and object arrays,\n    * boxing and unboxing are supported.\n    *\n    * Equivalent to Java\u0027s\n    *   `java.util.Arrays.copyOf(original, newLength, newType)`,\n    * except that this works for all combinations of primitive and object arrays\n    * in a single method.\n    *\n    * @see `java.util.Arrays#copyOf`\n    */\n  def copyAs[A](original: Array[_], newLength: Int)(implicit ct: ClassTag[A]): Array[A] \u003d {\n    val runtimeClass \u003d ct.runtimeClass\n    if (runtimeClass \u003d\u003d Void.TYPE) newUnitArray(newLength).asInstanceOf[Array[A]]\n    else {\n      val destClass \u003d runtimeClass.asInstanceOf[Class[A]]\n      if (destClass.isAssignableFrom(original.getClass.getComponentType)) {\n        if (destClass.isPrimitive) copyOf[A](original.asInstanceOf[Array[A]], newLength)\n        else {\n          val destArrayClass \u003d java.lang.reflect.Array.newInstance(destClass, 0).getClass.asInstanceOf[Class[Array[AnyRef]]]\n          java.util.Arrays.copyOf(original.asInstanceOf[Array[AnyRef]], newLength, destArrayClass).asInstanceOf[Array[A]]\n        }\n      } else {\n        val dest \u003d new Array[A](newLength)\n        Array.copy(original, 0, dest, 0, original.length)\n        dest\n      }\n    }\n  }\n\n  private def newUnitArray(len: Int): Array[Unit] \u003d {\n    val result \u003d new Array[Unit](len)\n    java.util.Arrays.fill(result.asInstanceOf[Array[AnyRef]], ())\n    result\n  }\n\n  /** Returns an array of length 0 */\n  def empty[T: ClassTag]: Array[T] \u003d new Array[T](0)\n\n  /** Creates an array with given elements.\n   *\n   *  @param xs the elements to put in the array\n   *  @return an array containing all elements from xs.\n   */\n  // Subject to a compiler optimization in Cleanup.\n  // Array(e0, ..., en) is translated to { val a \u003d new Array(3); a(i) \u003d ei; a }\n  def apply[T: ClassTag](xs: T*): Array[T] \u003d {\n    val len \u003d xs.length\n    xs match {\n      case wa: immutable.ArraySeq[_] if wa.unsafeArray.getClass.getComponentType \u003d\u003d classTag[T].runtimeClass \u003d\u003e\n        // We get here in test/files/run/sd760a.scala, `Array[T](t)` for\n        // a specialized type parameter `T`. While we still pay for two\n        // copies of the array it is better than before when we also boxed\n        // each element when populating the result.\n        ScalaRunTime.array_clone(wa.unsafeArray).asInstanceOf[Array[T]]\n      case _ \u003d\u003e\n        val array \u003d new Array[T](len)\n        val iterator \u003d xs.iterator\n        var i \u003d 0\n        while (iterator.hasNext) {\n          array(i) \u003d iterator.next(); i +\u003d 1\n        }\n        array\n    }\n  }\n\n  /** Creates an array of `Boolean` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Boolean, xs: Boolean*): Array[Boolean] \u003d {\n    val array \u003d new Array[Boolean](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Byte` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Byte, xs: Byte*): Array[Byte] \u003d {\n    val array \u003d new Array[Byte](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Short` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Short, xs: Short*): Array[Short] \u003d {\n    val array \u003d new Array[Short](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Char` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Char, xs: Char*): Array[Char] \u003d {\n    val array \u003d new Array[Char](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Int` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Int, xs: Int*): Array[Int] \u003d {\n    val array \u003d new Array[Int](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Long` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Long, xs: Long*): Array[Long] \u003d {\n    val array \u003d new Array[Long](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Float` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Float, xs: Float*): Array[Float] \u003d {\n    val array \u003d new Array[Float](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Double` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Double, xs: Double*): Array[Double] \u003d {\n    val array \u003d new Array[Double](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Unit` objects */\n  def apply(x: Unit, xs: Unit*): Array[Unit] \u003d {\n    val array \u003d new Array[Unit](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates array with given dimensions */\n  def ofDim[T: ClassTag](n1: Int): Array[T] \u003d\n    new Array[T](n1)\n  /** Creates a 2-dimensional array */\n  def ofDim[T: ClassTag](n1: Int, n2: Int): Array[Array[T]] \u003d {\n    val arr: Array[Array[T]] \u003d (new Array[Array[T]](n1): Array[Array[T]])\n    for (i \u003c- 0 until n1) arr(i) \u003d new Array[T](n2)\n    arr\n    // tabulate(n1)(_ \u003d\u003e ofDim[T](n2))\n  }\n  /** Creates a 3-dimensional array */\n  def ofDim[T: ClassTag](n1: Int, n2: Int, n3: Int): Array[Array[Array[T]]] \u003d\n    tabulate(n1)(_ \u003d\u003e ofDim[T](n2, n3))\n  /** Creates a 4-dimensional array */\n  def ofDim[T: ClassTag](n1: Int, n2: Int, n3: Int, n4: Int): Array[Array[Array[Array[T]]]] \u003d\n    tabulate(n1)(_ \u003d\u003e ofDim[T](n2, n3, n4))\n  /** Creates a 5-dimensional array */\n  def ofDim[T: ClassTag](n1: Int, n2: Int, n3: Int, n4: Int, n5: Int): Array[Array[Array[Array[Array[T]]]]] \u003d\n    tabulate(n1)(_ \u003d\u003e ofDim[T](n2, n3, n4, n5))\n\n  /** Concatenates all arrays into a single array.\n   *\n   *  @param xss the given arrays\n   *  @return   the array created from concatenating `xss`\n   */\n  def concat[T: ClassTag](xss: Array[T]*): Array[T] \u003d {\n    val b \u003d newBuilder[T]\n    b.sizeHint(xss.map(_.length).sum)\n    for (xs \u003c- xss) b ++\u003d xs\n    b.result()\n  }\n\n  /** Returns an array that contains the results of some element computation a number\n   *  of times.\n   *\n   *  Note that this means that `elem` is computed a total of n times:\n   *  {{{\n   * scala\u003e Array.fill(3){ math.random }\n   * res3: Array[Double] \u003d Array(0.365461167592537, 1.550395944913685E-4, 0.7907242137333306)\n   *  }}}\n   *\n   *  @param   n  the number of elements desired\n   *  @param   elem the element computation\n   *  @return an Array of size n, where each element contains the result of computing\n   *  `elem`.\n   */\n  def fill[T: ClassTag](n: Int)(elem: \u003d\u003e T): Array[T] \u003d {\n    if (n \u003c\u003d 0) {\n      empty[T]\n    } else {\n      val array \u003d new Array[T](n)\n      var i \u003d 0\n      while (i \u003c n) {\n        array(i) \u003d elem\n        i +\u003d 1\n      }\n      array\n    }\n  }\n\n  /** Returns a two-dimensional array that contains the results of some element\n   *  computation a number of times.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   elem the element computation\n   */\n  def fill[T: ClassTag](n1: Int, n2: Int)(elem: \u003d\u003e T): Array[Array[T]] \u003d\n    tabulate(n1)(_ \u003d\u003e fill(n2)(elem))\n\n  /** Returns a three-dimensional array that contains the results of some element\n   *  computation a number of times.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   n3  the number of elements in the 3rd dimension\n   *  @param   elem the element computation\n   */\n  def fill[T: ClassTag](n1: Int, n2: Int, n3: Int)(elem: \u003d\u003e T): Array[Array[Array[T]]] \u003d\n    tabulate(n1)(_ \u003d\u003e fill(n2, n3)(elem))\n\n  /** Returns a four-dimensional array that contains the results of some element\n   *  computation a number of times.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   n3  the number of elements in the 3rd dimension\n   *  @param   n4  the number of elements in the 4th dimension\n   *  @param   elem the element computation\n   */\n  def fill[T: ClassTag](n1: Int, n2: Int, n3: Int, n4: Int)(elem: \u003d\u003e T): Array[Array[Array[Array[T]]]] \u003d\n    tabulate(n1)(_ \u003d\u003e fill(n2, n3, n4)(elem))\n\n  /** Returns a five-dimensional array that contains the results of some element\n   *  computation a number of times.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   n3  the number of elements in the 3rd dimension\n   *  @param   n4  the number of elements in the 4th dimension\n   *  @param   n5  the number of elements in the 5th dimension\n   *  @param   elem the element computation\n   */\n  def fill[T: ClassTag](n1: Int, n2: Int, n3: Int, n4: Int, n5: Int)(elem: \u003d\u003e T): Array[Array[Array[Array[Array[T]]]]] \u003d\n    tabulate(n1)(_ \u003d\u003e fill(n2, n3, n4, n5)(elem))\n\n  /** Returns an array containing values of a given function over a range of integer\n   *  values starting from 0.\n   *\n   *  @param  n   The number of elements in the array\n   *  @param  f   The function computing element values\n   *  @return An `Array` consisting of elements `f(0),f(1), ..., f(n - 1)`\n   */\n  def tabulate[T: ClassTag](n: Int)(f: Int \u003d\u003e T): Array[T] \u003d {\n    if (n \u003c\u003d 0) {\n      empty[T]\n    } else {\n      val array \u003d new Array[T](n)\n      var i \u003d 0\n      while (i \u003c n) {\n        array(i) \u003d f(i)\n        i +\u003d 1\n      }\n      array\n    }\n  }\n\n  /** Returns a two-dimensional array containing values of a given function\n   *  over ranges of integer values starting from `0`.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   f   The function computing element values\n   */\n  def tabulate[T: ClassTag](n1: Int, n2: Int)(f: (Int, Int) \u003d\u003e T): Array[Array[T]] \u003d\n    tabulate(n1)(i1 \u003d\u003e tabulate(n2)(f(i1, _)))\n\n  /** Returns a three-dimensional array containing values of a given function\n   *  over ranges of integer values starting from `0`.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   n3  the number of elements in the 3rd dimension\n   *  @param   f   The function computing element values\n   */\n  def tabulate[T: ClassTag](n1: Int, n2: Int, n3: Int)(f: (Int, Int, Int) \u003d\u003e T): Array[Array[Array[T]]] \u003d\n    tabulate(n1)(i1 \u003d\u003e tabulate(n2, n3)(f(i1, _, _)))\n\n  /** Returns a four-dimensional array containing values of a given function\n   *  over ranges of integer values starting from `0`.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   n3  the number of elements in the 3rd dimension\n   *  @param   n4  the number of elements in the 4th dimension\n   *  @param   f   The function computing element values\n   */\n  def tabulate[T: ClassTag](n1: Int, n2: Int, n3: Int, n4: Int)(f: (Int, Int, Int, Int) \u003d\u003e T): Array[Array[Array[Array[T]]]] \u003d\n    tabulate(n1)(i1 \u003d\u003e tabulate(n2, n3, n4)(f(i1, _, _, _)))\n\n  /** Returns a five-dimensional array containing values of a given function\n   *  over ranges of integer values starting from `0`.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   n3  the number of elements in the 3rd dimension\n   *  @param   n4  the number of elements in the 4th dimension\n   *  @param   n5  the number of elements in the 5th dimension\n   *  @param   f   The function computing element values\n   */\n  def tabulate[T: ClassTag](n1: Int, n2: Int, n3: Int, n4: Int, n5: Int)(f: (Int, Int, Int, Int, Int) \u003d\u003e T): Array[Array[Array[Array[Array[T]]]]] \u003d\n    tabulate(n1)(i1 \u003d\u003e tabulate(n2, n3, n4, n5)(f(i1, _, _, _, _)))\n\n  /** Returns an array containing a sequence of increasing integers in a range.\n   *\n   *  @param start  the start value of the array\n   *  @param end    the end value of the array, exclusive (in other words, this is the first value \u0027\u0027\u0027not\u0027\u0027\u0027 returned)\n   *  @return  the array with values in range `start, start + 1, ..., end - 1`\n   *  up to, but excluding, `end`.\n   */\n  def range(start: Int, end: Int): Array[Int] \u003d range(start, end, 1)\n\n  /** Returns an array containing equally spaced values in some integer interval.\n   *\n   *  @param start the start value of the array\n   *  @param end   the end value of the array, exclusive (in other words, this is the first value \u0027\u0027\u0027not\u0027\u0027\u0027 returned)\n   *  @param step  the increment value of the array (may not be zero)\n   *  @return      the array with values in `start, start + step, ...` up to, but excluding `end`\n   */\n  def range(start: Int, end: Int, step: Int): Array[Int] \u003d {\n    if (step \u003d\u003d 0) throw new IllegalArgumentException(\"zero step\")\n    val array \u003d new Array[Int](immutable.Range.count(start, end, step, isInclusive \u003d false))\n\n    var n \u003d 0\n    var i \u003d start\n    while (if (step \u003c 0) end \u003c i else i \u003c end) {\n      array(n) \u003d i\n      i +\u003d step\n      n +\u003d 1\n    }\n    array\n  }\n\n  /** Returns an array containing repeated applications of a function to a start value.\n   *\n   *  @param start the start value of the array\n   *  @param len   the number of elements returned by the array\n   *  @param f     the function that is repeatedly applied\n   *  @return      the array returning `len` values in the sequence `start, f(start), f(f(start)), ...`\n   */\n  def iterate[T: ClassTag](start: T, len: Int)(f: T \u003d\u003e T): Array[T] \u003d {\n    if (len \u003e 0) {\n      val array \u003d new Array[T](len)\n      var acc \u003d start\n      var i \u003d 1\n      array(0) \u003d acc\n\n      while (i \u003c len) {\n        acc \u003d f(acc)\n        array(i) \u003d acc\n        i +\u003d 1\n      }\n      array\n    } else {\n      empty[T]\n    }\n  }\n\n  /** Compare two arrays per element.\n   *\n   *  A more efficient version of `xs.sameElements(ys)`.\n   *\n   *  Note that arrays are invariant in Scala, but it may\n   *  be sound to cast an array of arbitrary reference type\n   *  to `Array[AnyRef]`. Arrays on the JVM are covariant\n   *  in their element type.\n   *\n   *  `Array.equals(xs.asInstanceOf[Array[AnyRef]], ys.asInstanceOf[Array[AnyRef]])`\n   *\n   *  @param xs an array of AnyRef\n   *  @param ys an array of AnyRef\n   *  @return true if corresponding elements are equal\n   */\n  def equals(xs: Array[AnyRef], ys: Array[AnyRef]): Boolean \u003d\n    (xs eq ys) ||\n    (xs.length \u003d\u003d ys.length) \u0026\u0026 {\n      var i \u003d 0\n      while (i \u003c xs.length \u0026\u0026 xs(i) \u003d\u003d ys(i)) i +\u003d 1\n      i \u003e\u003d xs.length\n    }\n\n  /** Called in a pattern match like `{ case Array(x,y,z) \u003d\u003e println(\u00273 elements\u0027)}`.\n   *\n   *  @param x the selector value\n   *  @return  sequence wrapped in a [[scala.Some]], if `x` is an Array, otherwise `None`\n   */\n  def unapplySeq[T](x: Array[T]): UnapplySeqWrapper[T] \u003d new UnapplySeqWrapper(x)\n\n  final class UnapplySeqWrapper[T](private val a: Array[T]) extends AnyVal {\n    def isEmpty: false \u003d false\n    def get: UnapplySeqWrapper[T] \u003d this\n    def lengthCompare(len: Int): Int \u003d a.lengthCompare(len)\n    def apply(i: Int): T \u003d a(i)\n    def drop(n: Int): scala.Seq[T] \u003d ArraySeq.unsafeWrapArray(a.drop(n)) // clones the array, also if n \u003d\u003d 0\n    def toSeq: scala.Seq[T] \u003d a.toSeq // clones the array\n  }\n}\n\n/** Arrays are mutable, indexed collections of values. `Array[T]` is Scala\u0027s representation\n *  for Java\u0027s `T[]`.\n *\n *  {{{\n *  val numbers \u003d Array(1, 2, 3, 4)\n *  val first \u003d numbers(0) // read the first element\n *  numbers(3) \u003d 100 // replace the 4th array element with 100\n *  val biggerNumbers \u003d numbers.map(_ * 2) // multiply all numbers by two\n *  }}}\n *\n *  Arrays make use of two common pieces of Scala syntactic sugar, shown on lines 2 and 3 of the above\n *  example code.\n *  Line 2 is translated into a call to `apply(Int)`, while line 3 is translated into a call to\n *  `update(Int, T)`.\n *\n *  Two implicit conversions exist in [[scala.Predef]] that are frequently applied to arrays: a conversion\n *  to [[scala.collection.ArrayOps]] (shown on line 4 of the example above) and a conversion\n *  to [[scala.collection.mutable.ArraySeq]] (a subtype of [[scala.collection.Seq]]).\n *  Both types make available many of the standard operations found in the Scala collections API.\n *  The conversion to `ArrayOps` is temporary, as all operations defined on `ArrayOps` return an `Array`,\n *  while the conversion to `ArraySeq` is permanent as all operations return a `ArraySeq`.\n *\n *  The conversion to `ArrayOps` takes priority over the conversion to `ArraySeq`. For instance,\n *  consider the following code:\n *\n *  {{{\n *  val arr \u003d Array(1, 2, 3)\n *  val arrReversed \u003d arr.reverse\n *  val seqReversed : collection.Seq[Int] \u003d arr.reverse\n *  }}}\n *\n *  Value `arrReversed` will be of type `Array[Int]`, with an implicit conversion to `ArrayOps` occurring\n *  to perform the `reverse` operation. The value of `seqReversed`, on the other hand, will be computed\n *  by converting to `ArraySeq` first and invoking the variant of `reverse` that returns another\n *  `ArraySeq`.\n *\n *  @see [[https://www.scala-lang.org/files/archive/spec/2.13/ Scala Language Specification]], for in-depth information on the transformations the Scala compiler makes on Arrays (Sections 6.6 and 6.15 respectively.)\n *  @see [[https://docs.scala-lang.org/sips/scala-2-8-arrays.html \"Scala 2.8 Arrays\"]] the Scala Improvement Document detailing arrays since Scala 2.8.\n *  @see [[https://docs.scala-lang.org/overviews/collections-2.13/arrays.html \"The Scala 2.8 Collections\u0027 API\"]] section on `Array` by Martin Odersky for more information.\n *  @hideImplicitConversion scala.Predef.booleanArrayOps\n *  @hideImplicitConversion scala.Predef.byteArrayOps\n *  @hideImplicitConversion scala.Predef.charArrayOps\n *  @hideImplicitConversion scala.Predef.doubleArrayOps\n *  @hideImplicitConversion scala.Predef.floatArrayOps\n *  @hideImplicitConversion scala.Predef.intArrayOps\n *  @hideImplicitConversion scala.Predef.longArrayOps\n *  @hideImplicitConversion scala.Predef.refArrayOps\n *  @hideImplicitConversion scala.Predef.shortArrayOps\n *  @hideImplicitConversion scala.Predef.unitArrayOps\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapRefArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapIntArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapDoubleArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapLongArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapFloatArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapCharArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapByteArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapShortArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapBooleanArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapUnitArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.genericWrapArray\n *  @define coll array\n *  @define Coll `Array`\n *  @define orderDependent\n *  @define orderDependentFold\n *  @define mayNotTerminateInf\n *  @define willNotTerminateInf\n *  @define collectExample\n *  @define undefinedorder\n */\nfinal class Array[T](_length: Int) extends java.io.Serializable with java.lang.Cloneable {\n\n  /** The length of the array */\n  def length: Int \u003d throw new Error()\n\n  /** The element at given index.\n   *\n   *  Indices start at `0`; `xs.apply(0)` is the first element of array `xs`.\n   *  Note the indexing syntax `xs(i)` is a shorthand for `xs.apply(i)`.\n   *\n   *  @param    i   the index\n   *  @return       the element at the given index\n   *  @throws       ArrayIndexOutOfBoundsException if `i \u003c 0` or `length \u003c\u003d i`\n   */\n  def apply(i: Int): T \u003d throw new Error()\n\n  /** Update the element at given index.\n   *\n   *  Indices start at `0`; `xs.update(i, x)` replaces the i^th^ element in the array.\n   *  Note the syntax `xs(i) \u003d x` is a shorthand for `xs.update(i, x)`.\n   *\n   *  @param    i   the index\n   *  @param    x   the value to be written at index `i`\n   *  @throws       ArrayIndexOutOfBoundsException if `i \u003c 0` or `length \u003c\u003d i`\n   */\n  def update(i: Int, x: T): Unit \u003d { throw new Error() }\n\n  /** Clone the Array.\n   *\n   *  @return A clone of the Array.\n   */\n  override def clone(): Array[T] \u003d throw new Error()\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Array.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Array.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 25, 2024 11:58:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Array.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Array.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Array.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.25 23:58:46 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Array.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Array.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 25, 2024 11:58:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Array.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\n//import scala.collection.generic._\nimport scala.collection.{Factory, immutable, mutable}\nimport mutable.ArrayBuilder\nimport immutable.ArraySeq\nimport scala.language.implicitConversions\nimport scala.reflect.{ClassTag, classTag}\nimport scala.runtime.BoxedUnit\nimport scala.runtime.ScalaRunTime\nimport scala.runtime.ScalaRunTime.{array_apply, array_update}\n\n/** Utility methods for operating on arrays.\n *  For example:\n *  {{{\n *  val a \u003d Array(1, 2)\n *  val b \u003d Array.ofDim[Int](2)\n *  val c \u003d Array.concat(a, b)\n *  }}}\n *  where the array objects `a`, `b` and `c` have respectively the values\n *  `Array(1, 2)`, `Array(0, 0)` and `Array(1, 2, 0, 0)`.\n */\nobject Array {\n  val emptyBooleanArray \u003d new Array[Boolean](0)\n  val emptyByteArray    \u003d new Array[Byte](0)\n  val emptyCharArray    \u003d new Array[Char](0)\n  val emptyDoubleArray  \u003d new Array[Double](0)\n  val emptyFloatArray   \u003d new Array[Float](0)\n  val emptyIntArray     \u003d new Array[Int](0)\n  val emptyLongArray    \u003d new Array[Long](0)\n  val emptyShortArray   \u003d new Array[Short](0)\n  val emptyObjectArray  \u003d new Array[Object](0)\n\n  /** Provides an implicit conversion from the Array object to a collection Factory */\n  implicit def toFactory[A : ClassTag](dummy: Array.type): Factory[A, Array[A]] \u003d new ArrayFactory(dummy)\n  @SerialVersionUID(3L)\n  private class ArrayFactory[A : ClassTag](dummy: Array.type) extends Factory[A, Array[A]] with Serializable {\n    def fromSpecific(it: IterableOnce[A]): Array[A] \u003d Array.from[A](it)\n    def newBuilder: mutable.Builder[A, Array[A]] \u003d Array.newBuilder[A]\n  }\n\n  /**\n   * Returns a new [[scala.collection.mutable.ArrayBuilder]].\n   */\n  def newBuilder[T](implicit t: ClassTag[T]): ArrayBuilder[T] \u003d ArrayBuilder.make[T](t)\n\n  /** Build an array from the iterable collection.\n   *\n   *  {{{\n   *  scala\u003e val a \u003d Array.from(Seq(1, 5))\n   *  val a: Array[Int] \u003d Array(1, 5)\n   *\n   *  scala\u003e val b \u003d Array.from(Range(1, 5))\n   *  val b: Array[Int] \u003d Array(1, 2, 3, 4)\n   *  }}}\n   *\n   *  @param  it the iterable collection\n   *  @return    an array consisting of elements of the iterable collection\n   */\n  def from[A : ClassTag](it: IterableOnce[A]): Array[A] \u003d it match {\n    case it: Iterable[A] \u003d\u003e it.toArray[A]\n    case _ \u003d\u003e it.iterator.toArray[A]\n  }\n\n  private def slowcopy(src : AnyRef,\n                       srcPos : Int,\n                       dest : AnyRef,\n                       destPos : Int,\n                       length : Int): Unit \u003d {\n    var i \u003d srcPos\n    var j \u003d destPos\n    val srcUntil \u003d srcPos + length\n    while (i \u003c srcUntil) {\n      array_update(dest, j, array_apply(src, i))\n      i +\u003d 1\n      j +\u003d 1\n    }\n  }\n\n  /** Copy one array to another.\n   *  Equivalent to Java\u0027s\n   *    `System.arraycopy(src, srcPos, dest, destPos, length)`,\n   *  except that this also works for polymorphic and boxed arrays.\n   *\n   *  Note that the passed-in `dest` array will be modified by this call.\n   *\n   *  @param src the source array.\n   *  @param srcPos  starting position in the source array.\n   *  @param dest destination array.\n   *  @param destPos starting position in the destination array.\n   *  @param length the number of array elements to be copied.\n   *\n   *  @see `java.lang.System#arraycopy`\n   */\n  def copy(src: AnyRef, srcPos: Int, dest: AnyRef, destPos: Int, length: Int): Unit \u003d {\n    val srcClass \u003d src.getClass\n    if (srcClass.isArray \u0026\u0026 dest.getClass.isAssignableFrom(srcClass))\n      java.lang.System.arraycopy(src, srcPos, dest, destPos, length)\n    else\n      slowcopy(src, srcPos, dest, destPos, length)\n  }\n\n  /** Copy one array to another, truncating or padding with default values (if\n    * necessary) so the copy has the specified length.\n    *\n    * Equivalent to Java\u0027s\n    *   `java.util.Arrays.copyOf(original, newLength)`,\n    * except that this works for primitive and object arrays in a single method.\n    *\n    * @see `java.util.Arrays#copyOf`\n    */\n  def copyOf[A](original: Array[A], newLength: Int): Array[A] \u003d ((original: @unchecked) match {\n    case x: Array[BoxedUnit]  \u003d\u003e newUnitArray(newLength).asInstanceOf[Array[A]]\n    case x: Array[AnyRef]     \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Int]        \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Double]     \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Long]       \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Float]      \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Char]       \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Byte]       \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Short]      \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n    case x: Array[Boolean]    \u003d\u003e java.util.Arrays.copyOf(x, newLength)\n  }).asInstanceOf[Array[A]]\n\n  /** Copy one array to another, truncating or padding with default values (if\n    * necessary) so the copy has the specified length. The new array can have\n    * a different type than the original one as long as the values are\n    * assignment-compatible. When copying between primitive and object arrays,\n    * boxing and unboxing are supported.\n    *\n    * Equivalent to Java\u0027s\n    *   `java.util.Arrays.copyOf(original, newLength, newType)`,\n    * except that this works for all combinations of primitive and object arrays\n    * in a single method.\n    *\n    * @see `java.util.Arrays#copyOf`\n    */\n  def copyAs[A](original: Array[_], newLength: Int)(implicit ct: ClassTag[A]): Array[A] \u003d {\n    val runtimeClass \u003d ct.runtimeClass\n    if (runtimeClass \u003d\u003d Void.TYPE) newUnitArray(newLength).asInstanceOf[Array[A]]\n    else {\n      val destClass \u003d runtimeClass.asInstanceOf[Class[A]]\n      if (destClass.isAssignableFrom(original.getClass.getComponentType)) {\n        if (destClass.isPrimitive) copyOf[A](original.asInstanceOf[Array[A]], newLength)\n        else {\n          val destArrayClass \u003d java.lang.reflect.Array.newInstance(destClass, 0).getClass.asInstanceOf[Class[Array[AnyRef]]]\n          java.util.Arrays.copyOf(original.asInstanceOf[Array[AnyRef]], newLength, destArrayClass).asInstanceOf[Array[A]]\n        }\n      } else {\n        val dest \u003d new Array[A](newLength)\n        Array.copy(original, 0, dest, 0, original.length)\n        dest\n      }\n    }\n  }\n\n  private def newUnitArray(len: Int): Array[Unit] \u003d {\n    val result \u003d new Array[Unit](len)\n    java.util.Arrays.fill(result.asInstanceOf[Array[AnyRef]], ())\n    result\n  }\n\n  /** Returns an array of length 0 */\n  def empty[T: ClassTag]: Array[T] \u003d new Array[T](0)\n\n  /** Creates an array with given elements.\n   *\n   *  @param xs the elements to put in the array\n   *  @return an array containing all elements from xs.\n   */\n  // Subject to a compiler optimization in Cleanup.\n  // Array(e0, ..., en) is translated to { val a \u003d new Array(3); a(i) \u003d ei; a }\n  def apply[T: ClassTag](xs: T*): Array[T] \u003d {\n    val len \u003d xs.length\n    xs match {\n      case wa: immutable.ArraySeq[_] if wa.unsafeArray.getClass.getComponentType \u003d\u003d classTag[T].runtimeClass \u003d\u003e\n        // We get here in test/files/run/sd760a.scala, `Array[T](t)` for\n        // a specialized type parameter `T`. While we still pay for two\n        // copies of the array it is better than before when we also boxed\n        // each element when populating the result.\n        ScalaRunTime.array_clone(wa.unsafeArray).asInstanceOf[Array[T]]\n      case _ \u003d\u003e\n        val array \u003d new Array[T](len)\n        val iterator \u003d xs.iterator\n        var i \u003d 0\n        while (iterator.hasNext) {\n          array(i) \u003d iterator.next(); i +\u003d 1\n        }\n        array\n    }\n  }\n\n  /** Creates an array of `Boolean` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Boolean, xs: Boolean*): Array[Boolean] \u003d {\n    val array \u003d new Array[Boolean](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Byte` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Byte, xs: Byte*): Array[Byte] \u003d {\n    val array \u003d new Array[Byte](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Short` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Short, xs: Short*): Array[Short] \u003d {\n    val array \u003d new Array[Short](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Char` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Char, xs: Char*): Array[Char] \u003d {\n    val array \u003d new Array[Char](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Int` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Int, xs: Int*): Array[Int] \u003d {\n    val array \u003d new Array[Int](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Long` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Long, xs: Long*): Array[Long] \u003d {\n    val array \u003d new Array[Long](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Float` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Float, xs: Float*): Array[Float] \u003d {\n    val array \u003d new Array[Float](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Double` objects */\n  // Subject to a compiler optimization in Cleanup, see above.\n  def apply(x: Double, xs: Double*): Array[Double] \u003d {\n    val array \u003d new Array[Double](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates an array of `Unit` objects */\n  def apply(x: Unit, xs: Unit*): Array[Unit] \u003d {\n    val array \u003d new Array[Unit](xs.length + 1)\n    array(0) \u003d x\n    val iterator \u003d xs.iterator\n    var i \u003d 1\n    while (iterator.hasNext) {\n      array(i) \u003d iterator.next(); i +\u003d 1\n    }\n    array\n  }\n\n  /** Creates array with given dimensions */\n  def ofDim[T: ClassTag](n1: Int): Array[T] \u003d\n    new Array[T](n1)\n  /** Creates a 2-dimensional array */\n  def ofDim[T: ClassTag](n1: Int, n2: Int): Array[Array[T]] \u003d {\n    val arr: Array[Array[T]] \u003d (new Array[Array[T]](n1): Array[Array[T]])\n    for (i \u003c- 0 until n1) arr(i) \u003d new Array[T](n2)\n    arr\n    // tabulate(n1)(_ \u003d\u003e ofDim[T](n2))\n  }\n  /** Creates a 3-dimensional array */\n  def ofDim[T: ClassTag](n1: Int, n2: Int, n3: Int): Array[Array[Array[T]]] \u003d\n    tabulate(n1)(_ \u003d\u003e ofDim[T](n2, n3))\n  /** Creates a 4-dimensional array */\n  def ofDim[T: ClassTag](n1: Int, n2: Int, n3: Int, n4: Int): Array[Array[Array[Array[T]]]] \u003d\n    tabulate(n1)(_ \u003d\u003e ofDim[T](n2, n3, n4))\n  /** Creates a 5-dimensional array */\n  def ofDim[T: ClassTag](n1: Int, n2: Int, n3: Int, n4: Int, n5: Int): Array[Array[Array[Array[Array[T]]]]] \u003d\n    tabulate(n1)(_ \u003d\u003e ofDim[T](n2, n3, n4, n5))\n\n  /** Concatenates all arrays into a single array.\n   *\n   *  @param xss the given arrays\n   *  @return   the array created from concatenating `xss`\n   */\n  def concat[T: ClassTag](xss: Array[T]*): Array[T] \u003d {\n    val b \u003d newBuilder[T]\n    b.sizeHint(xss.map(_.length).sum)\n    for (xs \u003c- xss) b ++\u003d xs\n    b.result()\n  }\n\n  /** Returns an array that contains the results of some element computation a number\n   *  of times.\n   *\n   *  Note that this means that `elem` is computed a total of n times:\n   *  {{{\n   * scala\u003e Array.fill(3){ math.random }\n   * res3: Array[Double] \u003d Array(0.365461167592537, 1.550395944913685E-4, 0.7907242137333306)\n   *  }}}\n   *\n   *  @param   n  the number of elements desired\n   *  @param   elem the element computation\n   *  @return an Array of size n, where each element contains the result of computing\n   *  `elem`.\n   */\n  def fill[T: ClassTag](n: Int)(elem: \u003d\u003e T): Array[T] \u003d {\n    if (n \u003c\u003d 0) {\n      empty[T]\n    } else {\n      val array \u003d new Array[T](n)\n      var i \u003d 0\n      while (i \u003c n) {\n        array(i) \u003d elem\n        i +\u003d 1\n      }\n      array\n    }\n  }\n\n  /** Returns a two-dimensional array that contains the results of some element\n   *  computation a number of times.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   elem the element computation\n   */\n  def fill[T: ClassTag](n1: Int, n2: Int)(elem: \u003d\u003e T): Array[Array[T]] \u003d\n    tabulate(n1)(_ \u003d\u003e fill(n2)(elem))\n\n  /** Returns a three-dimensional array that contains the results of some element\n   *  computation a number of times.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   n3  the number of elements in the 3rd dimension\n   *  @param   elem the element computation\n   */\n  def fill[T: ClassTag](n1: Int, n2: Int, n3: Int)(elem: \u003d\u003e T): Array[Array[Array[T]]] \u003d\n    tabulate(n1)(_ \u003d\u003e fill(n2, n3)(elem))\n\n  /** Returns a four-dimensional array that contains the results of some element\n   *  computation a number of times.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   n3  the number of elements in the 3rd dimension\n   *  @param   n4  the number of elements in the 4th dimension\n   *  @param   elem the element computation\n   */\n  def fill[T: ClassTag](n1: Int, n2: Int, n3: Int, n4: Int)(elem: \u003d\u003e T): Array[Array[Array[Array[T]]]] \u003d\n    tabulate(n1)(_ \u003d\u003e fill(n2, n3, n4)(elem))\n\n  /** Returns a five-dimensional array that contains the results of some element\n   *  computation a number of times.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   n3  the number of elements in the 3rd dimension\n   *  @param   n4  the number of elements in the 4th dimension\n   *  @param   n5  the number of elements in the 5th dimension\n   *  @param   elem the element computation\n   */\n  def fill[T: ClassTag](n1: Int, n2: Int, n3: Int, n4: Int, n5: Int)(elem: \u003d\u003e T): Array[Array[Array[Array[Array[T]]]]] \u003d\n    tabulate(n1)(_ \u003d\u003e fill(n2, n3, n4, n5)(elem))\n\n  /** Returns an array containing values of a given function over a range of integer\n   *  values starting from 0.\n   *\n   *  @param  n   The number of elements in the array\n   *  @param  f   The function computing element values\n   *  @return An `Array` consisting of elements `f(0),f(1), ..., f(n - 1)`\n   */\n  def tabulate[T: ClassTag](n: Int)(f: Int \u003d\u003e T): Array[T] \u003d {\n    if (n \u003c\u003d 0) {\n      empty[T]\n    } else {\n      val array \u003d new Array[T](n)\n      var i \u003d 0\n      while (i \u003c n) {\n        array(i) \u003d f(i)\n        i +\u003d 1\n      }\n      array\n    }\n  }\n\n  /** Returns a two-dimensional array containing values of a given function\n   *  over ranges of integer values starting from `0`.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   f   The function computing element values\n   */\n  def tabulate[T: ClassTag](n1: Int, n2: Int)(f: (Int, Int) \u003d\u003e T): Array[Array[T]] \u003d\n    tabulate(n1)(i1 \u003d\u003e tabulate(n2)(f(i1, _)))\n\n  /** Returns a three-dimensional array containing values of a given function\n   *  over ranges of integer values starting from `0`.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   n3  the number of elements in the 3rd dimension\n   *  @param   f   The function computing element values\n   */\n  def tabulate[T: ClassTag](n1: Int, n2: Int, n3: Int)(f: (Int, Int, Int) \u003d\u003e T): Array[Array[Array[T]]] \u003d\n    tabulate(n1)(i1 \u003d\u003e tabulate(n2, n3)(f(i1, _, _)))\n\n  /** Returns a four-dimensional array containing values of a given function\n   *  over ranges of integer values starting from `0`.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   n3  the number of elements in the 3rd dimension\n   *  @param   n4  the number of elements in the 4th dimension\n   *  @param   f   The function computing element values\n   */\n  def tabulate[T: ClassTag](n1: Int, n2: Int, n3: Int, n4: Int)(f: (Int, Int, Int, Int) \u003d\u003e T): Array[Array[Array[Array[T]]]] \u003d\n    tabulate(n1)(i1 \u003d\u003e tabulate(n2, n3, n4)(f(i1, _, _, _)))\n\n  /** Returns a five-dimensional array containing values of a given function\n   *  over ranges of integer values starting from `0`.\n   *\n   *  @param   n1  the number of elements in the 1st dimension\n   *  @param   n2  the number of elements in the 2nd dimension\n   *  @param   n3  the number of elements in the 3rd dimension\n   *  @param   n4  the number of elements in the 4th dimension\n   *  @param   n5  the number of elements in the 5th dimension\n   *  @param   f   The function computing element values\n   */\n  def tabulate[T: ClassTag](n1: Int, n2: Int, n3: Int, n4: Int, n5: Int)(f: (Int, Int, Int, Int, Int) \u003d\u003e T): Array[Array[Array[Array[Array[T]]]]] \u003d\n    tabulate(n1)(i1 \u003d\u003e tabulate(n2, n3, n4, n5)(f(i1, _, _, _, _)))\n\n  /** Returns an array containing a sequence of increasing integers in a range.\n   *\n   *  @param start  the start value of the array\n   *  @param end    the end value of the array, exclusive (in other words, this is the first value \u0027\u0027\u0027not\u0027\u0027\u0027 returned)\n   *  @return  the array with values in range `start, start + 1, ..., end - 1`\n   *  up to, but excluding, `end`.\n   */\n  def range(start: Int, end: Int): Array[Int] \u003d range(start, end, 1)\n\n  /** Returns an array containing equally spaced values in some integer interval.\n   *\n   *  @param start the start value of the array\n   *  @param end   the end value of the array, exclusive (in other words, this is the first value \u0027\u0027\u0027not\u0027\u0027\u0027 returned)\n   *  @param step  the increment value of the array (may not be zero)\n   *  @return      the array with values in `start, start + step, ...` up to, but excluding `end`\n   */\n  def range(start: Int, end: Int, step: Int): Array[Int] \u003d {\n    if (step \u003d\u003d 0) throw new IllegalArgumentException(\"zero step\")\n    val array \u003d new Array[Int](immutable.Range.count(start, end, step, isInclusive \u003d false))\n\n    var n \u003d 0\n    var i \u003d start\n    while (if (step \u003c 0) end \u003c i else i \u003c end) {\n      array(n) \u003d i\n      i +\u003d step\n      n +\u003d 1\n    }\n    array\n  }\n\n  /** Returns an array containing repeated applications of a function to a start value.\n   *\n   *  @param start the start value of the array\n   *  @param len   the number of elements returned by the array\n   *  @param f     the function that is repeatedly applied\n   *  @return      the array returning `len` values in the sequence `start, f(start), f(f(start)), ...`\n   */\n  def iterate[T: ClassTag](start: T, len: Int)(f: T \u003d\u003e T): Array[T] \u003d {\n    if (len \u003e 0) {\n      val array \u003d new Array[T](len)\n      var acc \u003d start\n      var i \u003d 1\n      array(0) \u003d acc\n\n      while (i \u003c len) {\n        acc \u003d f(acc)\n        array(i) \u003d acc\n        i +\u003d 1\n      }\n      array\n    } else {\n      empty[T]\n    }\n  }\n\n  /** Compare two arrays per element.\n   *\n   *  A more efficient version of `xs.sameElements(ys)`.\n   *\n   *  Note that arrays are invariant in Scala, but it may\n   *  be sound to cast an array of arbitrary reference type\n   *  to `Array[AnyRef]`. Arrays on the JVM are covariant\n   *  in their element type.\n   *\n   *  `Array.equals(xs.asInstanceOf[Array[AnyRef]], ys.asInstanceOf[Array[AnyRef]])`\n   *\n   *  @param xs an array of AnyRef\n   *  @param ys an array of AnyRef\n   *  @return true if corresponding elements are equal\n   */\n  def equals(xs: Array[AnyRef], ys: Array[AnyRef]): Boolean \u003d\n    (xs eq ys) ||\n    (xs.length \u003d\u003d ys.length) \u0026\u0026 {\n      var i \u003d 0\n      while (i \u003c xs.length \u0026\u0026 xs(i) \u003d\u003d ys(i)) i +\u003d 1\n      i \u003e\u003d xs.length\n    }\n\n  /** Called in a pattern match like `{ case Array(x,y,z) \u003d\u003e println(\u00273 elements\u0027)}`.\n   *\n   *  @param x the selector value\n   *  @return  sequence wrapped in a [[scala.Some]], if `x` is an Array, otherwise `None`\n   */\n  def unapplySeq[T](x: Array[T]): UnapplySeqWrapper[T] \u003d new UnapplySeqWrapper(x)\n\n  final class UnapplySeqWrapper[T](private val a: Array[T]) extends AnyVal {\n    def isEmpty: false \u003d false\n    def get: UnapplySeqWrapper[T] \u003d this\n    def lengthCompare(len: Int): Int \u003d a.lengthCompare(len)\n    def apply(i: Int): T \u003d a(i)\n    def drop(n: Int): scala.Seq[T] \u003d ArraySeq.unsafeWrapArray(a.drop(n)) // clones the array, also if n \u003d\u003d 0\n    def toSeq: scala.Seq[T] \u003d a.toSeq // clones the array\n  }\n}\n\n/** Arrays are mutable, indexed collections of values. `Array[T]` is Scala\u0027s representation\n *  for Java\u0027s `T[]`.\n *\n *  {{{\n *  val numbers \u003d Array(1, 2, 3, 4)\n *  val first \u003d numbers(0) // read the first element\n *  numbers(3) \u003d 100 // replace the 4th array element with 100\n *  val biggerNumbers \u003d numbers.map(_ * 2) // multiply all numbers by two\n *  }}}\n *\n *  Arrays make use of two common pieces of Scala syntactic sugar, shown on lines 2 and 3 of the above\n *  example code.\n *  Line 2 is translated into a call to `apply(Int)`, while line 3 is translated into a call to\n *  `update(Int, T)`.\n *\n *  Two implicit conversions exist in [[scala.Predef]] that are frequently applied to arrays: a conversion\n *  to [[scala.collection.ArrayOps]] (shown on line 4 of the example above) and a conversion\n *  to [[scala.collection.mutable.ArraySeq]] (a subtype of [[scala.collection.Seq]]).\n *  Both types make available many of the standard operations found in the Scala collections API.\n *  The conversion to `ArrayOps` is temporary, as all operations defined on `ArrayOps` return an `Array`,\n *  while the conversion to `ArraySeq` is permanent as all operations return a `ArraySeq`.\n *\n *  The conversion to `ArrayOps` takes priority over the conversion to `ArraySeq`. For instance,\n *  consider the following code:\n *\n *  {{{\n *  val arr \u003d Array(1, 2, 3)\n *  val arrReversed \u003d arr.reverse\n *  val seqReversed : collection.Seq[Int] \u003d arr.reverse\n *  }}}\n *\n *  Value `arrReversed` will be of type `Array[Int]`, with an implicit conversion to `ArrayOps` occurring\n *  to perform the `reverse` operation. The value of `seqReversed`, on the other hand, will be computed\n *  by converting to `ArraySeq` first and invoking the variant of `reverse` that returns another\n *  `ArraySeq`.\n *\n *  @see [[https://www.scala-lang.org/files/archive/spec/2.13/ Scala Language Specification]], for in-depth information on the transformations the Scala compiler makes on Arrays (Sections 6.6 and 6.15 respectively.)\n *  @see [[https://docs.scala-lang.org/sips/scala-2-8-arrays.html \"Scala 2.8 Arrays\"]] the Scala Improvement Document detailing arrays since Scala 2.8.\n *  @see [[https://docs.scala-lang.org/overviews/collections-2.13/arrays.html \"The Scala 2.8 Collections\u0027 API\"]] section on `Array` by Martin Odersky for more information.\n *  @hideImplicitConversion scala.Predef.booleanArrayOps\n *  @hideImplicitConversion scala.Predef.byteArrayOps\n *  @hideImplicitConversion scala.Predef.charArrayOps\n *  @hideImplicitConversion scala.Predef.doubleArrayOps\n *  @hideImplicitConversion scala.Predef.floatArrayOps\n *  @hideImplicitConversion scala.Predef.intArrayOps\n *  @hideImplicitConversion scala.Predef.longArrayOps\n *  @hideImplicitConversion scala.Predef.refArrayOps\n *  @hideImplicitConversion scala.Predef.shortArrayOps\n *  @hideImplicitConversion scala.Predef.unitArrayOps\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapRefArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapIntArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapDoubleArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapLongArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapFloatArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapCharArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapByteArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapShortArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapBooleanArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.wrapUnitArray\n *  @hideImplicitConversion scala.LowPriorityImplicits.genericWrapArray\n *  @define coll array\n *  @define Coll `Array`\n *  @define orderDependent\n *  @define orderDependentFold\n *  @define mayNotTerminateInf\n *  @define willNotTerminateInf\n *  @define collectExample\n *  @define undefinedorder\n */\nfinal class Array[T](_length: Int) extends java.io.Serializable with java.lang.Cloneable {\n\n  /** The length of the array */\n  def length: Int \u003d throw new Error()\n\n  /** The element at given index.\n   *\n   *  Indices start at `0`; `xs.apply(0)` is the first element of array `xs`.\n   *  Note the indexing syntax `xs(i)` is a shorthand for `xs.apply(i)`.\n   *\n   *  @param    i   the index\n   *  @return       the element at the given index\n   *  @throws       ArrayIndexOutOfBoundsException if `i \u003c 0` or `length \u003c\u003d i`\n   */\n  def apply(i: Int): T \u003d throw new Error()\n\n  /** Update the element at given index.\n   *\n   *  Indices start at `0`; `xs.update(i, x)` replaces the i^th^ element in the array.\n   *  Note the syntax `xs(i) \u003d x` is a shorthand for `xs.update(i, x)`.\n   *\n   *  @param    i   the index\n   *  @param    x   the value to be written at index `i`\n   *  @throws       ArrayIndexOutOfBoundsException if `i \u003c 0` or `length \u003c\u003d i`\n   */\n  def update(i: Int, x: T): Unit \u003d { throw new Error() }\n\n  /** Clone the Array.\n   *\n   *  @return A clone of the Array.\n   */\n  override def clone(): Array[T] \u003d throw new Error()\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Array.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Array.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.25 23:58:56 INFO  compiling root-test (3 scala sources)
2024.04.25 23:58:56 INFO  time: compiled root-test in 0.5s
2024.04.25 23:58:56 INFO  compiling root-test (3 scala sources)
2024.04.25 23:58:56 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 25, 2024 11:58:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Predef.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nimport scala.language.implicitConversions\n\nimport scala.collection.{mutable, immutable, ArrayOps, StringOps}, immutable.WrappedString\nimport scala.annotation.{elidable, implicitNotFound}, elidable.ASSERTION\nimport scala.annotation.meta.{ companionClass, companionMethod }\n\n/** The `Predef` object provides definitions that are accessible in all Scala\n *  compilation units without explicit qualification.\n *\n *  \u003d\u003d\u003d Commonly Used Types \u003d\u003d\u003d\n *  Predef provides type aliases for types which are commonly used, such as\n *  the immutable collection types [[scala.collection.immutable.Map]] and\n *  [[scala.collection.immutable.Set]].\n *\n *  \u003d\u003d\u003d Console Output \u003d\u003d\u003d\n *  For basic console output, `Predef` provides convenience methods [[print(x:Any* print]] and [[println(x:Any* println]],\n *  which are aliases of the methods in the object [[scala.Console]].\n *\n *  \u003d\u003d\u003d Assertions \u003d\u003d\u003d\n *  A set of `assert` functions are provided for use as a way to document\n *  and dynamically check invariants in code. Invocations of `assert` can be elided\n *  at compile time by providing the command line option `-Xdisable-assertions`,\n *  which raises `-Xelide-below` above `elidable.ASSERTION`, to the `scalac` command.\n *\n *  Variants of `assert` intended for use with static analysis tools are also\n *  provided: `assume`, `require` and `ensuring`. `require` and `ensuring` are\n *  intended for use as a means of design-by-contract style specification\n *  of pre- and post-conditions on functions, with the intention that these\n *  specifications could be consumed by a static analysis tool. For instance,\n *\n *  {{{\n *  def addNaturals(nats: List[Int]): Int \u003d {\n *    require(nats forall (_ \u003e\u003d 0), \"List contains negative numbers\")\n *    nats.foldLeft(0)(_ + _)\n *  } ensuring(_ \u003e\u003d 0)\n *  }}}\n *\n *  The declaration of `addNaturals` states that the list of integers passed should\n *  only contain natural numbers (i.e. non-negative), and that the result returned\n *  will also be natural. `require` is distinct from `assert` in that if the\n *  condition fails, then the caller of the function is to blame rather than a\n *  logical error having been made within `addNaturals` itself. `ensuring` is a\n *  form of `assert` that declares the guarantee the function is providing with\n *  regards to its return value.\n *\n *  \u003d\u003d\u003d Implicit Conversions \u003d\u003d\u003d\n *  A number of commonly applied implicit conversions are also defined here, and\n *  in the parent type [[scala.LowPriorityImplicits]]. Implicit conversions\n *  are provided for the \"widening\" of numeric values, for instance, converting a\n *  Short value to a Long value as required, and to add additional higher-order\n *  functions to Array values. These are described in more detail in the documentation of [[scala.Array]].\n *\n * @groupname utilities Utility Methods\n * @groupprio utilities 10\n *\n * @groupname assertions Assertions\n * @groupprio assertions 20\n * @groupdesc assertions These methods support program verification and runtime correctness.\n *\n * @groupname console-output Console Output\n * @groupprio console-output 30\n * @groupdesc console-output These methods provide output via the console.\n *\n * @groupname aliases Aliases\n * @groupprio aliases 50\n * @groupdesc aliases These aliases bring selected immutable types into scope without any imports.\n *\n * @groupname conversions-string String Conversions\n * @groupprio conversions-string 60\n * @groupdesc conversions-string Conversions from String to StringOps or WrappedString.\n *\n * @groupname implicit-classes-any Implicit Classes\n * @groupprio implicit-classes-any 70\n * @groupdesc implicit-classes-any These implicit classes add useful extension methods to every type.\n *\n * @groupname char-sequence-wrappers CharSequence Wrappers\n * @groupprio char-sequence-wrappers 80\n * @groupdesc char-sequence-wrappers Wrappers that implements CharSequence and were implicit classes.\n *\n * @groupname conversions-java-to-anyval Java to Scala\n * @groupprio conversions-java-to-anyval 90\n * @groupdesc conversions-java-to-anyval Implicit conversion from Java primitive wrapper types to Scala equivalents.\n *\n * @groupname conversions-anyval-to-java Scala to Java\n * @groupprio conversions-anyval-to-java 100\n * @groupdesc conversions-anyval-to-java Implicit conversion from Scala AnyVals to Java primitive wrapper types equivalents.\n *\n * @groupname conversions-array-to-wrapped-array Array to ArraySeq\n * @groupprio conversions-array-to-wrapped-array 110\n * @groupdesc conversions-array-to-wrapped-array Conversions from Arrays to ArraySeqs.\n */\nobject Predef extends LowPriorityImplicits {\n  /**\n   * Retrieve the runtime representation of a class type. `classOf[T]` is equivalent to\n   * the class literal `T.class` in Java.\n   *\n   * @example {{{\n   * val listClass \u003d classOf[List[_]]\n   * // listClass is java.lang.Class[List[_]] \u003d class scala.collection.immutable.List\n   *\n   * val mapIntString \u003d classOf[Map[Int,String]]\n   * // mapIntString is java.lang.Class[Map[Int,String]] \u003d interface scala.collection.immutable.Map\n   * }}}\n   *\n   * @return The runtime [[Class]] representation of type `T`.\n   * @group utilities\n   */\n  def classOf[T]: Class[T] \u003d null // This is a stub method. The actual implementation is filled in by the compiler.\n\n  /**\n   * Retrieve the single value of a type with a unique inhabitant.\n   *\n   * @example {{{\n   * object Foo\n   * val foo \u003d valueOf[Foo.type]\n   * // foo is Foo.type \u003d Foo\n   *\n   * val bar \u003d valueOf[23]\n   * // bar is 23.type \u003d 23\n   * }}}\n   * @group utilities\n   */\n  @inline def valueOf[T](implicit vt: ValueOf[T]): T \u003d vt.value\n\n  /** The `String` type in Scala has all the methods of the underlying\n   *  [[java.lang.String]], of which it is just an alias.\n   *\n   *  In addition, extension methods in [[scala.collection.StringOps]]\n   *  are added implicitly through the conversion [[augmentString]].\n   *  @group aliases\n   */\n  type String        \u003d java.lang.String\n  /**  @group aliases */\n  type Class[T]      \u003d java.lang.Class[T]\n\n  // miscellaneous -----------------------------------------------------\n  scala.`package`                         // to force scala package object to be seen.\n  scala.collection.immutable.List         // to force Nil, :: to be seen.\n\n  /**  @group aliases */\n  type Function[-A, +B] \u003d Function1[A, B]\n\n  /**  @group aliases */\n  type Map[K, +V] \u003d immutable.Map[K, V]\n  /**  @group aliases */\n  type Set[A]     \u003d immutable.Set[A]\n  /**  @group aliases */\n  val Map         \u003d immutable.Map\n  /**  @group aliases */\n  val Set         \u003d immutable.Set\n\n  /**\n   * Allows destructuring tuples with the same syntax as constructing them.\n   *\n   * @example {{{\n   * val tup \u003d \"foobar\" -\u003e 3\n   *\n   * val c \u003d tup match {\n   *   case str -\u003e i \u003d\u003e str.charAt(i)\n   * }\n   * }}}\n   * @group aliases\n   */\n  val -\u003e        \u003d Tuple2\n\n  // Manifest types, companions, and incantations for summoning\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  type OptManifest[T]   \u003d scala.reflect.OptManifest[T]\n  @implicitNotFound(msg \u003d \"No Manifest available for ${T}.\")\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  type Manifest[T]      \u003d scala.reflect.Manifest[T]\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  val Manifest          \u003d scala.reflect.Manifest\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  val NoManifest        \u003d scala.reflect.NoManifest\n\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use scala.reflect.classTag[T] and scala.reflect.runtime.universe.typeTag[T] instead\", \"2.10.0\")\n  def manifest[T](implicit m: Manifest[T]): Manifest[T]          \u003d m\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  def optManifest[T](implicit m: OptManifest[T]): OptManifest[T] \u003d m\n\n  // Minor variations on identity functions\n\n  /**\n   * A method that returns its input value.\n   * @tparam A type of the input value x.\n   * @param x the value of type `A` to be returned.\n   * @return the value `x`.\n   * @group utilities */\n  @inline def identity[A](x: A): A \u003d x // see `$conforms` for the implicit version\n\n  /** Summon an implicit value of type `T`. Usually, the argument is not passed explicitly.\n   *\n   *  @tparam T the type of the value to be summoned\n   *  @return the implicit value of type `T`\n   *  @group utilities\n   */\n  @inline def implicitly[T](implicit e: T): T \u003d e // TODO: when dependent method types are on by default, give this result type `e.type`, so that inliner has better chance of knowing which method to inline in calls like `implicitly[MatchingStrategy[Option]].zero`\n\n  /** Used to mark code blocks as being expressions, instead of being taken as part of anonymous classes and the like.\n   *  This is just a different name for [[identity]].\n   *\n   *  @example Separating code blocks from `new`:\n   *           {{{\n   *             val x \u003d new AnyRef\n   *             {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // the { ... } block is seen as the body of an anonymous class\n   *\n   *             val x \u003d new AnyRef\n   *\n   *             {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // an empty line is a brittle \"fix\"\n   *\n   *             val x \u003d new AnyRef\n   *             locally {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // locally guards the block and helps communicate intent\n   *           }}}\n   *  @group utilities\n   */\n  @inline def locally[T](@deprecatedName(\"x\") x: T): T \u003d x\n\n  // assertions ---------------------------------------------------------\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assert(assertion: Boolean): Unit \u003d {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @param message     a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assert(assertion: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assume(assumption: Boolean): Unit \u003d {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @param message      a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assume(assumption: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @group assertions\n   */\n  def require(requirement: Boolean): Unit \u003d {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed\")\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @param message       a String to include in the failure message\n   *  @group assertions\n   */\n  @inline final def require(requirement: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed: \"+ message)\n  }\n\n  /** `???` can be used for marking methods that remain to be implemented.\n   *  @throws NotImplementedError when `???` is invoked.\n   *  @group utilities\n   */\n  def ??? : Nothing \u003d throw new NotImplementedError\n\n  // implicit classes -----------------------------------------------------\n\n  /** @group implicit-classes-any */\n  implicit final class ArrowAssoc[A](private val self: A) extends AnyVal {\n    @inline def -\u003e [B](y: B): (A, B) \u003d (self, y)\n    @deprecated(\"Use `-\u003e` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.\", \"2.13.0\")\n    def →[B](y: B): (A, B) \u003d -\u003e(y)\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class Ensuring[A](private val self: A) extends AnyVal {\n    def ensuring(cond: Boolean): A \u003d { assert(cond); self }\n    def ensuring(cond: Boolean, msg: \u003d\u003e Any): A \u003d { assert(cond, msg); self }\n    def ensuring(cond: A \u003d\u003e Boolean): A \u003d { assert(cond(self)); self }\n    def ensuring(cond: A \u003d\u003e Boolean, msg: \u003d\u003e Any): A \u003d { assert(cond(self), msg); self }\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class StringFormat[A](private val self: A) extends AnyVal {\n    /** Returns string formatted according to given `format` string.\n     *  Format strings are as for `String.format`\n     *  (@see java.lang.String.format).\n     */\n    @deprecated(\"Use `formatString.format(value)` instead of `value.formatted(formatString)`,\\nor use the `f\\\"\\\"` string interpolator. In Java 15 and later, `formatted` resolves to the new method in String which has reversed parameters.\", \"2.12.16\")\n    @inline def formatted(fmtstr: String): String \u003d fmtstr format self\n  }\n\n  /** Injects String concatenation operator `+` to any classes. \n   * @group implicit-classes-any\n   */\n  @(deprecated @companionMethod)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\")\n  @(deprecated @companionClass)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\") // for Scaladoc\n  // scala/bug#8229 retaining the pre 2.11 name for source compatibility in shadowing this implicit\n  implicit final class any2stringadd[A](private val self: A) extends AnyVal {\n    def +(other: String): String \u003d String.valueOf(self) + other\n  }\n\n  /** @group char-sequence-wrappers */\n  final class SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]) extends CharSequence {\n    def length: Int                                     \u003d sequenceOfChars.length\n    def charAt(index: Int): Char                        \u003d sequenceOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence \u003d new SeqCharSequence(sequenceOfChars.slice(start, end))\n    override def toString                               \u003d sequenceOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]): SeqCharSequence \u003d new SeqCharSequence(sequenceOfChars)\n\n  /** @group char-sequence-wrappers */\n  final class ArrayCharSequence(arrayOfChars: Array[Char]) extends CharSequence {\n    def length: Int                                     \u003d arrayOfChars.length\n    def charAt(index: Int): Char                        \u003d arrayOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence \u003d new runtime.ArrayCharSequence(arrayOfChars, start, end)\n    override def toString                               \u003d arrayOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def ArrayCharSequence(arrayOfChars: Array[Char]): ArrayCharSequence \u003d new ArrayCharSequence(arrayOfChars)\n\n  /** @group conversions-string */\n  @inline implicit def augmentString(x: String): StringOps \u003d new StringOps(x)\n\n  // printing -----------------------------------------------------------\n\n  /** Prints an object to `out` using its `toString` method.\n   *\n   *  @param x the object to print; may be null.\n   *  @group console-output\n   */\n  def print(x: Any): Unit \u003d Console.print(x)\n\n  /** Prints a newline character on the default output.\n   *  @group console-output\n   */\n  def println(): Unit \u003d Console.println()\n\n  /** Prints out an object to the default output, followed by a newline character.\n   *\n   *  @param x the object to print.\n   *  @group console-output\n   */\n  def println(x: Any): Unit \u003d Console.println(x)\n\n  /** Prints its arguments as a formatted string to the default output,\n   *  based on a string pattern (in a fashion similar to printf in C).\n   *\n   *  The interpretation of the formatting patterns is described in\n   *  [[java.util.Formatter]].\n   *\n   *  Consider using the [[scala.StringContext.f f interpolator]] as more type safe and idiomatic.\n   *\n   *  @param text the pattern for formatting the arguments.\n   *  @param xs   the arguments used to instantiate the pattern.\n   *  @throws java.lang.IllegalArgumentException if there was a problem with the format string or arguments\n   *\n   *  @see [[scala.StringContext.f StringContext.f]]\n   *  @group console-output\n   */\n  def printf(text: String, xs: Any*): Unit \u003d Console.print(text.format(xs: _*))\n\n  // views --------------------------------------------------------------\n\n  // these two are morally deprecated but the @deprecated annotation has been moved to the extension method themselves,\n  // in order to provide a more specific deprecation method.\n  implicit def tuple2ToZippedOps[T1, T2](x: (T1, T2)): runtime.Tuple2Zipped.Ops[T1, T2]             \u003d new runtime.Tuple2Zipped.Ops(x)\n  implicit def tuple3ToZippedOps[T1, T2, T3](x: (T1, T2, T3)): runtime.Tuple3Zipped.Ops[T1, T2, T3] \u003d new runtime.Tuple3Zipped.Ops(x)\n\n  // Not specialized anymore since 2.13 but we still need separate methods\n  // to avoid https://github.com/scala/bug/issues/10746\n  // TODO: should not need @inline. add heuristic to inline factories for value classes.\n  @inline implicit def genericArrayOps[T](xs: Array[T]): ArrayOps[T]          \u003d new ArrayOps(xs)\n  @inline implicit def booleanArrayOps(xs: Array[Boolean]): ArrayOps[Boolean] \u003d new ArrayOps(xs)\n  @inline implicit def byteArrayOps(xs: Array[Byte]): ArrayOps[Byte]          \u003d new ArrayOps(xs)\n  @inline implicit def charArrayOps(xs: Array[Char]): ArrayOps[Char]          \u003d new ArrayOps(xs)\n  @inline implicit def doubleArrayOps(xs: Array[Double]): ArrayOps[Double]    \u003d new ArrayOps(xs)\n  @inline implicit def floatArrayOps(xs: Array[Float]): ArrayOps[Float]       \u003d new ArrayOps(xs)\n  @inline implicit def intArrayOps(xs: Array[Int]): ArrayOps[Int]             \u003d new ArrayOps(xs)\n  @inline implicit def longArrayOps(xs: Array[Long]): ArrayOps[Long]          \u003d new ArrayOps(xs)\n  @inline implicit def refArrayOps[T \u003c: AnyRef](xs: Array[T]): ArrayOps[T]    \u003d new ArrayOps(xs)\n  @inline implicit def shortArrayOps(xs: Array[Short]): ArrayOps[Short]       \u003d new ArrayOps(xs)\n  @inline implicit def unitArrayOps(xs: Array[Unit]): ArrayOps[Unit]          \u003d new ArrayOps(xs)\n\n  // \"Autoboxing\" and \"Autounboxing\" ---------------------------------------------------\n\n  /** @group conversions-anyval-to-java */\n  implicit def byte2Byte(x: Byte): java.lang.Byte             \u003d x.asInstanceOf[java.lang.Byte]\n  /** @group conversions-anyval-to-java */\n  implicit def short2Short(x: Short): java.lang.Short         \u003d x.asInstanceOf[java.lang.Short]\n  /** @group conversions-anyval-to-java */\n  implicit def char2Character(x: Char): java.lang.Character   \u003d x.asInstanceOf[java.lang.Character]\n  /** @group conversions-anyval-to-java */\n  implicit def int2Integer(x: Int): java.lang.Integer         \u003d x.asInstanceOf[java.lang.Integer]\n  /** @group conversions-anyval-to-java */\n  implicit def long2Long(x: Long): java.lang.Long             \u003d x.asInstanceOf[java.lang.Long]\n  /** @group conversions-anyval-to-java */\n  implicit def float2Float(x: Float): java.lang.Float         \u003d x.asInstanceOf[java.lang.Float]\n  /** @group conversions-anyval-to-java */\n  implicit def double2Double(x: Double): java.lang.Double     \u003d x.asInstanceOf[java.lang.Double]\n  /** @group conversions-anyval-to-java */\n  implicit def boolean2Boolean(x: Boolean): java.lang.Boolean \u003d x.asInstanceOf[java.lang.Boolean]\n\n  /** @group conversions-java-to-anyval */\n  implicit def Byte2byte(x: java.lang.Byte): Byte             \u003d x.asInstanceOf[Byte]\n  /** @group conversions-java-to-anyval */\n  implicit def Short2short(x: java.lang.Short): Short         \u003d x.asInstanceOf[Short]\n  /** @group conversions-java-to-anyval */\n  implicit def Character2char(x: java.lang.Character): Char   \u003d x.asInstanceOf[Char]\n  /** @group conversions-java-to-anyval */\n  implicit def Integer2int(x: java.lang.Integer): Int         \u003d x.asInstanceOf[Int]\n  /** @group conversions-java-to-anyval */\n  implicit def Long2long(x: java.lang.Long): Long             \u003d x.asInstanceOf[Long]\n  /** @group conversions-java-to-anyval */\n  implicit def Float2float(x: java.lang.Float): Float         \u003d x.asInstanceOf[Float]\n  /** @group conversions-java-to-anyval */\n  implicit def Double2double(x: java.lang.Double): Double     \u003d x.asInstanceOf[Double]\n  /** @group conversions-java-to-anyval */\n  implicit def Boolean2boolean(x: java.lang.Boolean): Boolean \u003d x.asInstanceOf[Boolean]\n\n  /** An implicit of type `A \u003d\u003e A` is available for all `A` because it can always\n   *  be implemented using the identity function. This also means that an\n   *  implicit of type `A \u003d\u003e B` is always available when `A \u003c: B`, because\n   *  `(A \u003d\u003e A) \u003c: (A \u003d\u003e B)`.\n   */\n  // $ to avoid accidental shadowing (e.g. scala/bug#7788)\n  implicit def $conforms[A]: A \u003d\u003e A \u003d \u003c:\u003c.refl\n}\n\n/** The `LowPriorityImplicits` class provides implicit values that\n*  are valid in all Scala compilation units without explicit qualification,\n*  but that are partially overridden by higher-priority conversions in object\n*  `Predef`.\n*/\n// scala/bug#7335 Parents of Predef are defined in the same compilation unit to avoid\n// cyclic reference errors compiling the standard library *without* a previously\n// compiled copy on the classpath.\nprivate[scala] abstract class LowPriorityImplicits extends LowPriorityImplicits2 {\n  import mutable.ArraySeq\n\n  /** We prefer the java.lang.* boxed types to these wrappers in\n   *  any potential conflicts.  Conflicts do exist because the wrappers\n   *  need to implement ScalaNumber in order to have a symmetric equals\n   *  method, but that implies implementing java.lang.Number as well.\n   *\n   *  Note - these are inlined because they are value classes, but\n   *  the call to xxxWrapper is not eliminated even though it does nothing.\n   *  Even inlined, every call site does a no-op retrieval of Predef\u0027s MODULE$\n   *  because maybe loading Predef has side effects!\n   */\n  @inline implicit def byteWrapper(x: Byte): runtime.RichByte          \u003d new runtime.RichByte(x)\n  @inline implicit def shortWrapper(x: Short): runtime.RichShort       \u003d new runtime.RichShort(x)\n  @inline implicit def intWrapper(x: Int): runtime.RichInt             \u003d new runtime.RichInt(x)\n  @inline implicit def charWrapper(c: Char): runtime.RichChar          \u003d new runtime.RichChar(c)\n  @inline implicit def longWrapper(x: Long): runtime.RichLong          \u003d new runtime.RichLong(x)\n  @inline implicit def floatWrapper(x: Float): runtime.RichFloat       \u003d new runtime.RichFloat(x)\n  @inline implicit def doubleWrapper(x: Double): runtime.RichDouble    \u003d new runtime.RichDouble(x)\n  @inline implicit def booleanWrapper(x: Boolean): runtime.RichBoolean \u003d new runtime.RichBoolean(x)\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def genericWrapArray[T](xs: Array[T]): ArraySeq[T] \u003d\n    if (xs eq null) null\n    else ArraySeq.make(xs)\n\n  // Since the JVM thinks arrays are covariant, one 0-length Array[AnyRef]\n  // is as good as another for all T \u003c: AnyRef.  Instead of creating 100,000,000\n  // unique ones by way of this implicit, let\u0027s share one.\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapRefArray[T \u003c: AnyRef](xs: Array[T]): ArraySeq.ofRef[T] \u003d {\n    if (xs eq null) null\n    else if (xs.length \u003d\u003d 0) ArraySeq.empty[AnyRef].asInstanceOf[ArraySeq.ofRef[T]]\n    else new ArraySeq.ofRef[T](xs)\n  }\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapIntArray(xs: Array[Int]): ArraySeq.ofInt \u003d if (xs ne null) new ArraySeq.ofInt(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapDoubleArray(xs: Array[Double]): ArraySeq.ofDouble \u003d if (xs ne null) new ArraySeq.ofDouble(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapLongArray(xs: Array[Long]): ArraySeq.ofLong \u003d if (xs ne null) new ArraySeq.ofLong(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapFloatArray(xs: Array[Float]): ArraySeq.ofFloat \u003d if (xs ne null) new ArraySeq.ofFloat(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapCharArray(xs: Array[Char]): ArraySeq.ofChar \u003d if (xs ne null) new ArraySeq.ofChar(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapByteArray(xs: Array[Byte]): ArraySeq.ofByte \u003d if (xs ne null) new ArraySeq.ofByte(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapShortArray(xs: Array[Short]): ArraySeq.ofShort \u003d if (xs ne null) new ArraySeq.ofShort(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapBooleanArray(xs: Array[Boolean]): ArraySeq.ofBoolean \u003d if (xs ne null) new ArraySeq.ofBoolean(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapUnitArray(xs: Array[Unit]): ArraySeq.ofUnit \u003d if (xs ne null) new ArraySeq.ofUnit(xs) else null\n\n  /** @group conversions-string */\n  implicit def wrapString(s: String): WrappedString \u003d if (s ne null) new WrappedString(s) else null\n}\n\nprivate[scala] abstract class LowPriorityImplicits2 {\n  @deprecated(\"implicit conversions from Array to immutable.IndexedSeq are implemented by copying; use `toIndexedSeq` explicitly if you want to copy, or use the more efficient non-copying ArraySeq.unsafeWrapArray\", since\u003d\"2.13.0\")\n  implicit def copyArrayToImmutableIndexedSeq[T](xs: Array[T]): IndexedSeq[T] \u003d\n    if (xs eq null) null\n    else new ArrayOps(xs).toIndexedSeq\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 25, 2024 11:58:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Predef.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.25 23:58:56 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

2024.04.25 23:58:56 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 25, 2024 11:58:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Predef.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nimport scala.language.implicitConversions\n\nimport scala.collection.{mutable, immutable, ArrayOps, StringOps}, immutable.WrappedString\nimport scala.annotation.{elidable, implicitNotFound}, elidable.ASSERTION\nimport scala.annotation.meta.{ companionClass, companionMethod }\n\n/** The `Predef` object provides definitions that are accessible in all Scala\n *  compilation units without explicit qualification.\n *\n *  \u003d\u003d\u003d Commonly Used Types \u003d\u003d\u003d\n *  Predef provides type aliases for types which are commonly used, such as\n *  the immutable collection types [[scala.collection.immutable.Map]] and\n *  [[scala.collection.immutable.Set]].\n *\n *  \u003d\u003d\u003d Console Output \u003d\u003d\u003d\n *  For basic console output, `Predef` provides convenience methods [[print(x:Any* print]] and [[println(x:Any* println]],\n *  which are aliases of the methods in the object [[scala.Console]].\n *\n *  \u003d\u003d\u003d Assertions \u003d\u003d\u003d\n *  A set of `assert` functions are provided for use as a way to document\n *  and dynamically check invariants in code. Invocations of `assert` can be elided\n *  at compile time by providing the command line option `-Xdisable-assertions`,\n *  which raises `-Xelide-below` above `elidable.ASSERTION`, to the `scalac` command.\n *\n *  Variants of `assert` intended for use with static analysis tools are also\n *  provided: `assume`, `require` and `ensuring`. `require` and `ensuring` are\n *  intended for use as a means of design-by-contract style specification\n *  of pre- and post-conditions on functions, with the intention that these\n *  specifications could be consumed by a static analysis tool. For instance,\n *\n *  {{{\n *  def addNaturals(nats: List[Int]): Int \u003d {\n *    require(nats forall (_ \u003e\u003d 0), \"List contains negative numbers\")\n *    nats.foldLeft(0)(_ + _)\n *  } ensuring(_ \u003e\u003d 0)\n *  }}}\n *\n *  The declaration of `addNaturals` states that the list of integers passed should\n *  only contain natural numbers (i.e. non-negative), and that the result returned\n *  will also be natural. `require` is distinct from `assert` in that if the\n *  condition fails, then the caller of the function is to blame rather than a\n *  logical error having been made within `addNaturals` itself. `ensuring` is a\n *  form of `assert` that declares the guarantee the function is providing with\n *  regards to its return value.\n *\n *  \u003d\u003d\u003d Implicit Conversions \u003d\u003d\u003d\n *  A number of commonly applied implicit conversions are also defined here, and\n *  in the parent type [[scala.LowPriorityImplicits]]. Implicit conversions\n *  are provided for the \"widening\" of numeric values, for instance, converting a\n *  Short value to a Long value as required, and to add additional higher-order\n *  functions to Array values. These are described in more detail in the documentation of [[scala.Array]].\n *\n * @groupname utilities Utility Methods\n * @groupprio utilities 10\n *\n * @groupname assertions Assertions\n * @groupprio assertions 20\n * @groupdesc assertions These methods support program verification and runtime correctness.\n *\n * @groupname console-output Console Output\n * @groupprio console-output 30\n * @groupdesc console-output These methods provide output via the console.\n *\n * @groupname aliases Aliases\n * @groupprio aliases 50\n * @groupdesc aliases These aliases bring selected immutable types into scope without any imports.\n *\n * @groupname conversions-string String Conversions\n * @groupprio conversions-string 60\n * @groupdesc conversions-string Conversions from String to StringOps or WrappedString.\n *\n * @groupname implicit-classes-any Implicit Classes\n * @groupprio implicit-classes-any 70\n * @groupdesc implicit-classes-any These implicit classes add useful extension methods to every type.\n *\n * @groupname char-sequence-wrappers CharSequence Wrappers\n * @groupprio char-sequence-wrappers 80\n * @groupdesc char-sequence-wrappers Wrappers that implements CharSequence and were implicit classes.\n *\n * @groupname conversions-java-to-anyval Java to Scala\n * @groupprio conversions-java-to-anyval 90\n * @groupdesc conversions-java-to-anyval Implicit conversion from Java primitive wrapper types to Scala equivalents.\n *\n * @groupname conversions-anyval-to-java Scala to Java\n * @groupprio conversions-anyval-to-java 100\n * @groupdesc conversions-anyval-to-java Implicit conversion from Scala AnyVals to Java primitive wrapper types equivalents.\n *\n * @groupname conversions-array-to-wrapped-array Array to ArraySeq\n * @groupprio conversions-array-to-wrapped-array 110\n * @groupdesc conversions-array-to-wrapped-array Conversions from Arrays to ArraySeqs.\n */\nobject Predef extends LowPriorityImplicits {\n  /**\n   * Retrieve the runtime representation of a class type. `classOf[T]` is equivalent to\n   * the class literal `T.class` in Java.\n   *\n   * @example {{{\n   * val listClass \u003d classOf[List[_]]\n   * // listClass is java.lang.Class[List[_]] \u003d class scala.collection.immutable.List\n   *\n   * val mapIntString \u003d classOf[Map[Int,String]]\n   * // mapIntString is java.lang.Class[Map[Int,String]] \u003d interface scala.collection.immutable.Map\n   * }}}\n   *\n   * @return The runtime [[Class]] representation of type `T`.\n   * @group utilities\n   */\n  def classOf[T]: Class[T] \u003d null // This is a stub method. The actual implementation is filled in by the compiler.\n\n  /**\n   * Retrieve the single value of a type with a unique inhabitant.\n   *\n   * @example {{{\n   * object Foo\n   * val foo \u003d valueOf[Foo.type]\n   * // foo is Foo.type \u003d Foo\n   *\n   * val bar \u003d valueOf[23]\n   * // bar is 23.type \u003d 23\n   * }}}\n   * @group utilities\n   */\n  @inline def valueOf[T](implicit vt: ValueOf[T]): T \u003d vt.value\n\n  /** The `String` type in Scala has all the methods of the underlying\n   *  [[java.lang.String]], of which it is just an alias.\n   *\n   *  In addition, extension methods in [[scala.collection.StringOps]]\n   *  are added implicitly through the conversion [[augmentString]].\n   *  @group aliases\n   */\n  type String        \u003d java.lang.String\n  /**  @group aliases */\n  type Class[T]      \u003d java.lang.Class[T]\n\n  // miscellaneous -----------------------------------------------------\n  scala.`package`                         // to force scala package object to be seen.\n  scala.collection.immutable.List         // to force Nil, :: to be seen.\n\n  /**  @group aliases */\n  type Function[-A, +B] \u003d Function1[A, B]\n\n  /**  @group aliases */\n  type Map[K, +V] \u003d immutable.Map[K, V]\n  /**  @group aliases */\n  type Set[A]     \u003d immutable.Set[A]\n  /**  @group aliases */\n  val Map         \u003d immutable.Map\n  /**  @group aliases */\n  val Set         \u003d immutable.Set\n\n  /**\n   * Allows destructuring tuples with the same syntax as constructing them.\n   *\n   * @example {{{\n   * val tup \u003d \"foobar\" -\u003e 3\n   *\n   * val c \u003d tup match {\n   *   case str -\u003e i \u003d\u003e str.charAt(i)\n   * }\n   * }}}\n   * @group aliases\n   */\n  val -\u003e        \u003d Tuple2\n\n  // Manifest types, companions, and incantations for summoning\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  type OptManifest[T]   \u003d scala.reflect.OptManifest[T]\n  @implicitNotFound(msg \u003d \"No Manifest available for ${T}.\")\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  type Manifest[T]      \u003d scala.reflect.Manifest[T]\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  val Manifest          \u003d scala.reflect.Manifest\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  val NoManifest        \u003d scala.reflect.NoManifest\n\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use scala.reflect.classTag[T] and scala.reflect.runtime.universe.typeTag[T] instead\", \"2.10.0\")\n  def manifest[T](implicit m: Manifest[T]): Manifest[T]          \u003d m\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  def optManifest[T](implicit m: OptManifest[T]): OptManifest[T] \u003d m\n\n  // Minor variations on identity functions\n\n  /**\n   * A method that returns its input value.\n   * @tparam A type of the input value x.\n   * @param x the value of type `A` to be returned.\n   * @return the value `x`.\n   * @group utilities */\n  @inline def identity[A](x: A): A \u003d x // see `$conforms` for the implicit version\n\n  /** Summon an implicit value of type `T`. Usually, the argument is not passed explicitly.\n   *\n   *  @tparam T the type of the value to be summoned\n   *  @return the implicit value of type `T`\n   *  @group utilities\n   */\n  @inline def implicitly[T](implicit e: T): T \u003d e // TODO: when dependent method types are on by default, give this result type `e.type`, so that inliner has better chance of knowing which method to inline in calls like `implicitly[MatchingStrategy[Option]].zero`\n\n  /** Used to mark code blocks as being expressions, instead of being taken as part of anonymous classes and the like.\n   *  This is just a different name for [[identity]].\n   *\n   *  @example Separating code blocks from `new`:\n   *           {{{\n   *             val x \u003d new AnyRef\n   *             {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // the { ... } block is seen as the body of an anonymous class\n   *\n   *             val x \u003d new AnyRef\n   *\n   *             {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // an empty line is a brittle \"fix\"\n   *\n   *             val x \u003d new AnyRef\n   *             locally {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // locally guards the block and helps communicate intent\n   *           }}}\n   *  @group utilities\n   */\n  @inline def locally[T](@deprecatedName(\"x\") x: T): T \u003d x\n\n  // assertions ---------------------------------------------------------\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assert(assertion: Boolean): Unit \u003d {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @param message     a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assert(assertion: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assume(assumption: Boolean): Unit \u003d {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @param message      a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assume(assumption: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @group assertions\n   */\n  def require(requirement: Boolean): Unit \u003d {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed\")\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @param message       a String to include in the failure message\n   *  @group assertions\n   */\n  @inline final def require(requirement: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed: \"+ message)\n  }\n\n  /** `???` can be used for marking methods that remain to be implemented.\n   *  @throws NotImplementedError when `???` is invoked.\n   *  @group utilities\n   */\n  def ??? : Nothing \u003d throw new NotImplementedError\n\n  // implicit classes -----------------------------------------------------\n\n  /** @group implicit-classes-any */\n  implicit final class ArrowAssoc[A](private val self: A) extends AnyVal {\n    @inline def -\u003e [B](y: B): (A, B) \u003d (self, y)\n    @deprecated(\"Use `-\u003e` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.\", \"2.13.0\")\n    def →[B](y: B): (A, B) \u003d -\u003e(y)\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class Ensuring[A](private val self: A) extends AnyVal {\n    def ensuring(cond: Boolean): A \u003d { assert(cond); self }\n    def ensuring(cond: Boolean, msg: \u003d\u003e Any): A \u003d { assert(cond, msg); self }\n    def ensuring(cond: A \u003d\u003e Boolean): A \u003d { assert(cond(self)); self }\n    def ensuring(cond: A \u003d\u003e Boolean, msg: \u003d\u003e Any): A \u003d { assert(cond(self), msg); self }\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class StringFormat[A](private val self: A) extends AnyVal {\n    /** Returns string formatted according to given `format` string.\n     *  Format strings are as for `String.format`\n     *  (@see java.lang.String.format).\n     */\n    @deprecated(\"Use `formatString.format(value)` instead of `value.formatted(formatString)`,\\nor use the `f\\\"\\\"` string interpolator. In Java 15 and later, `formatted` resolves to the new method in String which has reversed parameters.\", \"2.12.16\")\n    @inline def formatted(fmtstr: String): String \u003d fmtstr format self\n  }\n\n  /** Injects String concatenation operator `+` to any classes. \n   * @group implicit-classes-any\n   */\n  @(deprecated @companionMethod)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\")\n  @(deprecated @companionClass)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\") // for Scaladoc\n  // scala/bug#8229 retaining the pre 2.11 name for source compatibility in shadowing this implicit\n  implicit final class any2stringadd[A](private val self: A) extends AnyVal {\n    def +(other: String): String \u003d String.valueOf(self) + other\n  }\n\n  /** @group char-sequence-wrappers */\n  final class SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]) extends CharSequence {\n    def length: Int                                     \u003d sequenceOfChars.length\n    def charAt(index: Int): Char                        \u003d sequenceOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence \u003d new SeqCharSequence(sequenceOfChars.slice(start, end))\n    override def toString                               \u003d sequenceOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]): SeqCharSequence \u003d new SeqCharSequence(sequenceOfChars)\n\n  /** @group char-sequence-wrappers */\n  final class ArrayCharSequence(arrayOfChars: Array[Char]) extends CharSequence {\n    def length: Int                                     \u003d arrayOfChars.length\n    def charAt(index: Int): Char                        \u003d arrayOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence \u003d new runtime.ArrayCharSequence(arrayOfChars, start, end)\n    override def toString                               \u003d arrayOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def ArrayCharSequence(arrayOfChars: Array[Char]): ArrayCharSequence \u003d new ArrayCharSequence(arrayOfChars)\n\n  /** @group conversions-string */\n  @inline implicit def augmentString(x: String): StringOps \u003d new StringOps(x)\n\n  // printing -----------------------------------------------------------\n\n  /** Prints an object to `out` using its `toString` method.\n   *\n   *  @param x the object to print; may be null.\n   *  @group console-output\n   */\n  def print(x: Any): Unit \u003d Console.print(x)\n\n  /** Prints a newline character on the default output.\n   *  @group console-output\n   */\n  def println(): Unit \u003d Console.println()\n\n  /** Prints out an object to the default output, followed by a newline character.\n   *\n   *  @param x the object to print.\n   *  @group console-output\n   */\n  def println(x: Any): Unit \u003d Console.println(x)\n\n  /** Prints its arguments as a formatted string to the default output,\n   *  based on a string pattern (in a fashion similar to printf in C).\n   *\n   *  The interpretation of the formatting patterns is described in\n   *  [[java.util.Formatter]].\n   *\n   *  Consider using the [[scala.StringContext.f f interpolator]] as more type safe and idiomatic.\n   *\n   *  @param text the pattern for formatting the arguments.\n   *  @param xs   the arguments used to instantiate the pattern.\n   *  @throws java.lang.IllegalArgumentException if there was a problem with the format string or arguments\n   *\n   *  @see [[scala.StringContext.f StringContext.f]]\n   *  @group console-output\n   */\n  def printf(text: String, xs: Any*): Unit \u003d Console.print(text.format(xs: _*))\n\n  // views --------------------------------------------------------------\n\n  // these two are morally deprecated but the @deprecated annotation has been moved to the extension method themselves,\n  // in order to provide a more specific deprecation method.\n  implicit def tuple2ToZippedOps[T1, T2](x: (T1, T2)): runtime.Tuple2Zipped.Ops[T1, T2]             \u003d new runtime.Tuple2Zipped.Ops(x)\n  implicit def tuple3ToZippedOps[T1, T2, T3](x: (T1, T2, T3)): runtime.Tuple3Zipped.Ops[T1, T2, T3] \u003d new runtime.Tuple3Zipped.Ops(x)\n\n  // Not specialized anymore since 2.13 but we still need separate methods\n  // to avoid https://github.com/scala/bug/issues/10746\n  // TODO: should not need @inline. add heuristic to inline factories for value classes.\n  @inline implicit def genericArrayOps[T](xs: Array[T]): ArrayOps[T]          \u003d new ArrayOps(xs)\n  @inline implicit def booleanArrayOps(xs: Array[Boolean]): ArrayOps[Boolean] \u003d new ArrayOps(xs)\n  @inline implicit def byteArrayOps(xs: Array[Byte]): ArrayOps[Byte]          \u003d new ArrayOps(xs)\n  @inline implicit def charArrayOps(xs: Array[Char]): ArrayOps[Char]          \u003d new ArrayOps(xs)\n  @inline implicit def doubleArrayOps(xs: Array[Double]): ArrayOps[Double]    \u003d new ArrayOps(xs)\n  @inline implicit def floatArrayOps(xs: Array[Float]): ArrayOps[Float]       \u003d new ArrayOps(xs)\n  @inline implicit def intArrayOps(xs: Array[Int]): ArrayOps[Int]             \u003d new ArrayOps(xs)\n  @inline implicit def longArrayOps(xs: Array[Long]): ArrayOps[Long]          \u003d new ArrayOps(xs)\n  @inline implicit def refArrayOps[T \u003c: AnyRef](xs: Array[T]): ArrayOps[T]    \u003d new ArrayOps(xs)\n  @inline implicit def shortArrayOps(xs: Array[Short]): ArrayOps[Short]       \u003d new ArrayOps(xs)\n  @inline implicit def unitArrayOps(xs: Array[Unit]): ArrayOps[Unit]          \u003d new ArrayOps(xs)\n\n  // \"Autoboxing\" and \"Autounboxing\" ---------------------------------------------------\n\n  /** @group conversions-anyval-to-java */\n  implicit def byte2Byte(x: Byte): java.lang.Byte             \u003d x.asInstanceOf[java.lang.Byte]\n  /** @group conversions-anyval-to-java */\n  implicit def short2Short(x: Short): java.lang.Short         \u003d x.asInstanceOf[java.lang.Short]\n  /** @group conversions-anyval-to-java */\n  implicit def char2Character(x: Char): java.lang.Character   \u003d x.asInstanceOf[java.lang.Character]\n  /** @group conversions-anyval-to-java */\n  implicit def int2Integer(x: Int): java.lang.Integer         \u003d x.asInstanceOf[java.lang.Integer]\n  /** @group conversions-anyval-to-java */\n  implicit def long2Long(x: Long): java.lang.Long             \u003d x.asInstanceOf[java.lang.Long]\n  /** @group conversions-anyval-to-java */\n  implicit def float2Float(x: Float): java.lang.Float         \u003d x.asInstanceOf[java.lang.Float]\n  /** @group conversions-anyval-to-java */\n  implicit def double2Double(x: Double): java.lang.Double     \u003d x.asInstanceOf[java.lang.Double]\n  /** @group conversions-anyval-to-java */\n  implicit def boolean2Boolean(x: Boolean): java.lang.Boolean \u003d x.asInstanceOf[java.lang.Boolean]\n\n  /** @group conversions-java-to-anyval */\n  implicit def Byte2byte(x: java.lang.Byte): Byte             \u003d x.asInstanceOf[Byte]\n  /** @group conversions-java-to-anyval */\n  implicit def Short2short(x: java.lang.Short): Short         \u003d x.asInstanceOf[Short]\n  /** @group conversions-java-to-anyval */\n  implicit def Character2char(x: java.lang.Character): Char   \u003d x.asInstanceOf[Char]\n  /** @group conversions-java-to-anyval */\n  implicit def Integer2int(x: java.lang.Integer): Int         \u003d x.asInstanceOf[Int]\n  /** @group conversions-java-to-anyval */\n  implicit def Long2long(x: java.lang.Long): Long             \u003d x.asInstanceOf[Long]\n  /** @group conversions-java-to-anyval */\n  implicit def Float2float(x: java.lang.Float): Float         \u003d x.asInstanceOf[Float]\n  /** @group conversions-java-to-anyval */\n  implicit def Double2double(x: java.lang.Double): Double     \u003d x.asInstanceOf[Double]\n  /** @group conversions-java-to-anyval */\n  implicit def Boolean2boolean(x: java.lang.Boolean): Boolean \u003d x.asInstanceOf[Boolean]\n\n  /** An implicit of type `A \u003d\u003e A` is available for all `A` because it can always\n   *  be implemented using the identity function. This also means that an\n   *  implicit of type `A \u003d\u003e B` is always available when `A \u003c: B`, because\n   *  `(A \u003d\u003e A) \u003c: (A \u003d\u003e B)`.\n   */\n  // $ to avoid accidental shadowing (e.g. scala/bug#7788)\n  implicit def $conforms[A]: A \u003d\u003e A \u003d \u003c:\u003c.refl\n}\n\n/** The `LowPriorityImplicits` class provides implicit values that\n*  are valid in all Scala compilation units without explicit qualification,\n*  but that are partially overridden by higher-priority conversions in object\n*  `Predef`.\n*/\n// scala/bug#7335 Parents of Predef are defined in the same compilation unit to avoid\n// cyclic reference errors compiling the standard library *without* a previously\n// compiled copy on the classpath.\nprivate[scala] abstract class LowPriorityImplicits extends LowPriorityImplicits2 {\n  import mutable.ArraySeq\n\n  /** We prefer the java.lang.* boxed types to these wrappers in\n   *  any potential conflicts.  Conflicts do exist because the wrappers\n   *  need to implement ScalaNumber in order to have a symmetric equals\n   *  method, but that implies implementing java.lang.Number as well.\n   *\n   *  Note - these are inlined because they are value classes, but\n   *  the call to xxxWrapper is not eliminated even though it does nothing.\n   *  Even inlined, every call site does a no-op retrieval of Predef\u0027s MODULE$\n   *  because maybe loading Predef has side effects!\n   */\n  @inline implicit def byteWrapper(x: Byte): runtime.RichByte          \u003d new runtime.RichByte(x)\n  @inline implicit def shortWrapper(x: Short): runtime.RichShort       \u003d new runtime.RichShort(x)\n  @inline implicit def intWrapper(x: Int): runtime.RichInt             \u003d new runtime.RichInt(x)\n  @inline implicit def charWrapper(c: Char): runtime.RichChar          \u003d new runtime.RichChar(c)\n  @inline implicit def longWrapper(x: Long): runtime.RichLong          \u003d new runtime.RichLong(x)\n  @inline implicit def floatWrapper(x: Float): runtime.RichFloat       \u003d new runtime.RichFloat(x)\n  @inline implicit def doubleWrapper(x: Double): runtime.RichDouble    \u003d new runtime.RichDouble(x)\n  @inline implicit def booleanWrapper(x: Boolean): runtime.RichBoolean \u003d new runtime.RichBoolean(x)\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def genericWrapArray[T](xs: Array[T]): ArraySeq[T] \u003d\n    if (xs eq null) null\n    else ArraySeq.make(xs)\n\n  // Since the JVM thinks arrays are covariant, one 0-length Array[AnyRef]\n  // is as good as another for all T \u003c: AnyRef.  Instead of creating 100,000,000\n  // unique ones by way of this implicit, let\u0027s share one.\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapRefArray[T \u003c: AnyRef](xs: Array[T]): ArraySeq.ofRef[T] \u003d {\n    if (xs eq null) null\n    else if (xs.length \u003d\u003d 0) ArraySeq.empty[AnyRef].asInstanceOf[ArraySeq.ofRef[T]]\n    else new ArraySeq.ofRef[T](xs)\n  }\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapIntArray(xs: Array[Int]): ArraySeq.ofInt \u003d if (xs ne null) new ArraySeq.ofInt(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapDoubleArray(xs: Array[Double]): ArraySeq.ofDouble \u003d if (xs ne null) new ArraySeq.ofDouble(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapLongArray(xs: Array[Long]): ArraySeq.ofLong \u003d if (xs ne null) new ArraySeq.ofLong(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapFloatArray(xs: Array[Float]): ArraySeq.ofFloat \u003d if (xs ne null) new ArraySeq.ofFloat(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapCharArray(xs: Array[Char]): ArraySeq.ofChar \u003d if (xs ne null) new ArraySeq.ofChar(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapByteArray(xs: Array[Byte]): ArraySeq.ofByte \u003d if (xs ne null) new ArraySeq.ofByte(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapShortArray(xs: Array[Short]): ArraySeq.ofShort \u003d if (xs ne null) new ArraySeq.ofShort(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapBooleanArray(xs: Array[Boolean]): ArraySeq.ofBoolean \u003d if (xs ne null) new ArraySeq.ofBoolean(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapUnitArray(xs: Array[Unit]): ArraySeq.ofUnit \u003d if (xs ne null) new ArraySeq.ofUnit(xs) else null\n\n  /** @group conversions-string */\n  implicit def wrapString(s: String): WrappedString \u003d if (s ne null) new WrappedString(s) else null\n}\n\nprivate[scala] abstract class LowPriorityImplicits2 {\n  @deprecated(\"implicit conversions from Array to immutable.IndexedSeq are implemented by copying; use `toIndexedSeq` explicitly if you want to copy, or use the more efficient non-copying ArraySeq.unsafeWrapArray\", since\u003d\"2.13.0\")\n  implicit def copyArrayToImmutableIndexedSeq[T](xs: Array[T]): IndexedSeq[T] \u003d\n    if (xs eq null) null\n    else new ArrayOps(xs).toIndexedSeq\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 25, 2024 11:58:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Unit.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// DO NOT EDIT, CHANGES WILL BE LOST\n// This auto-generated code can be modified in \"project/GenerateAnyVals.scala\".\n// Afterwards, running \"sbt generateSources\" regenerates this source file.\n\npackage scala\n\n\n/** `Unit` is a subtype of [[scala.AnyVal]]. There is only one value of type\n *  `Unit`, `()`, and it is not represented by any object in the underlying\n *  runtime system. A method with return type `Unit` is analogous to a Java\n *  method which is declared `void`.\n */\nfinal abstract class Unit private extends AnyVal {\n  // Provide a more specific return type for Scaladoc\n  override def getClass(): Class[Unit] \u003d ???\n}\n\n@scala.annotation.compileTimeOnly(\"`Unit` companion object is not allowed in source; instead, use `()` for the unit value\")\nobject Unit extends AnyValCompanion {\n\n  /** Transform a value type into a boxed reference type.\n   *\n   *  This method is not intended for use in source code.\n   *  The runtime representation of this value is platform specific.\n   *\n   *  @param  x   the Unit to be boxed\n   *  @return     a scala.runtime.BoxedUnit offering `x` as its underlying value.\n   */\n  def box(x: Unit): scala.runtime.BoxedUnit \u003d scala.runtime.BoxedUnit.UNIT\n\n  /** Transform a boxed type into a value type.  Note that this\n   *  method is not typesafe: it accepts any Object, but will throw\n   *  an exception if the argument is not a scala.runtime.BoxedUnit.\n   *\n   *  This method is not intended for use in source code.\n   *  The result of successfully unboxing a value is `()`.\n   *\n   *  @param  x   the scala.runtime.BoxedUnit to be unboxed.\n   *  @throws     ClassCastException  if the argument is not a scala.runtime.BoxedUnit\n   *  @return     the Unit value ()\n   */\n  def unbox(x: java.lang.Object): Unit \u003d x.asInstanceOf[scala.runtime.BoxedUnit]\n\n  /** The String representation of the scala.Unit companion object. */\n  override def toString \u003d \"object scala.Unit\"\n}\n\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 25, 2024 11:58:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Unit.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.25 23:58:56 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 25, 2024 11:58:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Unit.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// DO NOT EDIT, CHANGES WILL BE LOST\n// This auto-generated code can be modified in \"project/GenerateAnyVals.scala\".\n// Afterwards, running \"sbt generateSources\" regenerates this source file.\n\npackage scala\n\n\n/** `Unit` is a subtype of [[scala.AnyVal]]. There is only one value of type\n *  `Unit`, `()`, and it is not represented by any object in the underlying\n *  runtime system. A method with return type `Unit` is analogous to a Java\n *  method which is declared `void`.\n */\nfinal abstract class Unit private extends AnyVal {\n  // Provide a more specific return type for Scaladoc\n  override def getClass(): Class[Unit] \u003d ???\n}\n\n@scala.annotation.compileTimeOnly(\"`Unit` companion object is not allowed in source; instead, use `()` for the unit value\")\nobject Unit extends AnyValCompanion {\n\n  /** Transform a value type into a boxed reference type.\n   *\n   *  This method is not intended for use in source code.\n   *  The runtime representation of this value is platform specific.\n   *\n   *  @param  x   the Unit to be boxed\n   *  @return     a scala.runtime.BoxedUnit offering `x` as its underlying value.\n   */\n  def box(x: Unit): scala.runtime.BoxedUnit \u003d scala.runtime.BoxedUnit.UNIT\n\n  /** Transform a boxed type into a value type.  Note that this\n   *  method is not typesafe: it accepts any Object, but will throw\n   *  an exception if the argument is not a scala.runtime.BoxedUnit.\n   *\n   *  This method is not intended for use in source code.\n   *  The result of successfully unboxing a value is `()`.\n   *\n   *  @param  x   the scala.runtime.BoxedUnit to be unboxed.\n   *  @throws     ClassCastException  if the argument is not a scala.runtime.BoxedUnit\n   *  @return     the Unit value ()\n   */\n  def unbox(x: java.lang.Object): Unit \u003d x.asInstanceOf[scala.runtime.BoxedUnit]\n\n  /** The String representation of the scala.Unit companion object. */\n  override def toString \u003d \"object scala.Unit\"\n}\n\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.25 23:58:57 INFO  time: compiled root-test in 0.47s
Apr. 26, 2024 12:01:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Array.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Array.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Array.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 12:01:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Predef.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 12:01:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Unit.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 00:02:19 INFO  compiling root (2 scala sources)
2024.04.26 00:02:19 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 55m 52.532s)
2024.04.26 00:02:19 INFO  compiling root (2 scala sources)
2024.04.26 00:02:19 INFO  time: compiled root in 0.11s
2024.04.26 00:02:19 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 55m 52.689s)
2024.04.26 00:02:19 INFO  compiling root (2 scala sources)
2024.04.26 00:02:19 INFO  compiling root (2 scala sources)
2024.04.26 00:02:19 INFO  time: compiled root in 0.24s
2024.04.26 00:02:20 INFO  {
  "jsonrpc": "2.0",
  "id": "78",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.26 00:02:20 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:509)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:509)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:484)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 00:02:40 INFO  compiling root (2 scala sources)
2024.04.26 00:02:40 INFO  time: compiled root in 0.12s
2024.04.26 00:02:52 INFO  compiling root (2 scala sources)
2024.04.26 00:02:52 INFO  time: compiled root in 0.66s
2024.04.26 00:02:53 INFO  compiling root (2 scala sources)
2024.04.26 00:02:53 INFO  time: compiled root in 0.46s
2024.04.26 00:02:53 INFO  compiling root (2 scala sources)
2024.04.26 00:02:53 INFO  time: compiled root in 0.44s
2024.04.26 00:03:10 INFO  compiling root (2 scala sources)
2024.04.26 00:03:10 INFO  time: compiled root in 0.27s
2024.04.26 00:03:13 INFO  compiling root (2 scala sources)
2024.04.26 00:03:13 WARN  Using indexes to guess the definition of createfield
2024.04.26 00:03:13 INFO  time: compiled root in 0.36s
2024.04.26 00:03:50 INFO  compiling root (2 scala sources)
2024.04.26 00:03:50 INFO  time: compiled root in 0.16s
Apr. 26, 2024 12:04:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1347
Apr. 26, 2024 12:04:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1350
Apr. 26, 2024 12:04:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1403
2024.04.26 00:05:41 INFO  compiling root (2 scala sources)
2024.04.26 00:05:41 INFO  time: compiled root in 0.11s
2024.04.26 00:07:34 INFO  compiling root (2 scala sources)
2024.04.26 00:07:34 INFO  time: compiled root in 0.28s
2024.04.26 00:08:04 INFO  compiling root (2 scala sources)
2024.04.26 00:08:04 INFO  time: compiled root in 0.25s
2024.04.26 00:08:14 INFO  compiling root (2 scala sources)
2024.04.26 00:08:14 INFO  time: compiled root in 0.25s
2024.04.26 00:08:44 INFO  compiling root (2 scala sources)
2024.04.26 00:08:44 INFO  time: compiled root in 0.38s
2024.04.26 00:08:49 INFO  compiling root (2 scala sources)
2024.04.26 00:08:49 INFO  time: compiled root in 0.38s
2024.04.26 00:09:58 INFO  compiling root (2 scala sources)
2024.04.26 00:09:58 INFO  time: compiled root in 0.33s
2024.04.26 00:10:11 INFO  compiling root (2 scala sources)
2024.04.26 00:10:11 INFO  time: compiled root in 0.29s
2024.04.26 00:10:21 INFO  compiling root (2 scala sources)
2024.04.26 00:10:21 INFO  time: compiled root in 0.23s
2024.04.26 00:10:32 INFO  compiling root (2 scala sources)
2024.04.26 00:10:32 INFO  time: compiled root in 0.23s
2024.04.26 00:10:39 INFO  compiling root (2 scala sources)
2024.04.26 00:10:39 INFO  time: compiled root in 0.28s
2024.04.26 00:11:37 INFO  compiling root (2 scala sources)
2024.04.26 00:11:37 INFO  time: compiled root in 0.21s
2024.04.26 00:11:42 INFO  compiling root (2 scala sources)
2024.04.26 00:11:42 INFO  time: compiled root in 0.24s
2024.04.26 00:11:51 INFO  compiling root (2 scala sources)
2024.04.26 00:11:51 INFO  time: compiled root in 0.22s
2024.04.26 00:11:57 INFO  compiling root (2 scala sources)
2024.04.26 00:11:57 INFO  time: compiled root in 0.22s
2024.04.26 00:12:52 INFO  compiling root (5 scala sources)
2024.04.26 00:12:52 INFO  time: compiled root in 0.49s
2024.04.26 00:12:57 INFO  compiling root (5 scala sources)
2024.04.26 00:12:57 INFO  time: compiled root in 0.36s
2024.04.26 00:13:15 INFO  compiling root (5 scala sources)
2024.04.26 00:13:15 INFO  time: compiled root in 0.37s
2024.04.26 00:13:35 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 12:13:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\nimport scala.annotation.migration\n\n/**\n * Core Scala types. They are always available without an explicit import.\n * @contentDiagram hideNodes \"scala.Serializable\"\n */\npackage object scala {\n  type Cloneable    \u003d java.lang.Cloneable\n  type Serializable \u003d java.io.Serializable\n\n  type Throwable \u003d java.lang.Throwable\n  type Exception \u003d java.lang.Exception\n  type Error     \u003d java.lang.Error\n\n  type RuntimeException                \u003d java.lang.RuntimeException\n  type NullPointerException            \u003d java.lang.NullPointerException\n  type ClassCastException              \u003d java.lang.ClassCastException\n  type IndexOutOfBoundsException       \u003d java.lang.IndexOutOfBoundsException\n  type ArrayIndexOutOfBoundsException  \u003d java.lang.ArrayIndexOutOfBoundsException\n  type StringIndexOutOfBoundsException \u003d java.lang.StringIndexOutOfBoundsException\n  type UnsupportedOperationException   \u003d java.lang.UnsupportedOperationException\n  type IllegalArgumentException        \u003d java.lang.IllegalArgumentException\n  type NoSuchElementException          \u003d java.util.NoSuchElementException\n  type NumberFormatException           \u003d java.lang.NumberFormatException\n  type AbstractMethodError             \u003d java.lang.AbstractMethodError\n  type InterruptedException            \u003d java.lang.InterruptedException\n\n  // A dummy used by the specialization annotation.\n  val AnyRef \u003d new Specializable {\n    override def toString \u003d \"object AnyRef\"\n  }\n\n  @deprecated(\"Use IterableOnce instead of TraversableOnce\", \"2.13.0\")\n  type TraversableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  type IterableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  type Traversable[+A] \u003d scala.collection.Iterable[A]\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  val Traversable \u003d scala.collection.Iterable\n\n  type Iterable[+A] \u003d scala.collection.Iterable[A]\n  val Iterable \u003d scala.collection.Iterable\n\n  @migration(\"scala.Seq is now scala.collection.immutable.Seq instead of scala.collection.Seq\", \"2.13.0\")\n  type Seq[+A] \u003d scala.collection.immutable.Seq[A]\n  val Seq \u003d scala.collection.immutable.Seq\n\n  @migration(\"scala.IndexedSeq is now scala.collection.immutable.IndexedSeq instead of scala.collection.IndexedSeq\", \"2.13.0\")\n  type IndexedSeq[+A] \u003d scala.collection.immutable.IndexedSeq[A]\n  val IndexedSeq \u003d scala.collection.immutable.IndexedSeq\n\n  type Iterator[+A] \u003d scala.collection.Iterator[A]\n  val Iterator \u003d scala.collection.Iterator\n\n  @deprecated(\"Use scala.collection.BufferedIterator instead of scala.BufferedIterator\", \"2.13.0\")\n  type BufferedIterator[+A] \u003d scala.collection.BufferedIterator[A]\n\n  type List[+A] \u003d scala.collection.immutable.List[A]\n  val List \u003d scala.collection.immutable.List\n\n  val Nil \u003d scala.collection.immutable.Nil\n\n  type ::[+A] \u003d scala.collection.immutable.::[A]\n  val :: \u003d scala.collection.immutable.::\n\n  val +: \u003d scala.collection.+:\n  val :+ \u003d scala.collection.:+\n\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  type Stream[+A] \u003d scala.collection.immutable.Stream[A]\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  val Stream \u003d scala.collection.immutable.Stream\n\n  type LazyList[+A] \u003d scala.collection.immutable.LazyList[A]\n  val LazyList \u003d scala.collection.immutable.LazyList\n  // This should be an alias to LazyList.#:: but we need to support Stream, too\n  //val #:: \u003d scala.collection.immutable.LazyList.#::\n  object #:: {\n    def unapply[A](s: LazyList[A]): Option[(A, LazyList[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n    @deprecated(\"Prefer LazyList instead\", since \u003d \"2.13.0\")\n    def unapply[A](s: Stream[A]): Option[(A, Stream[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n  }\n\n  type Vector[+A] \u003d scala.collection.immutable.Vector[A]\n  val Vector \u003d scala.collection.immutable.Vector\n\n  type StringBuilder \u003d scala.collection.mutable.StringBuilder\n  val StringBuilder \u003d scala.collection.mutable.StringBuilder\n\n  type Range \u003d scala.collection.immutable.Range\n  val Range \u003d scala.collection.immutable.Range\n\n  // Numeric types which were moved into scala.math.*\n\n  type BigDecimal \u003d scala.math.BigDecimal\n  val BigDecimal \u003d scala.math.BigDecimal\n\n  type BigInt \u003d scala.math.BigInt\n  val BigInt \u003d scala.math.BigInt\n\n  type Equiv[T] \u003d scala.math.Equiv[T]\n  val Equiv \u003d scala.math.Equiv\n\n  type Fractional[T] \u003d scala.math.Fractional[T]\n  val Fractional \u003d scala.math.Fractional\n\n  type Integral[T] \u003d scala.math.Integral[T]\n  val Integral \u003d scala.math.Integral\n\n  type Numeric[T] \u003d scala.math.Numeric[T]\n  val Numeric \u003d scala.math.Numeric\n\n  type Ordered[T] \u003d scala.math.Ordered[T]\n  val Ordered \u003d scala.math.Ordered\n\n  type Ordering[T] \u003d scala.math.Ordering[T]\n  val Ordering \u003d scala.math.Ordering\n\n  type PartialOrdering[T] \u003d scala.math.PartialOrdering[T]\n  type PartiallyOrdered[T] \u003d scala.math.PartiallyOrdered[T]\n\n  type Either[+A, +B] \u003d scala.util.Either[A, B]\n  val Either \u003d scala.util.Either\n\n  type Left[+A, +B] \u003d scala.util.Left[A, B]\n  val Left \u003d scala.util.Left\n\n  type Right[+A, +B] \u003d scala.util.Right[A, B]\n  val Right \u003d scala.util.Right\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 12:13:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 00:13:35 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 12:13:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\nimport scala.annotation.migration\n\n/**\n * Core Scala types. They are always available without an explicit import.\n * @contentDiagram hideNodes \"scala.Serializable\"\n */\npackage object scala {\n  type Cloneable    \u003d java.lang.Cloneable\n  type Serializable \u003d java.io.Serializable\n\n  type Throwable \u003d java.lang.Throwable\n  type Exception \u003d java.lang.Exception\n  type Error     \u003d java.lang.Error\n\n  type RuntimeException                \u003d java.lang.RuntimeException\n  type NullPointerException            \u003d java.lang.NullPointerException\n  type ClassCastException              \u003d java.lang.ClassCastException\n  type IndexOutOfBoundsException       \u003d java.lang.IndexOutOfBoundsException\n  type ArrayIndexOutOfBoundsException  \u003d java.lang.ArrayIndexOutOfBoundsException\n  type StringIndexOutOfBoundsException \u003d java.lang.StringIndexOutOfBoundsException\n  type UnsupportedOperationException   \u003d java.lang.UnsupportedOperationException\n  type IllegalArgumentException        \u003d java.lang.IllegalArgumentException\n  type NoSuchElementException          \u003d java.util.NoSuchElementException\n  type NumberFormatException           \u003d java.lang.NumberFormatException\n  type AbstractMethodError             \u003d java.lang.AbstractMethodError\n  type InterruptedException            \u003d java.lang.InterruptedException\n\n  // A dummy used by the specialization annotation.\n  val AnyRef \u003d new Specializable {\n    override def toString \u003d \"object AnyRef\"\n  }\n\n  @deprecated(\"Use IterableOnce instead of TraversableOnce\", \"2.13.0\")\n  type TraversableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  type IterableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  type Traversable[+A] \u003d scala.collection.Iterable[A]\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  val Traversable \u003d scala.collection.Iterable\n\n  type Iterable[+A] \u003d scala.collection.Iterable[A]\n  val Iterable \u003d scala.collection.Iterable\n\n  @migration(\"scala.Seq is now scala.collection.immutable.Seq instead of scala.collection.Seq\", \"2.13.0\")\n  type Seq[+A] \u003d scala.collection.immutable.Seq[A]\n  val Seq \u003d scala.collection.immutable.Seq\n\n  @migration(\"scala.IndexedSeq is now scala.collection.immutable.IndexedSeq instead of scala.collection.IndexedSeq\", \"2.13.0\")\n  type IndexedSeq[+A] \u003d scala.collection.immutable.IndexedSeq[A]\n  val IndexedSeq \u003d scala.collection.immutable.IndexedSeq\n\n  type Iterator[+A] \u003d scala.collection.Iterator[A]\n  val Iterator \u003d scala.collection.Iterator\n\n  @deprecated(\"Use scala.collection.BufferedIterator instead of scala.BufferedIterator\", \"2.13.0\")\n  type BufferedIterator[+A] \u003d scala.collection.BufferedIterator[A]\n\n  type List[+A] \u003d scala.collection.immutable.List[A]\n  val List \u003d scala.collection.immutable.List\n\n  val Nil \u003d scala.collection.immutable.Nil\n\n  type ::[+A] \u003d scala.collection.immutable.::[A]\n  val :: \u003d scala.collection.immutable.::\n\n  val +: \u003d scala.collection.+:\n  val :+ \u003d scala.collection.:+\n\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  type Stream[+A] \u003d scala.collection.immutable.Stream[A]\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  val Stream \u003d scala.collection.immutable.Stream\n\n  type LazyList[+A] \u003d scala.collection.immutable.LazyList[A]\n  val LazyList \u003d scala.collection.immutable.LazyList\n  // This should be an alias to LazyList.#:: but we need to support Stream, too\n  //val #:: \u003d scala.collection.immutable.LazyList.#::\n  object #:: {\n    def unapply[A](s: LazyList[A]): Option[(A, LazyList[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n    @deprecated(\"Prefer LazyList instead\", since \u003d \"2.13.0\")\n    def unapply[A](s: Stream[A]): Option[(A, Stream[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n  }\n\n  type Vector[+A] \u003d scala.collection.immutable.Vector[A]\n  val Vector \u003d scala.collection.immutable.Vector\n\n  type StringBuilder \u003d scala.collection.mutable.StringBuilder\n  val StringBuilder \u003d scala.collection.mutable.StringBuilder\n\n  type Range \u003d scala.collection.immutable.Range\n  val Range \u003d scala.collection.immutable.Range\n\n  // Numeric types which were moved into scala.math.*\n\n  type BigDecimal \u003d scala.math.BigDecimal\n  val BigDecimal \u003d scala.math.BigDecimal\n\n  type BigInt \u003d scala.math.BigInt\n  val BigInt \u003d scala.math.BigInt\n\n  type Equiv[T] \u003d scala.math.Equiv[T]\n  val Equiv \u003d scala.math.Equiv\n\n  type Fractional[T] \u003d scala.math.Fractional[T]\n  val Fractional \u003d scala.math.Fractional\n\n  type Integral[T] \u003d scala.math.Integral[T]\n  val Integral \u003d scala.math.Integral\n\n  type Numeric[T] \u003d scala.math.Numeric[T]\n  val Numeric \u003d scala.math.Numeric\n\n  type Ordered[T] \u003d scala.math.Ordered[T]\n  val Ordered \u003d scala.math.Ordered\n\n  type Ordering[T] \u003d scala.math.Ordering[T]\n  val Ordering \u003d scala.math.Ordering\n\n  type PartialOrdering[T] \u003d scala.math.PartialOrdering[T]\n  type PartiallyOrdered[T] \u003d scala.math.PartiallyOrdered[T]\n\n  type Either[+A, +B] \u003d scala.util.Either[A, B]\n  val Either \u003d scala.util.Either\n\n  type Left[+A, +B] \u003d scala.util.Left[A, B]\n  val Left \u003d scala.util.Left\n\n  type Right[+A, +B] \u003d scala.util.Right[A, B]\n  val Right \u003d scala.util.Right\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 00:14:04 INFO  compiling root (5 scala sources)
2024.04.26 00:14:04 INFO  time: compiled root in 0.37s
2024.04.26 00:15:04 INFO  compiling root (5 scala sources)
2024.04.26 00:15:04 INFO  time: compiled root in 0.35s
Apr. 26, 2024 12:15:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3269
2024.04.26 00:16:07 INFO  compiling root (5 scala sources)
2024.04.26 00:16:07 INFO  time: compiled root in 0.32s
2024.04.26 00:16:09 INFO  compiling root (5 scala sources)
2024.04.26 00:16:09 INFO  time: compiled root in 0.39s
2024.04.26 00:16:09 INFO  compiling root (5 scala sources)
2024.04.26 00:16:10 INFO  time: compiled root in 0.43s
2024.04.26 00:16:16 INFO  compiling root (5 scala sources)
2024.04.26 00:16:16 INFO  time: compiled root in 0.18s
2024.04.26 00:16:21 INFO  compiling root (5 scala sources)
2024.04.26 00:16:21 INFO  time: compiled root in 0.34s
2024.04.26 00:16:22 INFO  compiling root (5 scala sources)
2024.04.26 00:16:22 INFO  time: compiled root in 0.28s
2024.04.26 00:16:22 INFO  compiling root (5 scala sources)
2024.04.26 00:16:22 INFO  time: compiled root in 0.39s
Apr. 26, 2024 12:16:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 00:16:54 INFO  compiling root (5 scala sources)
2024.04.26 00:16:54 INFO  time: compiled root in 0.26s
2024.04.26 00:16:59 INFO  compiling root (5 scala sources)
2024.04.26 00:16:59 INFO  time: compiled root in 0.25s
2024.04.26 00:18:50 INFO  compiling root (5 scala sources)
2024.04.26 00:18:50 INFO  time: compiled root in 0.19s
2024.04.26 00:19:13 INFO  compiling root (5 scala sources)
2024.04.26 00:19:13 INFO  time: compiled root in 0.15s
Apr. 26, 2024 12:19:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3975
2024.04.26 00:19:34 INFO  compiling root (5 scala sources)
2024.04.26 00:19:34 INFO  time: compiled root in 0.17s
2024.04.26 00:19:35 INFO  compiling root (5 scala sources)
2024.04.26 00:19:35 INFO  time: compiled root in 0.2s
2024.04.26 00:19:35 INFO  compiling root (5 scala sources)
2024.04.26 00:19:35 INFO  time: compiled root in 0.2s
2024.04.26 00:19:35 INFO  compiling root (5 scala sources)
2024.04.26 00:19:35 INFO  time: compiled root in 0.2s
2024.04.26 00:19:43 INFO  compiling root (5 scala sources)
2024.04.26 00:19:43 INFO  time: compiled root in 0.17s
2024.04.26 00:19:44 INFO  compiling root (5 scala sources)
2024.04.26 00:19:44 INFO  time: compiled root in 0.21s
2024.04.26 00:19:44 INFO  compiling root (5 scala sources)
2024.04.26 00:19:44 INFO  time: compiled root in 0.17s
2024.04.26 00:19:44 INFO  compiling root (5 scala sources)
2024.04.26 00:19:44 INFO  time: compiled root in 0.17s
2024.04.26 00:19:44 INFO  compiling root (5 scala sources)
2024.04.26 00:19:45 INFO  time: compiled root in 0.21s
2024.04.26 00:19:45 INFO  compiling root (5 scala sources)
2024.04.26 00:19:45 INFO  time: compiled root in 0.23s
2024.04.26 00:19:55 INFO  compiling root (5 scala sources)
2024.04.26 00:19:55 INFO  time: compiled root in 0.81s
2024.04.26 00:19:57 INFO  compiling root (2 scala sources)
2024.04.26 00:19:57 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 1h 13m 30.456s)
2024.04.26 00:19:57 INFO  compiling root (2 scala sources)
2024.04.26 00:19:57 INFO  compiling root-test (3 scala sources)
2024.04.26 00:19:57 INFO  time: compiled root in 0.46s
2024.04.26 00:19:59 INFO  time: compiled root-test in 0.57s
2024.04.26 00:19:59 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 00:19:59 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 00:19:59 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 00:19:59 INFO  Loaded expression compiler in 0 milliseconds
2024.04.26 00:19:59 INFO  Loaded step filter in 0 milliseconds
2024.04.26 00:20:01 INFO  Loaded all sources and classes in 1 second
2024.04.26 00:20:01 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:61941 .
2024.04.26 00:20:01 INFO  Attaching to debuggee VM succeeded.
2024.04.26 00:20:02 INFO  Closing debug server tcp://0.0.0.0:61938
2024.04.26 00:20:02 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 00:20:30 INFO  compiling root (1 scala source)
2024.04.26 00:20:30 INFO  time: compiled root in 0.16s
2024.04.26 00:20:31 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 1h 14m 4.248s)
2024.04.26 00:20:31 INFO  compiling root-test (3 scala sources)
2024.04.26 00:20:31 INFO  time: compiled root-test in 0.34s
2024.04.26 00:20:32 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 00:20:32 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 00:20:32 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 00:20:31 INFO  Loaded expression compiler in 1 millisecond
2024.04.26 00:20:31 INFO  Loaded step filter in 0 milliseconds
2024.04.26 00:20:33 INFO  Loaded all sources and classes in 1 second
2024.04.26 00:20:33 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:61958 .
2024.04.26 00:20:33 INFO  Attaching to debuggee VM succeeded.
2024.04.26 00:20:34 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 00:20:34 INFO  Closing debug server tcp://0.0.0.0:61956
2024.04.26 00:23:16 INFO  compiling root (1 scala source)
2024.04.26 00:23:16 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 1h 16m 48.505s)
2024.04.26 00:23:16 INFO  compiling root (1 scala source)
2024.04.26 00:23:16 INFO  time: compiled root in 0.23s
2024.04.26 00:23:16 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 1h 16m 48.776s)
2024.04.26 00:23:16 INFO  compiling root (1 scala source)
2024.04.26 00:23:16 INFO  compiling root (1 scala source)
2024.04.26 00:23:16 INFO  time: compiled root in 0.3s
2024.04.26 00:23:16 INFO  {
  "jsonrpc": "2.0",
  "id": "274",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.26 00:23:16 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:509)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:509)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:484)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 00:23:35 INFO  compiling root (1 scala source)
2024.04.26 00:23:35 INFO  time: compiled root in 0.21s
2024.04.26 00:23:37 INFO  compiling root (1 scala source)
2024.04.26 00:23:37 INFO  time: compiled root in 0.3s
2024.04.26 00:23:38 INFO  compiling root (1 scala source)
2024.04.26 00:23:38 INFO  time: compiled root in 0.28s
2024.04.26 00:23:49 INFO  compiling root (1 scala source)
2024.04.26 00:23:49 INFO  time: compiled root in 0.22s
2024.04.26 00:24:11 INFO  compiling root (1 scala source)
2024.04.26 00:24:11 INFO  time: compiled root in 0.23s
2024.04.26 00:24:14 INFO  compiling root (1 scala source)
2024.04.26 00:24:14 INFO  time: compiled root in 0.31s
2024.04.26 00:24:24 INFO  compiling root (1 scala source)
2024.04.26 00:24:24 INFO  time: compiled root in 0.27s
2024.04.26 00:24:26 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 1h 17m 58.952s)
2024.04.26 00:24:26 INFO  compiling root-test (3 scala sources)
2024.04.26 00:24:26 INFO  time: compiled root-test in 0.25s
2024.04.26 00:24:26 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 00:24:26 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 00:24:27 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 00:24:26 INFO  Loaded expression compiler in 0 milliseconds
2024.04.26 00:24:26 INFO  Loaded step filter in 0 milliseconds
2024.04.26 00:24:28 INFO  Loaded all sources and classes in 1 second
2024.04.26 00:24:28 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:62060 .
2024.04.26 00:24:28 INFO  Attaching to debuggee VM succeeded.
2024.04.26 00:24:28 INFO  Closing debug server tcp://0.0.0.0:62058
2024.04.26 00:24:29 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 00:26:22 INFO  compiling root (1 scala source)
2024.04.26 00:26:22 INFO  time: compiled root in 0.25s
Apr. 26, 2024 12:27:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4954
2024.04.26 00:28:26 INFO  compiling root (1 scala source)
2024.04.26 00:28:26 INFO  time: compiled root in 0.14s
2024.04.26 00:29:01 INFO  compiling root (1 scala source)
2024.04.26 00:29:01 INFO  time: compiled root in 0.25s
2024.04.26 00:29:24 INFO  compiling root (1 scala source)
2024.04.26 00:29:24 INFO  time: compiled root in 0.22s
2024.04.26 00:32:58 INFO  compiling root (1 scala source)
2024.04.26 00:32:58 INFO  time: compiled root in 0.22s
2024.04.26 00:33:29 INFO  compiling root (1 scala source)
2024.04.26 00:33:29 INFO  time: compiled root in 0.29s
Apr. 26, 2024 12:33:45 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5963
2024.04.26 00:34:46 WARN  Using indexes to guess the definition of getCords
2024.04.26 00:34:47 INFO  compiling root (1 scala source)
2024.04.26 00:34:47 WARN  Using indexes to guess the definition of getCords
2024.04.26 00:34:47 INFO  time: compiled root in 0.23s
2024.04.26 00:34:58 INFO  compiling root (1 scala source)
2024.04.26 00:34:58 INFO  time: compiled root in 0.13s
2024.04.26 00:35:02 INFO  compiling root (1 scala source)
2024.04.26 00:35:02 INFO  time: compiled root in 0.11s
Apr. 26, 2024 12:35:07 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 6179
2024.04.26 00:35:17 INFO  compiling root (1 scala source)
2024.04.26 00:35:17 INFO  time: compiled root in 0.25s
2024.04.26 00:35:58 INFO  compiling root (1 scala source)
2024.04.26 00:35:58 INFO  time: compiled root in 0.12s
2024.04.26 00:38:02 INFO  compiling root (1 scala source)
2024.04.26 00:38:02 INFO  time: compiled root in 0.13s
2024.04.26 00:38:22 INFO  compiling root (1 scala source)
2024.04.26 00:38:22 INFO  time: compiled root in 0.21s
2024.04.26 00:38:33 INFO  compiling root (1 scala source)
2024.04.26 00:38:33 INFO  time: compiled root in 0.13s
2024.04.26 00:38:59 INFO  compiling root (1 scala source)
2024.04.26 00:38:59 INFO  time: compiled root in 0.12s
2024.04.26 00:39:18 INFO  compiling root (1 scala source)
2024.04.26 00:39:18 INFO  time: compiled root in 0.22s
Apr. 26, 2024 12:39:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 6648
2024.04.26 00:39:45 INFO  compiling root (1 scala source)
2024.04.26 00:39:45 INFO  time: compiled root in 0.22s
2024.04.26 00:41:09 INFO  compiling root (1 scala source)
2024.04.26 00:41:09 INFO  time: compiled root in 0.24s
2024.04.26 00:42:35 INFO  compiling root (1 scala source)
2024.04.26 00:42:35 INFO  time: compiled root in 0.33s
2024.04.26 00:42:55 INFO  compiling root (1 scala source)
2024.04.26 00:42:55 INFO  time: compiled root in 0.36s
2024.04.26 00:44:15 INFO  compiling root (1 scala source)
2024.04.26 00:44:15 INFO  time: compiled root in 0.21s
2024.04.26 00:44:27 INFO  compiling root (1 scala source)
2024.04.26 00:44:27 INFO  time: compiled root in 0.11s
Apr. 26, 2024 12:45:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 7155
2024.04.26 00:46:34 WARN  Using indexes to guess the definition of vLine
2024.04.26 00:46:35 INFO  compiling root (1 scala source)
2024.04.26 00:46:35 INFO  time: compiled root in 0.12s
2024.04.26 00:47:57 INFO  compiling root (1 scala source)
2024.04.26 00:47:57 INFO  time: compiled root in 0.11s
2024.04.26 00:48:16 INFO  compiling root (1 scala source)
2024.04.26 00:48:16 INFO  time: compiled root in 0.12s
2024.04.26 00:48:43 INFO  compiling root (1 scala source)
2024.04.26 00:48:43 INFO  time: compiled root in 0.11s
2024.04.26 00:49:28 INFO  compiling root (1 scala source)
2024.04.26 00:49:28 INFO  time: compiled root in 0.14s
2024.04.26 00:49:54 INFO  compiling root (1 scala source)
2024.04.26 00:49:54 INFO  time: compiled root in 0.14s
2024.04.26 00:49:54 INFO  compiling root (1 scala source)
2024.04.26 00:49:54 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 1h 43m 27.399s)
2024.04.26 00:49:54 INFO  compiling root (1 scala source)
2024.04.26 00:49:54 INFO  time: compiled root in 0.19s
Apr. 26, 2024 12:50:26 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 7887
2024.04.26 00:50:40 INFO  compiling root (1 scala source)
2024.04.26 00:50:40 INFO  time: compiled root in 0.11s
Apr. 26, 2024 12:53:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8357
2024.04.26 00:55:21 INFO  compiling root (1 scala source)
2024.04.26 00:55:21 INFO  time: compiled root in 0.12s
2024.04.26 00:55:29 INFO  compiling root (1 scala source)
2024.04.26 00:55:29 INFO  time: compiled root in 0.12s
2024.04.26 00:55:56 INFO  compiling root (1 scala source)
2024.04.26 00:55:56 INFO  time: compiled root in 0.12s
2024.04.26 00:57:33 INFO  compiling root (1 scala source)
2024.04.26 00:57:33 INFO  time: compiled root in 0.12s
Apr. 26, 2024 12:58:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9061
2024.04.26 00:58:06 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:41: error: unclosed string literal
    sr.append(checkFieldR(x+1,y) + "\")
                                   ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 00:58:22 INFO  compiling root (1 scala source)
2024.04.26 00:58:22 INFO  time: compiled root in 0.12s
Apr. 26, 2024 12:58:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9146
2024.04.26 01:02:17 INFO  compiling root (1 scala source)
2024.04.26 01:02:17 INFO  time: compiled root in 0.14s
2024.04.26 01:02:17 INFO  compiling root (1 scala source)
2024.04.26 01:02:17 INFO  time: compiled root in 0.15s
Apr. 26, 2024 1:04:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9567
Apr. 26, 2024 1:08:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9981
2024.04.26 01:10:35 INFO  compiling root (2 scala sources)
2024.04.26 01:10:36 INFO  time: compiled root in 1.01s
Apr. 26, 2024 1:10:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 10347
2024.04.26 01:10:45 INFO  compiling root (2 scala sources)
2024.04.26 01:10:45 INFO  time: compiled root in 0.27s
2024.04.26 01:11:03 INFO  compiling root (2 scala sources)
2024.04.26 01:11:03 INFO  time: compiled root in 0.32s
Apr. 26, 2024 1:11:14 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 10468
2024.04.26 01:11:22 INFO  compiling root (2 scala sources)
2024.04.26 01:11:22 INFO  time: compiled root in 0.28s
2024.04.26 01:11:31 INFO  compiling root (2 scala sources)
2024.04.26 01:11:31 INFO  time: compiled root in 0.13s
2024.04.26 01:12:41 INFO  compiling root (2 scala sources)
2024.04.26 01:12:41 INFO  time: compiled root in 0.15s
2024.04.26 01:13:01 INFO  compiling root (2 scala sources)
2024.04.26 01:13:01 INFO  time: compiled root in 0.22s
2024.04.26 01:13:02 WARN  Using indexes to guess the definition of Chesspiece
2024.04.26 01:13:02 INFO  compiling root (2 scala sources)
2024.04.26 01:13:02 WARN  Using indexes to guess the definition of Chesspiece
2024.04.26 01:13:02 INFO  time: compiled root in 0.2s
2024.04.26 01:13:17 INFO  compiling root (2 scala sources)
2024.04.26 01:13:17 INFO  time: compiled root in 0.32s
2024.04.26 01:13:24 INFO  compiling root (2 scala sources)
2024.04.26 01:13:24 INFO  time: compiled root in 0.32s
2024.04.26 01:13:34 INFO  compiling root (2 scala sources)
2024.04.26 01:13:34 INFO  time: compiled root in 0.33s
2024.04.26 01:13:35 INFO  compiling root (2 scala sources)
2024.04.26 01:13:35 INFO  time: compiled root in 0.27s
2024.04.26 01:13:35 INFO  compiling root (2 scala sources)
2024.04.26 01:13:35 INFO  time: compiled root in 0.34s
2024.04.26 01:13:44 INFO  compiling root (2 scala sources)
2024.04.26 01:13:44 INFO  time: compiled root in 0.3s
2024.04.26 01:13:52 INFO  compiling root (2 scala sources)
2024.04.26 01:13:52 INFO  time: compiled root in 0.16s
2024.04.26 01:14:04 INFO  compiling root (2 scala sources)
2024.04.26 01:14:04 INFO  time: compiled root in 0.13s
2024.04.26 01:14:32 INFO  compiling root (2 scala sources)
2024.04.26 01:14:32 INFO  time: compiled root in 0.16s
2024.04.26 01:16:44 INFO  compiling root (2 scala sources)
2024.04.26 01:16:44 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 1:16:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// DO NOT EDIT, CHANGES WILL BE LOST\n// This auto-generated code can be modified in \"project/GenerateAnyVals.scala\".\n// Afterwards, running \"sbt generateSources\" regenerates this source file.\n\npackage scala\n\n/** `Int`, a 32-bit signed integer (equivalent to Java\u0027s `int` primitive type) is a\n *  subtype of [[scala.AnyVal]]. Instances of `Int` are not\n *  represented by an object in the underlying runtime system.\n *\n *  There is an implicit conversion from [[scala.Int]] \u003d\u003e [[scala.runtime.RichInt]]\n *  which provides useful non-primitive operations.\n */\nfinal abstract class Int private extends AnyVal {\n  def toByte: Byte\n  def toShort: Short\n  def toChar: Char\n  def toInt: Int\n  def toLong: Long\n  def toFloat: Float\n  def toDouble: Double\n\n  /**\n * Returns the bitwise negation of this value.\n * @example {{{\n * ~5 \u003d\u003d -6\n * // in binary: ~00000101 \u003d\u003d\n * //             11111010\n * }}}\n */\n  def unary_~ : Int\n  /** Returns this value, unmodified. */\n  def unary_+ : Int\n  /** Returns the negation of this value. */\n  def unary_- : Int\n\n  @deprecated(\"Adding a number and a String is deprecated. Use the string interpolation `s\\\"$num$str\\\"`\", \"2.13.0\")\n  def +(x: String): String\n\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  def \u003c\u003c(x: Int): Int\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003c\u003c(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e\u003e(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e(x: Long): Int\n\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Short): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Char): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Int): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Long): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Float): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Short): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Char): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Int): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Long): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Float): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Byte): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Short): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Char): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Int): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Long): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Float): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Double): Boolean\n\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Short): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Char): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Int): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Long): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Float): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Byte): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Short): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Char): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Int): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Long): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Float): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Short): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Char): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Int): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Long): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Float): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Double): Boolean\n\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Byte): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Short): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Char): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Int): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Long): Long\n\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Byte): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Short): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Char): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Int): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Long): Long\n\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Byte): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Short): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Char): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Int): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Long): Long\n\n  /** Returns the sum of this value and `x`. */\n  def +(x: Byte): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Short): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Char): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Int): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Long): Long\n  /** Returns the sum of this value and `x`. */\n  def +(x: Float): Float\n  /** Returns the sum of this value and `x`. */\n  def +(x: Double): Double\n\n  /** Returns the difference of this value and `x`. */\n  def -(x: Byte): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Short): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Char): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Int): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Long): Long\n  /** Returns the difference of this value and `x`. */\n  def -(x: Float): Float\n  /** Returns the difference of this value and `x`. */\n  def -(x: Double): Double\n\n  /** Returns the product of this value and `x`. */\n  def *(x: Byte): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Short): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Char): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Int): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Long): Long\n  /** Returns the product of this value and `x`. */\n  def *(x: Float): Float\n  /** Returns the product of this value and `x`. */\n  def *(x: Double): Double\n\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Byte): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Short): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Char): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Int): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Long): Long\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Float): Float\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Double): Double\n\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Byte): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Short): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Char): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Int): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Long): Long\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Float): Float\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Double): Double\n\n  // Provide a more specific return type for Scaladoc\n  override def getClass(): Class[Int] \u003d ???\n}\n\nobject Int extends AnyValCompanion {\n  /** The smallest value representable as an Int. */\n  final val MinValue \u003d java.lang.Integer.MIN_VALUE\n\n  /** The largest value representable as an Int. */\n  final val MaxValue \u003d java.lang.Integer.MAX_VALUE\n\n  /** Transform a value type into a boxed reference type.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.boxToInteger`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the Int to be boxed\n   *  @return     a java.lang.Integer offering `x` as its underlying value.\n   */\n  def box(x: Int): java.lang.Integer \u003d ???\n\n  /** Transform a boxed type into a value type.  Note that this\n   *  method is not typesafe: it accepts any Object, but will throw\n   *  an exception if the argument is not a java.lang.Integer.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.unboxToInt`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the java.lang.Integer to be unboxed.\n   *  @throws     ClassCastException  if the argument is not a java.lang.Integer\n   *  @return     the Int resulting from calling intValue() on `x`\n   */\n  def unbox(x: java.lang.Object): Int \u003d ???\n\n  /** The String representation of the scala.Int companion object. */\n  override def toString \u003d \"object scala.Int\"\n  /** Language mandated coercions from Int to \"wider\" types. */\n  import scala.language.implicitConversions\n  @deprecated(\"Implicit conversion from Int to Float is dangerous because it loses precision. Write `.toFloat` instead.\", \"2.13.1\")\n  implicit def int2float(x: Int): Float \u003d x.toFloat\n  implicit def int2long(x: Int): Long \u003d x.toLong\n  implicit def int2double(x: Int): Double \u003d x.toDouble\n}\n\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 1:16:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 01:16:44 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 1:16:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// DO NOT EDIT, CHANGES WILL BE LOST\n// This auto-generated code can be modified in \"project/GenerateAnyVals.scala\".\n// Afterwards, running \"sbt generateSources\" regenerates this source file.\n\npackage scala\n\n/** `Int`, a 32-bit signed integer (equivalent to Java\u0027s `int` primitive type) is a\n *  subtype of [[scala.AnyVal]]. Instances of `Int` are not\n *  represented by an object in the underlying runtime system.\n *\n *  There is an implicit conversion from [[scala.Int]] \u003d\u003e [[scala.runtime.RichInt]]\n *  which provides useful non-primitive operations.\n */\nfinal abstract class Int private extends AnyVal {\n  def toByte: Byte\n  def toShort: Short\n  def toChar: Char\n  def toInt: Int\n  def toLong: Long\n  def toFloat: Float\n  def toDouble: Double\n\n  /**\n * Returns the bitwise negation of this value.\n * @example {{{\n * ~5 \u003d\u003d -6\n * // in binary: ~00000101 \u003d\u003d\n * //             11111010\n * }}}\n */\n  def unary_~ : Int\n  /** Returns this value, unmodified. */\n  def unary_+ : Int\n  /** Returns the negation of this value. */\n  def unary_- : Int\n\n  @deprecated(\"Adding a number and a String is deprecated. Use the string interpolation `s\\\"$num$str\\\"`\", \"2.13.0\")\n  def +(x: String): String\n\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  def \u003c\u003c(x: Int): Int\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003c\u003c(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e\u003e(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e(x: Long): Int\n\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Short): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Char): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Int): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Long): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Float): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Short): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Char): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Int): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Long): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Float): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Byte): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Short): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Char): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Int): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Long): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Float): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Double): Boolean\n\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Short): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Char): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Int): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Long): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Float): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Byte): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Short): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Char): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Int): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Long): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Float): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Short): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Char): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Int): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Long): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Float): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Double): Boolean\n\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Byte): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Short): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Char): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Int): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Long): Long\n\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Byte): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Short): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Char): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Int): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Long): Long\n\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Byte): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Short): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Char): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Int): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Long): Long\n\n  /** Returns the sum of this value and `x`. */\n  def +(x: Byte): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Short): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Char): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Int): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Long): Long\n  /** Returns the sum of this value and `x`. */\n  def +(x: Float): Float\n  /** Returns the sum of this value and `x`. */\n  def +(x: Double): Double\n\n  /** Returns the difference of this value and `x`. */\n  def -(x: Byte): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Short): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Char): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Int): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Long): Long\n  /** Returns the difference of this value and `x`. */\n  def -(x: Float): Float\n  /** Returns the difference of this value and `x`. */\n  def -(x: Double): Double\n\n  /** Returns the product of this value and `x`. */\n  def *(x: Byte): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Short): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Char): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Int): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Long): Long\n  /** Returns the product of this value and `x`. */\n  def *(x: Float): Float\n  /** Returns the product of this value and `x`. */\n  def *(x: Double): Double\n\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Byte): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Short): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Char): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Int): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Long): Long\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Float): Float\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Double): Double\n\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Byte): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Short): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Char): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Int): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Long): Long\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Float): Float\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Double): Double\n\n  // Provide a more specific return type for Scaladoc\n  override def getClass(): Class[Int] \u003d ???\n}\n\nobject Int extends AnyValCompanion {\n  /** The smallest value representable as an Int. */\n  final val MinValue \u003d java.lang.Integer.MIN_VALUE\n\n  /** The largest value representable as an Int. */\n  final val MaxValue \u003d java.lang.Integer.MAX_VALUE\n\n  /** Transform a value type into a boxed reference type.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.boxToInteger`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the Int to be boxed\n   *  @return     a java.lang.Integer offering `x` as its underlying value.\n   */\n  def box(x: Int): java.lang.Integer \u003d ???\n\n  /** Transform a boxed type into a value type.  Note that this\n   *  method is not typesafe: it accepts any Object, but will throw\n   *  an exception if the argument is not a java.lang.Integer.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.unboxToInt`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the java.lang.Integer to be unboxed.\n   *  @throws     ClassCastException  if the argument is not a java.lang.Integer\n   *  @return     the Int resulting from calling intValue() on `x`\n   */\n  def unbox(x: java.lang.Object): Int \u003d ???\n\n  /** The String representation of the scala.Int companion object. */\n  override def toString \u003d \"object scala.Int\"\n  /** Language mandated coercions from Int to \"wider\" types. */\n  import scala.language.implicitConversions\n  @deprecated(\"Implicit conversion from Int to Float is dangerous because it loses precision. Write `.toFloat` instead.\", \"2.13.1\")\n  implicit def int2float(x: Int): Float \u003d x.toFloat\n  implicit def int2long(x: Int): Long \u003d x.toLong\n  implicit def int2double(x: Int): Double \u003d x.toDouble\n}\n\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 01:16:44 INFO  time: compiled root in 0.27s
2024.04.26 01:17:54 INFO  compiling root (2 scala sources)
2024.04.26 01:17:54 INFO  time: compiled root in 0.18s
2024.04.26 01:18:44 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 1:18:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/mutable/StringBuilder.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala.collection.mutable\n\nimport scala.collection.{IterableFactoryDefaults, IterableOnce}\nimport scala.collection.immutable.WrappedString\n\nimport scala.Predef.{ // unimport char-related implicit conversions to avoid triggering them accidentally\n  genericArrayOps \u003d\u003e _,\n  charArrayOps \u003d\u003e _,\n  genericWrapArray \u003d\u003e _,\n  wrapCharArray \u003d\u003e _,\n  wrapString \u003d\u003e _,\n //_\n}\n\n/** A builder of `String` which is also a mutable sequence of characters.\n *\n *  This class provides an API mostly compatible with `java.lang.StringBuilder`,\n *  except where there are conflicts with the Scala collections API, such as the `reverse` method:\n *  [[reverse]] produces a new `StringBuilder`, and [[reverseInPlace]] mutates this builder.\n *\n *  Mutating operations return either `this.type`, i.e., the current builder, or `Unit`.\n *\n *  Other methods extract data or information from the builder without mutating it.\n *\n *  The distinction is also reflected in naming conventions used by collections,\n *  such as `append`, which mutates, and `appended`, which does not, or `reverse`,\n *  which does not mutate, and `reverseInPlace`, which does.\n *\n *  The `String` result may be obtained using either `result()` or `toString`.\n *\n *  $multipleResults\n *\n *  @see [[https://docs.scala-lang.org/overviews/collections-2.13/concrete-mutable-collection-classes.html#stringbuilders \"Scala\u0027s Collection Library overview\"]]\n *  section on `StringBuilders` for more information.\n *\n *  @define Coll `mutable.IndexedSeq`\n *  @define coll string builder\n */\n@SerialVersionUID(3L)\nfinal class StringBuilder(val underlying: java.lang.StringBuilder) extends AbstractSeq[Char]\n  with ReusableBuilder[Char, String]\n  with IndexedSeq[Char]\n  with IndexedSeqOps[Char, IndexedSeq, StringBuilder]\n  with IterableFactoryDefaults[Char, IndexedSeq]\n  with java.lang.CharSequence\n  with Serializable {\n\n  def this() \u003d this(new java.lang.StringBuilder)\n\n  /** Constructs a string builder with no characters in it and an\n    *  initial capacity specified by the `capacity` argument.\n    *\n    *  @param  capacity  the initial capacity.\n    *  @throws java.lang.NegativeArraySizeException  if capacity \u003c 0.\n    */\n  def this(capacity: Int) \u003d this(new java.lang.StringBuilder(capacity))\n\n  /** Constructs a string builder with initial characters\n    *  equal to characters of `str`.\n    */\n  def this(str: String) \u003d this(new java.lang.StringBuilder(str))\n\n  /** Constructs a string builder initialized with string value `initValue`\n    *  and with additional character capacity `initCapacity`.\n    */\n  def this(initCapacity: Int, initValue: String) \u003d\n    this(new java.lang.StringBuilder(initValue.length + initCapacity) append initValue)\n\n  // Methods required to make this an IndexedSeq:\n  def apply(i: Int): Char \u003d underlying.charAt(i)\n\n  override protected def fromSpecific(coll: scala.collection.IterableOnce[Char]): StringBuilder \u003d\n    new StringBuilder() appendAll coll\n\n  override protected def newSpecificBuilder: Builder[Char, StringBuilder] \u003d\n    new GrowableBuilder(new StringBuilder())\n\n  override def empty: StringBuilder \u003d new StringBuilder()\n\n  @inline def length: Int \u003d underlying.length\n\n  def length_\u003d(n: Int): Unit \u003d underlying.setLength(n)\n\n  override def knownSize: Int \u003d super[IndexedSeqOps].knownSize\n\n  def addOne(x: Char): this.type \u003d { underlying.append(x); this }\n\n  def clear(): Unit \u003d underlying.setLength(0)\n\n  /** Overloaded version of `addAll` that takes a string */\n  def addAll(s: String): this.type \u003d { underlying.append(s); this }\n\n  /** Alias for `addAll` */\n  def ++\u003d (s: String): this.type \u003d addAll(s)\n\n  def result() \u003d underlying.toString\n\n  override def toString: String \u003d result()\n\n  override def toArray[B \u003e: Char](implicit ct: scala.reflect.ClassTag[B]) \u003d\n    ct.runtimeClass match {\n      case java.lang.Character.TYPE \u003d\u003e toCharArray.asInstanceOf[Array[B]]\n      case _ \u003d\u003e super.toArray\n    }\n\n  /** Returns the contents of this StringBuilder as an `Array[Char]`.\n   *\n   *  @return  An array with the characters from this builder.\n   */\n  def toCharArray: Array[Char] \u003d {\n    val len \u003d underlying.length\n    val arr \u003d new Array[Char](len)\n    underlying.getChars(0, len, arr, 0)\n    arr\n  }\n\n  // append* methods delegate to the underlying java.lang.StringBuilder:\n\n  def appendAll(xs: String): this.type \u003d {\n    underlying append xs\n    this\n  }\n\n  /** Appends the string representation of the given argument,\n    *  which is converted to a String with `String.valueOf`.\n    *\n    *  @param  x   an `Any` object.\n    *  @return     this StringBuilder.\n    */\n  def append(x: Any): this.type \u003d {\n    underlying append String.valueOf(x)\n    this\n  }\n\n  /** Appends the given String to this sequence.\n    *\n    *  @param  s   a String.\n    *  @return     this StringBuilder.\n    */\n  def append(s: String): this.type \u003d {\n    underlying append s\n    this\n  }\n\n  /** Appends the given CharSequence to this sequence.\n    *\n    *  @param  cs   a CharSequence.\n    *  @return     this StringBuilder.\n    */\n  def append(cs: java.lang.CharSequence): this.type \u003d {\n    underlying.append(cs match {\n      // Both cases call into append(\u003cCharSequence\u003e), but java SB\n      // looks up type at runtime and has fast path for SB.\n      case s: StringBuilder \u003d\u003e s.underlying\n      case _                \u003d\u003e cs\n    })\n    this\n  }\n\n  /** Appends the specified string builder to this sequence.\n    *\n    *  @param s\n    *  @return\n    */\n  def append(s: StringBuilder): this.type \u003d {\n    underlying append s.underlying\n    this\n  }\n\n  /** Appends all the Chars in the given IterableOnce[Char] to this sequence.\n    *\n    *  @param  xs  the characters to be appended.\n    *  @return     this StringBuilder.\n    */\n  def appendAll(xs: IterableOnce[Char]): this.type \u003d {\n    xs match {\n      case x: WrappedString \u003d\u003e underlying append x.unwrap\n      case x: ArraySeq.ofChar \u003d\u003e underlying append x.array\n      case x: StringBuilder \u003d\u003e underlying append x.underlying\n      case _ \u003d\u003e\n        val ks \u003d xs.knownSize\n        if (ks !\u003d 0) {\n          val b \u003d underlying\n          if (ks \u003e 0) b.ensureCapacity(b.length + ks)\n          val it \u003d xs.iterator\n          while (it.hasNext) { b append it.next() }\n        }\n    }\n    this\n  }\n\n  /** Appends all the Chars in the given Array[Char] to this sequence.\n    *\n    *  @param  xs  the characters to be appended.\n    *  @return     a reference to this object.\n    */\n  def appendAll(xs: Array[Char]): this.type \u003d {\n    underlying append xs\n    this\n  }\n\n  /** Appends a portion of the given Array[Char] to this sequence.\n    *\n    *  @param  xs      the Array containing Chars to be appended.\n    *  @param  offset  the index of the first Char to append.\n    *  @param  len     the numbers of Chars to append.\n    *  @return         this StringBuilder.\n    */\n  def appendAll(xs: Array[Char], offset: Int, len: Int): this.type \u003d {\n    underlying.append(xs, offset, len)\n    this\n  }\n\n  /** Append the String representation of the given primitive type\n    *  to this sequence.  The argument is converted to a String with\n    *  String.valueOf.\n    *\n    *  @param   x  a primitive value\n    *  @return     This StringBuilder.\n    */\n  def append(x: Boolean): this.type \u003d { underlying append x ; this }\n  def append(x: Byte): this.type \u003d append(x.toInt)\n  def append(x: Short): this.type \u003d append(x.toInt)\n  def append(x: Int): this.type \u003d { underlying append x ; this }\n  def append(x: Long): this.type \u003d { underlying append x ; this }\n  def append(x: Float): this.type \u003d { underlying append x ; this }\n  def append(x: Double): this.type \u003d { underlying append x ; this }\n  def append(x: Char): this.type \u003d { underlying append x ; this }\n\n  /** Remove a subsequence of Chars from this sequence, starting at the\n    *  given start index (inclusive) and extending to the end index (exclusive)\n    *  or to the end of the String, whichever comes first.\n    *\n    *  @param  start  The beginning index, inclusive.\n    *  @param  end    The ending index, exclusive.\n    *  @return        This StringBuilder.\n    *  @throws StringIndexOutOfBoundsException   if start \u003c 0 || start \u003e end\n    */\n  def delete(start: Int, end: Int): this.type \u003d {\n    underlying.delete(start, end)\n    this\n  }\n\n  /** Replaces a subsequence of Chars with the given String.  The semantics\n    *  are as in delete, with the String argument then inserted at index \u0027start\u0027.\n    *\n    *  @param  start  The beginning index, inclusive.\n    *  @param  end    The ending index, exclusive.\n    *  @param  str    The String to be inserted at the start index.\n    *  @return        This StringBuilder.\n    *  @throws StringIndexOutOfBoundsException if start \u003c 0, start \u003e length, or start \u003e end\n    */\n  def replace(start: Int, end: Int, str: String): this.type \u003d {\n    underlying.replace(start, end, str)\n    this\n  }\n\n  /** Inserts a subarray of the given Array[Char] at the given index\n    *  of this sequence.\n    *\n    * @param  index   index at which to insert the subarray.\n    * @param  str     the Array from which Chars will be taken.\n    * @param  offset  the index of the first Char to insert.\n    * @param  len     the number of Chars from \u0027str\u0027 to insert.\n    * @return         This StringBuilder.\n    *\n    * @throws StringIndexOutOfBoundsException  if index \u003c 0, index \u003e length,\n    *         offset \u003c 0, len \u003c 0, or (offset + len) \u003e str.length.\n    */\n  def insertAll(index: Int, str: Array[Char], offset: Int, len: Int): this.type \u003d {\n    underlying.insert(index, str, offset, len)\n    this\n  }\n\n  /** Inserts the String representation (via String.valueOf) of the given\n    *  argument into this sequence at the given index.\n    *\n    *  @param  index   the index at which to insert.\n    *  @param  x       a value.\n    *  @return         this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insert(index: Int, x: Any): this.type \u003d insert(index, String.valueOf(x))\n\n  /** Inserts the String into this character sequence.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  x     a String.\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insert(index: Int, x: String): this.type \u003d {\n    underlying.insert(index, x)\n    this\n  }\n\n  /** Inserts the given Seq[Char] into this sequence at the given index.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  xs    the Seq[Char].\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insertAll(index: Int, xs: IterableOnce[Char]): this.type \u003d\n    insertAll(index, (ArrayBuilder.make[Char] ++\u003d xs).result())\n\n  /** Inserts the given Array[Char] into this sequence at the given index.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  xs    the Array[Char].\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insertAll(index: Int, xs: Array[Char]): this.type \u003d {\n    underlying.insert(index, xs)\n    this\n  }\n\n  /** Calls String.valueOf on the given primitive value, and inserts the\n    *  String at the given index.\n    *\n    *  @param  index the offset position.\n    *  @param  x     a primitive value.\n    *  @return       this StringBuilder.\n    */\n  def insert(index: Int, x: Boolean): this.type \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Byte): this.type    \u003d insert(index, x.toInt)\n  def insert(index: Int, x: Short): this.type   \u003d insert(index, x.toInt)\n  def insert(index: Int, x: Int): this.type     \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Long): this.type    \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Float): this.type   \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Double): this.type  \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Char): this.type    \u003d insert(index, String.valueOf(x))\n\n  /** Sets the length of the character sequence.  If the current sequence\n    *  is shorter than the given length, it is padded with nulls; if it is\n    *  longer, it is truncated.\n    *\n    *  @param  len  the new length\n    *  @throws IndexOutOfBoundsException if the argument is negative.\n    */\n  def setLength(len: Int): Unit \u003d underlying.setLength(len)\n\n  def update(idx: Int, elem: Char): Unit \u003d underlying.setCharAt(idx, elem)\n\n\n  /** Like reverse, but destructively updates the target StringBuilder.\n   *\n   *  @return   the reversed StringBuilder (same as the target StringBuilder)\n   */\n  @deprecated(\"Use reverseInPlace instead\", \"2.13.0\")\n  final def reverseContents(): this.type \u003d reverseInPlace()\n\n  /** Like reverse, but destructively updates the target StringBuilder.\n   *\n   *  @return   the reversed StringBuilder (same as the target StringBuilder)\n   */\n  def reverseInPlace(): this.type \u003d {\n    underlying.reverse()\n    this\n  }\n\n\n  /** Returns the current capacity, which is the size of the underlying array.\n   *  A new array will be allocated if the current capacity is exceeded.\n   *\n   *  @return  the capacity\n   */\n  def capacity: Int \u003d underlying.capacity\n\n  /** Ensure that the capacity is at least the given argument.\n   *  If the argument is greater than the current capacity, new\n   *  storage will be allocated with size equal to the given\n   *  argument or to `(2 * capacity + 2)`, whichever is larger.\n   *\n   *  @param newCapacity    the minimum desired capacity.\n   */\n  def ensureCapacity(newCapacity: Int): Unit \u003d { underlying.ensureCapacity(newCapacity) }\n\n  /** Returns the Char at the specified index, counting from 0 as in Arrays.\n   *\n   *  @param  index   the index to look up\n   *  @return         the Char at the given index.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def charAt(index: Int): Char \u003d underlying.charAt(index)\n\n  /** Removes the Char at the specified index.  The sequence is\n   *  shortened by one.\n   *\n   *  @param  index  The index to remove.\n   *  @return        This StringBuilder.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def deleteCharAt(index: Int): this.type \u003d {\n    underlying.deleteCharAt(index)\n    this\n  }\n\n  /** Update the sequence at the given index to hold the specified Char.\n   *\n   *  @param  index   the index to modify.\n   *  @param  ch      the new Char.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def setCharAt(index: Int, ch: Char): this.type \u003d {\n    underlying.setCharAt(index, ch)\n    this\n  }\n\n  /** Returns a new String made up of a subsequence of this sequence,\n   *  beginning at the given index and extending to the end of the sequence.\n   *\n   *  target.substring(start)  is equivalent to  target.drop(start)\n   *\n   *  @param  start  The starting index, inclusive.\n   *  @return        The new String.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def substring(start: Int): String \u003d underlying.substring(start, length)\n\n  /** Returns a new String made up of a subsequence of this sequence,\n   *  beginning at the start index (inclusive) and extending to the\n   *  end index (exclusive).\n   *\n   *  target.substring(start, end)  is equivalent to  target.slice(start, end).mkString\n   *\n   *  @param  start  The beginning index, inclusive.\n   *  @param  end    The ending index, exclusive.\n   *  @return The new String.\n   *  @throws StringIndexOutOfBoundsException If either index is out of bounds,\n   *          or if start \u003e end.\n   */\n  def substring(start: Int, end: Int): String \u003d underlying.substring(start, end)\n\n  /** For implementing CharSequence.\n   */\n  def subSequence(start: Int, end: Int): java.lang.CharSequence \u003d\n    underlying.substring(start, end)\n\n  /** Finds the index of the first occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @return             the first applicable index where target occurs, or -1 if not found.\n   */\n  def indexOf(str: String): Int \u003d underlying.indexOf(str)\n\n  /** Finds the index of the first occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @param    fromIndex the smallest index in the source string to consider\n   *  @return             the first applicable index where target occurs, or -1 if not found.\n   */\n  def indexOf(str: String, fromIndex: Int): Int \u003d underlying.indexOf(str, fromIndex)\n\n  /** Finds the index of the last occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @return             the last applicable index where target occurs, or -1 if not found.\n   */\n  def lastIndexOf(str: String): Int \u003d underlying.lastIndexOf(str)\n\n  /** Finds the index of the last occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @param    fromIndex the smallest index in the source string to consider\n   *  @return             the last applicable index where target occurs, or -1 if not found.\n   */\n  def lastIndexOf(str: String, fromIndex: Int): Int \u003d underlying.lastIndexOf(str, fromIndex)\n\n  /** Tests whether this builder is empty.\n   *\n   *  This method is required for JDK15+ compatibility\n   *\n   *  @return  `true` if this builder contains nothing, `false` otherwise.\n   */\n  override def isEmpty: Boolean \u003d underlying.length() \u003d\u003d 0\n}\n\nobject StringBuilder {\n  @deprecated(\"Use `new StringBuilder()` instead of `StringBuilder.newBuilder`\", \"2.13.0\")\n  def newBuilder \u003d new StringBuilder\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 1:18:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/mutable/StringBuilder.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 01:18:44 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 1:18:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/mutable/StringBuilder.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala.collection.mutable\n\nimport scala.collection.{IterableFactoryDefaults, IterableOnce}\nimport scala.collection.immutable.WrappedString\n\nimport scala.Predef.{ // unimport char-related implicit conversions to avoid triggering them accidentally\n  genericArrayOps \u003d\u003e _,\n  charArrayOps \u003d\u003e _,\n  genericWrapArray \u003d\u003e _,\n  wrapCharArray \u003d\u003e _,\n  wrapString \u003d\u003e _,\n //_\n}\n\n/** A builder of `String` which is also a mutable sequence of characters.\n *\n *  This class provides an API mostly compatible with `java.lang.StringBuilder`,\n *  except where there are conflicts with the Scala collections API, such as the `reverse` method:\n *  [[reverse]] produces a new `StringBuilder`, and [[reverseInPlace]] mutates this builder.\n *\n *  Mutating operations return either `this.type`, i.e., the current builder, or `Unit`.\n *\n *  Other methods extract data or information from the builder without mutating it.\n *\n *  The distinction is also reflected in naming conventions used by collections,\n *  such as `append`, which mutates, and `appended`, which does not, or `reverse`,\n *  which does not mutate, and `reverseInPlace`, which does.\n *\n *  The `String` result may be obtained using either `result()` or `toString`.\n *\n *  $multipleResults\n *\n *  @see [[https://docs.scala-lang.org/overviews/collections-2.13/concrete-mutable-collection-classes.html#stringbuilders \"Scala\u0027s Collection Library overview\"]]\n *  section on `StringBuilders` for more information.\n *\n *  @define Coll `mutable.IndexedSeq`\n *  @define coll string builder\n */\n@SerialVersionUID(3L)\nfinal class StringBuilder(val underlying: java.lang.StringBuilder) extends AbstractSeq[Char]\n  with ReusableBuilder[Char, String]\n  with IndexedSeq[Char]\n  with IndexedSeqOps[Char, IndexedSeq, StringBuilder]\n  with IterableFactoryDefaults[Char, IndexedSeq]\n  with java.lang.CharSequence\n  with Serializable {\n\n  def this() \u003d this(new java.lang.StringBuilder)\n\n  /** Constructs a string builder with no characters in it and an\n    *  initial capacity specified by the `capacity` argument.\n    *\n    *  @param  capacity  the initial capacity.\n    *  @throws java.lang.NegativeArraySizeException  if capacity \u003c 0.\n    */\n  def this(capacity: Int) \u003d this(new java.lang.StringBuilder(capacity))\n\n  /** Constructs a string builder with initial characters\n    *  equal to characters of `str`.\n    */\n  def this(str: String) \u003d this(new java.lang.StringBuilder(str))\n\n  /** Constructs a string builder initialized with string value `initValue`\n    *  and with additional character capacity `initCapacity`.\n    */\n  def this(initCapacity: Int, initValue: String) \u003d\n    this(new java.lang.StringBuilder(initValue.length + initCapacity) append initValue)\n\n  // Methods required to make this an IndexedSeq:\n  def apply(i: Int): Char \u003d underlying.charAt(i)\n\n  override protected def fromSpecific(coll: scala.collection.IterableOnce[Char]): StringBuilder \u003d\n    new StringBuilder() appendAll coll\n\n  override protected def newSpecificBuilder: Builder[Char, StringBuilder] \u003d\n    new GrowableBuilder(new StringBuilder())\n\n  override def empty: StringBuilder \u003d new StringBuilder()\n\n  @inline def length: Int \u003d underlying.length\n\n  def length_\u003d(n: Int): Unit \u003d underlying.setLength(n)\n\n  override def knownSize: Int \u003d super[IndexedSeqOps].knownSize\n\n  def addOne(x: Char): this.type \u003d { underlying.append(x); this }\n\n  def clear(): Unit \u003d underlying.setLength(0)\n\n  /** Overloaded version of `addAll` that takes a string */\n  def addAll(s: String): this.type \u003d { underlying.append(s); this }\n\n  /** Alias for `addAll` */\n  def ++\u003d (s: String): this.type \u003d addAll(s)\n\n  def result() \u003d underlying.toString\n\n  override def toString: String \u003d result()\n\n  override def toArray[B \u003e: Char](implicit ct: scala.reflect.ClassTag[B]) \u003d\n    ct.runtimeClass match {\n      case java.lang.Character.TYPE \u003d\u003e toCharArray.asInstanceOf[Array[B]]\n      case _ \u003d\u003e super.toArray\n    }\n\n  /** Returns the contents of this StringBuilder as an `Array[Char]`.\n   *\n   *  @return  An array with the characters from this builder.\n   */\n  def toCharArray: Array[Char] \u003d {\n    val len \u003d underlying.length\n    val arr \u003d new Array[Char](len)\n    underlying.getChars(0, len, arr, 0)\n    arr\n  }\n\n  // append* methods delegate to the underlying java.lang.StringBuilder:\n\n  def appendAll(xs: String): this.type \u003d {\n    underlying append xs\n    this\n  }\n\n  /** Appends the string representation of the given argument,\n    *  which is converted to a String with `String.valueOf`.\n    *\n    *  @param  x   an `Any` object.\n    *  @return     this StringBuilder.\n    */\n  def append(x: Any): this.type \u003d {\n    underlying append String.valueOf(x)\n    this\n  }\n\n  /** Appends the given String to this sequence.\n    *\n    *  @param  s   a String.\n    *  @return     this StringBuilder.\n    */\n  def append(s: String): this.type \u003d {\n    underlying append s\n    this\n  }\n\n  /** Appends the given CharSequence to this sequence.\n    *\n    *  @param  cs   a CharSequence.\n    *  @return     this StringBuilder.\n    */\n  def append(cs: java.lang.CharSequence): this.type \u003d {\n    underlying.append(cs match {\n      // Both cases call into append(\u003cCharSequence\u003e), but java SB\n      // looks up type at runtime and has fast path for SB.\n      case s: StringBuilder \u003d\u003e s.underlying\n      case _                \u003d\u003e cs\n    })\n    this\n  }\n\n  /** Appends the specified string builder to this sequence.\n    *\n    *  @param s\n    *  @return\n    */\n  def append(s: StringBuilder): this.type \u003d {\n    underlying append s.underlying\n    this\n  }\n\n  /** Appends all the Chars in the given IterableOnce[Char] to this sequence.\n    *\n    *  @param  xs  the characters to be appended.\n    *  @return     this StringBuilder.\n    */\n  def appendAll(xs: IterableOnce[Char]): this.type \u003d {\n    xs match {\n      case x: WrappedString \u003d\u003e underlying append x.unwrap\n      case x: ArraySeq.ofChar \u003d\u003e underlying append x.array\n      case x: StringBuilder \u003d\u003e underlying append x.underlying\n      case _ \u003d\u003e\n        val ks \u003d xs.knownSize\n        if (ks !\u003d 0) {\n          val b \u003d underlying\n          if (ks \u003e 0) b.ensureCapacity(b.length + ks)\n          val it \u003d xs.iterator\n          while (it.hasNext) { b append it.next() }\n        }\n    }\n    this\n  }\n\n  /** Appends all the Chars in the given Array[Char] to this sequence.\n    *\n    *  @param  xs  the characters to be appended.\n    *  @return     a reference to this object.\n    */\n  def appendAll(xs: Array[Char]): this.type \u003d {\n    underlying append xs\n    this\n  }\n\n  /** Appends a portion of the given Array[Char] to this sequence.\n    *\n    *  @param  xs      the Array containing Chars to be appended.\n    *  @param  offset  the index of the first Char to append.\n    *  @param  len     the numbers of Chars to append.\n    *  @return         this StringBuilder.\n    */\n  def appendAll(xs: Array[Char], offset: Int, len: Int): this.type \u003d {\n    underlying.append(xs, offset, len)\n    this\n  }\n\n  /** Append the String representation of the given primitive type\n    *  to this sequence.  The argument is converted to a String with\n    *  String.valueOf.\n    *\n    *  @param   x  a primitive value\n    *  @return     This StringBuilder.\n    */\n  def append(x: Boolean): this.type \u003d { underlying append x ; this }\n  def append(x: Byte): this.type \u003d append(x.toInt)\n  def append(x: Short): this.type \u003d append(x.toInt)\n  def append(x: Int): this.type \u003d { underlying append x ; this }\n  def append(x: Long): this.type \u003d { underlying append x ; this }\n  def append(x: Float): this.type \u003d { underlying append x ; this }\n  def append(x: Double): this.type \u003d { underlying append x ; this }\n  def append(x: Char): this.type \u003d { underlying append x ; this }\n\n  /** Remove a subsequence of Chars from this sequence, starting at the\n    *  given start index (inclusive) and extending to the end index (exclusive)\n    *  or to the end of the String, whichever comes first.\n    *\n    *  @param  start  The beginning index, inclusive.\n    *  @param  end    The ending index, exclusive.\n    *  @return        This StringBuilder.\n    *  @throws StringIndexOutOfBoundsException   if start \u003c 0 || start \u003e end\n    */\n  def delete(start: Int, end: Int): this.type \u003d {\n    underlying.delete(start, end)\n    this\n  }\n\n  /** Replaces a subsequence of Chars with the given String.  The semantics\n    *  are as in delete, with the String argument then inserted at index \u0027start\u0027.\n    *\n    *  @param  start  The beginning index, inclusive.\n    *  @param  end    The ending index, exclusive.\n    *  @param  str    The String to be inserted at the start index.\n    *  @return        This StringBuilder.\n    *  @throws StringIndexOutOfBoundsException if start \u003c 0, start \u003e length, or start \u003e end\n    */\n  def replace(start: Int, end: Int, str: String): this.type \u003d {\n    underlying.replace(start, end, str)\n    this\n  }\n\n  /** Inserts a subarray of the given Array[Char] at the given index\n    *  of this sequence.\n    *\n    * @param  index   index at which to insert the subarray.\n    * @param  str     the Array from which Chars will be taken.\n    * @param  offset  the index of the first Char to insert.\n    * @param  len     the number of Chars from \u0027str\u0027 to insert.\n    * @return         This StringBuilder.\n    *\n    * @throws StringIndexOutOfBoundsException  if index \u003c 0, index \u003e length,\n    *         offset \u003c 0, len \u003c 0, or (offset + len) \u003e str.length.\n    */\n  def insertAll(index: Int, str: Array[Char], offset: Int, len: Int): this.type \u003d {\n    underlying.insert(index, str, offset, len)\n    this\n  }\n\n  /** Inserts the String representation (via String.valueOf) of the given\n    *  argument into this sequence at the given index.\n    *\n    *  @param  index   the index at which to insert.\n    *  @param  x       a value.\n    *  @return         this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insert(index: Int, x: Any): this.type \u003d insert(index, String.valueOf(x))\n\n  /** Inserts the String into this character sequence.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  x     a String.\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insert(index: Int, x: String): this.type \u003d {\n    underlying.insert(index, x)\n    this\n  }\n\n  /** Inserts the given Seq[Char] into this sequence at the given index.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  xs    the Seq[Char].\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insertAll(index: Int, xs: IterableOnce[Char]): this.type \u003d\n    insertAll(index, (ArrayBuilder.make[Char] ++\u003d xs).result())\n\n  /** Inserts the given Array[Char] into this sequence at the given index.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  xs    the Array[Char].\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insertAll(index: Int, xs: Array[Char]): this.type \u003d {\n    underlying.insert(index, xs)\n    this\n  }\n\n  /** Calls String.valueOf on the given primitive value, and inserts the\n    *  String at the given index.\n    *\n    *  @param  index the offset position.\n    *  @param  x     a primitive value.\n    *  @return       this StringBuilder.\n    */\n  def insert(index: Int, x: Boolean): this.type \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Byte): this.type    \u003d insert(index, x.toInt)\n  def insert(index: Int, x: Short): this.type   \u003d insert(index, x.toInt)\n  def insert(index: Int, x: Int): this.type     \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Long): this.type    \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Float): this.type   \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Double): this.type  \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Char): this.type    \u003d insert(index, String.valueOf(x))\n\n  /** Sets the length of the character sequence.  If the current sequence\n    *  is shorter than the given length, it is padded with nulls; if it is\n    *  longer, it is truncated.\n    *\n    *  @param  len  the new length\n    *  @throws IndexOutOfBoundsException if the argument is negative.\n    */\n  def setLength(len: Int): Unit \u003d underlying.setLength(len)\n\n  def update(idx: Int, elem: Char): Unit \u003d underlying.setCharAt(idx, elem)\n\n\n  /** Like reverse, but destructively updates the target StringBuilder.\n   *\n   *  @return   the reversed StringBuilder (same as the target StringBuilder)\n   */\n  @deprecated(\"Use reverseInPlace instead\", \"2.13.0\")\n  final def reverseContents(): this.type \u003d reverseInPlace()\n\n  /** Like reverse, but destructively updates the target StringBuilder.\n   *\n   *  @return   the reversed StringBuilder (same as the target StringBuilder)\n   */\n  def reverseInPlace(): this.type \u003d {\n    underlying.reverse()\n    this\n  }\n\n\n  /** Returns the current capacity, which is the size of the underlying array.\n   *  A new array will be allocated if the current capacity is exceeded.\n   *\n   *  @return  the capacity\n   */\n  def capacity: Int \u003d underlying.capacity\n\n  /** Ensure that the capacity is at least the given argument.\n   *  If the argument is greater than the current capacity, new\n   *  storage will be allocated with size equal to the given\n   *  argument or to `(2 * capacity + 2)`, whichever is larger.\n   *\n   *  @param newCapacity    the minimum desired capacity.\n   */\n  def ensureCapacity(newCapacity: Int): Unit \u003d { underlying.ensureCapacity(newCapacity) }\n\n  /** Returns the Char at the specified index, counting from 0 as in Arrays.\n   *\n   *  @param  index   the index to look up\n   *  @return         the Char at the given index.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def charAt(index: Int): Char \u003d underlying.charAt(index)\n\n  /** Removes the Char at the specified index.  The sequence is\n   *  shortened by one.\n   *\n   *  @param  index  The index to remove.\n   *  @return        This StringBuilder.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def deleteCharAt(index: Int): this.type \u003d {\n    underlying.deleteCharAt(index)\n    this\n  }\n\n  /** Update the sequence at the given index to hold the specified Char.\n   *\n   *  @param  index   the index to modify.\n   *  @param  ch      the new Char.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def setCharAt(index: Int, ch: Char): this.type \u003d {\n    underlying.setCharAt(index, ch)\n    this\n  }\n\n  /** Returns a new String made up of a subsequence of this sequence,\n   *  beginning at the given index and extending to the end of the sequence.\n   *\n   *  target.substring(start)  is equivalent to  target.drop(start)\n   *\n   *  @param  start  The starting index, inclusive.\n   *  @return        The new String.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def substring(start: Int): String \u003d underlying.substring(start, length)\n\n  /** Returns a new String made up of a subsequence of this sequence,\n   *  beginning at the start index (inclusive) and extending to the\n   *  end index (exclusive).\n   *\n   *  target.substring(start, end)  is equivalent to  target.slice(start, end).mkString\n   *\n   *  @param  start  The beginning index, inclusive.\n   *  @param  end    The ending index, exclusive.\n   *  @return The new String.\n   *  @throws StringIndexOutOfBoundsException If either index is out of bounds,\n   *          or if start \u003e end.\n   */\n  def substring(start: Int, end: Int): String \u003d underlying.substring(start, end)\n\n  /** For implementing CharSequence.\n   */\n  def subSequence(start: Int, end: Int): java.lang.CharSequence \u003d\n    underlying.substring(start, end)\n\n  /** Finds the index of the first occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @return             the first applicable index where target occurs, or -1 if not found.\n   */\n  def indexOf(str: String): Int \u003d underlying.indexOf(str)\n\n  /** Finds the index of the first occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @param    fromIndex the smallest index in the source string to consider\n   *  @return             the first applicable index where target occurs, or -1 if not found.\n   */\n  def indexOf(str: String, fromIndex: Int): Int \u003d underlying.indexOf(str, fromIndex)\n\n  /** Finds the index of the last occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @return             the last applicable index where target occurs, or -1 if not found.\n   */\n  def lastIndexOf(str: String): Int \u003d underlying.lastIndexOf(str)\n\n  /** Finds the index of the last occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @param    fromIndex the smallest index in the source string to consider\n   *  @return             the last applicable index where target occurs, or -1 if not found.\n   */\n  def lastIndexOf(str: String, fromIndex: Int): Int \u003d underlying.lastIndexOf(str, fromIndex)\n\n  /** Tests whether this builder is empty.\n   *\n   *  This method is required for JDK15+ compatibility\n   *\n   *  @return  `true` if this builder contains nothing, `false` otherwise.\n   */\n  override def isEmpty: Boolean \u003d underlying.length() \u003d\u003d 0\n}\n\nobject StringBuilder {\n  @deprecated(\"Use `new StringBuilder()` instead of `StringBuilder.newBuilder`\", \"2.13.0\")\n  def newBuilder \u003d new StringBuilder\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 01:18:45 INFO  compiling root (2 scala sources)
2024.04.26 01:18:45 INFO  time: compiled root in 0.15s
Apr. 26, 2024 1:19:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 1:19:59 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 11464
2024.04.26 01:20:01 INFO  compiling root (2 scala sources)
2024.04.26 01:20:01 INFO  time: compiled root in 0.15s
2024.04.26 01:20:41 INFO  compiling root (2 scala sources)
2024.04.26 01:20:41 INFO  time: compiled root in 0.16s
2024.04.26 01:20:53 INFO  compiling root (2 scala sources)
2024.04.26 01:20:53 INFO  time: compiled root in 0.14s
2024.04.26 01:21:35 INFO  compiling root (2 scala sources)
2024.04.26 01:21:35 INFO  time: compiled root in 0.22s
Apr. 26, 2024 1:21:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/mutable/StringBuilder.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 01:23:19 INFO  compiling root (2 scala sources)
2024.04.26 01:23:19 INFO  time: compiled root in 0.14s
2024.04.26 01:23:22 INFO  compiling root (2 scala sources)
2024.04.26 01:23:22 INFO  time: compiled root in 0.15s
2024.04.26 01:23:44 INFO  compiling root (2 scala sources)
2024.04.26 01:23:44 INFO  time: compiled root in 0.13s
2024.04.26 01:24:05 INFO  compiling root (2 scala sources)
2024.04.26 01:24:05 INFO  time: compiled root in 0.14s
2024.04.26 01:24:56 INFO  compiling root (2 scala sources)
2024.04.26 01:24:56 INFO  time: compiled root in 0.16s
2024.04.26 01:26:09 INFO  compiling root (2 scala sources)
2024.04.26 01:26:09 INFO  time: compiled root in 0.15s
2024.04.26 01:26:34 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 1:26:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Option.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nobject Option {\n\n  import scala.language.implicitConversions\n\n  /** An implicit conversion that converts an option to an iterable value */\n  implicit def option2Iterable[A](xo: Option[A]): Iterable[A] \u003d\n    if (xo.isEmpty) Iterable.empty else Iterable.single(xo.get)\n\n  /** An Option factory which creates Some(x) if the argument is not null,\n   *  and None if it is null.\n   *\n   *  @param  x the value\n   *  @return   Some(value) if value !\u003d null, None if value \u003d\u003d null\n   */\n  def apply[A](x: A): Option[A] \u003d if (x \u003d\u003d null) None else Some(x)\n\n  /** An Option factory which returns `None` in a manner consistent with\n   *  the collections hierarchy.\n   */\n  def empty[A] : Option[A] \u003d None\n\n  /** When a given condition is true, evaluates the `a` argument and returns\n   *  Some(a). When the condition is false, `a` is not evaluated and None is\n   *  returned.\n   */\n  def when[A](cond: Boolean)(a: \u003d\u003e A): Option[A] \u003d\n    if (cond) Some(a) else None\n\n  /** Unless a given condition is true, this will evaluate the `a` argument and\n   *  return Some(a). Otherwise, `a` is not evaluated and None is returned.\n   */\n  @inline def unless[A](cond: Boolean)(a: \u003d\u003e A): Option[A] \u003d\n    when(!cond)(a)\n}\n\n/** Represents optional values. Instances of `Option`\n *  are either an instance of $some or the object $none.\n *\n *  The most idiomatic way to use an $option instance is to treat it\n *  as a collection or monad and use `map`,`flatMap`, `filter`, or\n *  `foreach`:\n *\n *  {{{\n *  val name: Option[String] \u003d request getParameter \"name\"\n *  val upper \u003d name map { _.trim } filter { _.length !\u003d 0 } map { _.toUpperCase }\n *  println(upper getOrElse \"\")\n *  }}}\n *\n *  Note that this is equivalent to {{{\n *  val upper \u003d for {\n *    name \u003c- request getParameter \"name\"\n *    trimmed \u003c- Some(name.trim)\n *    upper \u003c- Some(trimmed.toUpperCase) if trimmed.length !\u003d 0\n *  } yield upper\n *  println(upper getOrElse \"\")\n *  }}}\n *\n *  Because of how for comprehension works, if $none is returned\n *  from `request.getParameter`, the entire expression results in\n *  $none\n *\n *  This allows for sophisticated chaining of $option values without\n *  having to check for the existence of a value.\n *\n * These are useful methods that exist for both $some and $none.\n *  - [[isDefined]] — True if not empty\n *  - [[isEmpty]] — True if empty\n *  - [[nonEmpty]] — True if not empty\n *  - [[orElse]] — Evaluate and return alternate optional value if empty\n *  - [[getOrElse]] — Evaluate and return alternate value if empty\n *  - [[get]] — Return value, throw exception if empty\n *  - [[fold]] —  Apply function on optional value, return default if empty\n *  - [[map]] — Apply a function on the optional value\n *  - [[flatMap]] — Same as map but function must return an optional value\n *  - [[foreach]] — Apply a procedure on option value\n *  - [[collect]] — Apply partial pattern match on optional value\n *  - [[filter]] — An optional value satisfies predicate\n *  - [[filterNot]] — An optional value doesn\u0027t satisfy predicate\n *  - [[exists]] — Apply predicate on optional value, or false if empty\n *  - [[forall]] — Apply predicate on optional value, or true if empty\n *  - [[contains]] — Checks if value equals optional value, or false if empty\n *  - [[zip]] — Combine two optional values to make a paired optional value\n *  - [[unzip]] — Split an optional pair to two optional values\n *  - [[unzip3]] — Split an optional triple to three optional values\n *  - [[toList]] — Unary list of optional value, otherwise the empty list\n *\n *  A less-idiomatic way to use $option values is via pattern matching: {{{\n *  val nameMaybe \u003d request getParameter \"name\"\n *  nameMaybe match {\n *    case Some(name) \u003d\u003e\n *      println(name.trim.toUppercase)\n *    case None \u003d\u003e\n *      println(\"No name value\")\n *  }\n *  }}}\n *\n * Interacting with code that can occasionally return null can be\n * safely wrapped in $option to become $none and $some otherwise. {{{\n * val abc \u003d new java.util.HashMap[Int, String]\n * abc.put(1, \"A\")\n * bMaybe \u003d Option(abc.get(2))\n * bMaybe match {\n *   case Some(b) \u003d\u003e\n *     println(s\"Found \\$b\")\n *   case None \u003d\u003e\n *     println(\"Not found\")\n * }\n * }}}\n *\n *  @note Many of the methods in here are duplicative with those\n *  in the Iterable hierarchy, but they are duplicated for a reason:\n *  the implicit conversion tends to leave one with an Iterable in\n *  situations where one could have retained an Option.\n *\n *  @define none `None`\n *  @define some [[scala.Some]]\n *  @define option [[scala.Option]]\n *  @define p `p`\n *  @define f `f`\n *  @define coll option\n *  @define Coll `Option`\n *  @define orderDependent\n *  @define orderDependentFold\n *  @define mayNotTerminateInf\n *  @define willNotTerminateInf\n *  @define collectExample\n *  @define undefinedorder\n */\n@SerialVersionUID(-114498752079829388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nsealed abstract class Option[+A] extends IterableOnce[A] with Product with Serializable {\n  self \u003d\u003e\n\n  /** Returns true if the option is $none, false otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e false\n   *   case None    \u003d\u003e true\n   * }\n   * }}}\n   */\n  final def isEmpty: Boolean \u003d this eq None\n\n  /** Returns true if the option is an instance of $some, false otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e true\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   */\n  final def isDefined: Boolean \u003d !isEmpty\n\n  override final def knownSize: Int \u003d if (isEmpty) 0 else 1\n\n  /** Returns the option\u0027s value.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e throw new Exception\n   * }\n   * }}}\n   *  @note The option must be nonempty.\n   *  @throws NoSuchElementException if the option is empty.\n   */\n  def get: A\n\n  /** Returns the option\u0027s value if the option is nonempty, otherwise\n   * return the result of evaluating `default`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e default\n   * }\n   * }}}\n   *\n   *  @param default  the default expression.\n   */\n  @inline final def getOrElse[B \u003e: A](default: \u003d\u003e B): B \u003d\n    if (isEmpty) default else this.get\n\n  /** Returns the option\u0027s value if it is nonempty,\n   * or `null` if it is empty.\n   *\n   * Although the use of null is discouraged, code written to use\n   * $option must often interface with code that expects and returns nulls.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e null\n   * }\n   * }}}\n   * @example {{{\n   * val initialText: Option[String] \u003d getInitialText\n   * val textField \u003d new JComponent(initialText.orNull,20)\n   * }}}\n   */\n  @inline final def orNull[A1 \u003e: A](implicit ev: Null \u003c:\u003c A1): A1 \u003d this getOrElse ev(null)\n\n  /** Returns a $some containing the result of applying $f to this $option\u0027s\n   * value if this $option is nonempty.\n   * Otherwise return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Some(f(x))\n   *   case None    \u003d\u003e None\n   * }\n   * }}}\n   *  @note This is similar to `flatMap` except here,\n   *  $f does not need to wrap its result in an $option.\n   *\n   *  @param  f   the function to apply\n   *  @see flatMap\n   *  @see foreach\n   */\n  @inline final def map[B](f: A \u003d\u003e B): Option[B] \u003d\n    if (isEmpty) None else Some(f(this.get))\n\n  /** Returns the result of applying $f to this $option\u0027s\n   *  value if the $option is nonempty.  Otherwise, evaluates\n   *  expression `ifEmpty`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e ifEmpty\n   * }\n   * }}}\n   * This is also equivalent to:\n   * {{{\n   * option map f getOrElse ifEmpty\n   * }}}\n   *  @param  ifEmpty the expression to evaluate if empty.\n   *  @param  f       the function to apply if nonempty.\n   */\n  @inline final def fold[B](ifEmpty: \u003d\u003e B)(f: A \u003d\u003e B): B \u003d\n    if (isEmpty) ifEmpty else f(this.get)\n\n  /** Returns the result of applying $f to this $option\u0027s value if\n   * this $option is nonempty.\n   * Returns $none if this $option is empty.\n   * Slightly different from `map` in that $f is expected to\n   * return an $option (which could be $none).\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e None\n   * }\n   * }}}\n   *  @param  f   the function to apply\n   *  @see map\n   *  @see foreach\n   */\n  @inline final def flatMap[B](f: A \u003d\u003e Option[B]): Option[B] \u003d\n    if (isEmpty) None else f(this.get)\n\n  /** Returns the nested $option value if it is nonempty.  Otherwise,\n   * return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(Some(b)) \u003d\u003e Some(b)\n   *   case _             \u003d\u003e None\n   * }\n   * }}}\n   * @example {{{\n   * Some(Some(\"something\")).flatten\n   * }}}\n   *\n   * @param ev an implicit conversion that asserts that the value is\n   *           also an $option.\n   * @see flatMap\n   */\n  def flatten[B](implicit ev: A \u003c:\u003c Option[B]): Option[B] \u003d\n    if (isEmpty) None else ev(this.get)\n\n  /** Returns this $option if it is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 applying the predicate $p to\n   * this $option\u0027s value returns true. Otherwise, return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) if p(x) \u003d\u003e Some(x)\n   *   case _               \u003d\u003e None\n   * }\n   * }}}\n   *  @param  p   the predicate used for testing.\n   */\n  @inline final def filter(p: A \u003d\u003e Boolean): Option[A] \u003d\n    if (isEmpty || p(this.get)) this else None\n\n  /** Returns this $option if it is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 applying the predicate $p to\n   * this $option\u0027s value returns false. Otherwise, return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) if !p(x) \u003d\u003e Some(x)\n   *   case _                \u003d\u003e None\n   * }\n   * }}}\n   *  @param  p   the predicate used for testing.\n   */\n  @inline final def filterNot(p: A \u003d\u003e Boolean): Option[A] \u003d\n    if (isEmpty || !p(this.get)) this else None\n\n  /** Returns false if the option is $none, true otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e true\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @note   Implemented here to avoid the implicit conversion to Iterable.\n   */\n  final def nonEmpty: Boolean \u003d isDefined\n\n  /** Necessary to keep $option from being implicitly converted to\n   *  [[scala.collection.Iterable]] in `for` comprehensions.\n   */\n  @inline final def withFilter(p: A \u003d\u003e Boolean): WithFilter \u003d new WithFilter(p)\n\n  /** We need a whole WithFilter class to honor the \"doesn\u0027t create a new\n   *  collection\" contract even though it seems unlikely to matter much in a\n   *  collection with max size 1.\n   */\n  class WithFilter(p: A \u003d\u003e Boolean) {\n    def map[B](f: A \u003d\u003e B): Option[B] \u003d self filter p map f\n    def flatMap[B](f: A \u003d\u003e Option[B]): Option[B] \u003d self filter p flatMap f\n    def foreach[U](f: A \u003d\u003e U): Unit \u003d self filter p foreach f\n    def withFilter(q: A \u003d\u003e Boolean): WithFilter \u003d new WithFilter(x \u003d\u003e p(x) \u0026\u0026 q(x))\n  }\n\n  /** Tests whether the option contains a given value as an element.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x \u003d\u003d elem\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @example {{{\n   *  // Returns true because Some instance contains string \"something\" which equals \"something\".\n   *  Some(\"something\") contains \"something\"\n   *\n   *  // Returns false because \"something\" !\u003d \"anything\".\n   *  Some(\"something\") contains \"anything\"\n   *\n   *  // Returns false when method called on None.\n   *  None contains \"anything\"\n   *  }}}\n   *\n   *  @param elem the element to test.\n   *  @return `true` if the option has an element that is equal (as\n   *  determined by `\u003d\u003d`) to `elem`, `false` otherwise.\n   */\n  final def contains[A1 \u003e: A](elem: A1): Boolean \u003d\n    !isEmpty \u0026\u0026 this.get \u003d\u003d elem\n\n  /** Returns true if this option is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 the predicate\n   * $p returns true when applied to this $option\u0027s value.\n   * Otherwise, returns false.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e p(x)\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @param  p   the predicate to test\n   */\n  @inline final def exists(p: A \u003d\u003e Boolean): Boolean \u003d\n    !isEmpty \u0026\u0026 p(this.get)\n\n  /** Returns true if this option is empty \u0027\u0027\u0027or\u0027\u0027\u0027 the predicate\n   * $p returns true when applied to this $option\u0027s value.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e p(x)\n   *   case None    \u003d\u003e true\n   * }\n   * }}}\n   *  @param  p   the predicate to test\n   */\n  @inline final def forall(p: A \u003d\u003e Boolean): Boolean \u003d isEmpty || p(this.get)\n\n  /** Apply the given procedure $f to the option\u0027s value,\n   *  if it is nonempty. Otherwise, do nothing.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e ()\n   * }\n   * }}}\n   *  @param  f   the procedure to apply.\n   *  @see map\n   *  @see flatMap\n   */\n  @inline final def foreach[U](f: A \u003d\u003e U): Unit \u003d {\n    if (!isEmpty) f(this.get)\n  }\n\n  /** Returns a $some containing the result of\n   * applying `pf` to this $option\u0027s contained\n   * value, \u0027\u0027\u0027if\u0027\u0027\u0027 this option is\n   * nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 `pf` is defined for that value.\n   * Returns $none otherwise.\n   *\n   *  @example {{{\n   *  // Returns Some(HTTP) because the partial function covers the case.\n   *  Some(\"http\") collect {case \"http\" \u003d\u003e \"HTTP\"}\n   *\n   *  // Returns None because the partial function doesn\u0027t cover the case.\n   *  Some(\"ftp\") collect {case \"http\" \u003d\u003e \"HTTP\"}\n   *\n   *  // Returns None because the option is empty. There is no value to pass to the partial function.\n   *  None collect {case value \u003d\u003e value}\n   *  }}}\n   *\n   *  @param  pf   the partial function.\n   *  @return the result of applying `pf` to this $option\u0027s\n   *  value (if possible), or $none.\n   */\n  @inline final def collect[B](pf: PartialFunction[A, B]): Option[B] \u003d\n    if (!isEmpty) pf.lift(this.get) else None\n\n  /** Returns this $option if it is nonempty,\n   *  otherwise return the result of evaluating `alternative`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Some(x)\n   *   case None    \u003d\u003e alternative\n   * }\n   * }}}\n   *  @param alternative the alternative expression.\n   */\n  @inline final def orElse[B \u003e: A](alternative: \u003d\u003e Option[B]): Option[B] \u003d\n    if (isEmpty) alternative else this\n\n  /** Returns a $some formed from this option and another option\n   *  by combining the corresponding elements in a pair.\n   *  If either of the two options is empty, $none is returned.\n   *\n   *  This is equivalent to:\n   *  {{{\n   *  (option1, option2) match {\n   *    case (Some(x), Some(y)) \u003d\u003e Some((x, y))\n   *    case _                  \u003d\u003e None\n   *  }\n   *  }}}\n   *  @example {{{\n   *  // Returns Some((\"foo\", \"bar\")) because both options are nonempty.\n   *  Some(\"foo\") zip Some(\"bar\")\n   *\n   *  // Returns None because `that` option is empty.\n   *  Some(\"foo\") zip None\n   *\n   *  // Returns None because `this` option is empty.\n   *  None zip Some(\"bar\")\n   *  }}}\n   *\n   *  @param  that   the options which is going to be zipped\n   */\n  final def zip[A1 \u003e: A, B](that: Option[B]): Option[(A1, B)] \u003d\n    if (isEmpty || that.isEmpty) None else Some((this.get, that.get))\n\n  /** Converts an Option of a pair into an Option of the first element and an Option of the second element.\n    *\n    *  This is equivalent to:\n    *  {{{\n    *  option match {\n    *    case Some((x, y)) \u003d\u003e (Some(x), Some(y))\n    *    case _            \u003d\u003e (None,    None)\n    *  }\n    *  }}}\n    *  @tparam A1    the type of the first half of the element pair\n    *  @tparam A2    the type of the second half of the element pair\n    *  @param asPair an implicit conversion which asserts that the element type\n    *                of this Option is a pair.\n    *  @return       a pair of Options, containing, respectively, the first and second half\n    *                of the element pair of this Option.\n    */\n  final def unzip[A1, A2](implicit asPair: A \u003c:\u003c (A1, A2)): (Option[A1], Option[A2]) \u003d {\n    if (isEmpty)\n      (None, None)\n    else {\n      val e \u003d asPair(this.get)\n      (Some(e._1), Some(e._2))\n    }\n  }\n\n  /** Converts an Option of a triple into three Options, one containing the element from each position of the triple.\n    *\n    *  This is equivalent to:\n    *  {{{\n    *  option match {\n    *    case Some((x, y, z)) \u003d\u003e (Some(x), Some(y), Some(z))\n    *    case _               \u003d\u003e (None,    None,    None)\n    *  }\n    *  }}}\n    *  @tparam A1      the type of the first of three elements in the triple\n    *  @tparam A2      the type of the second of three elements in the triple\n    *  @tparam A3      the type of the third of three elements in the triple\n    *  @param asTriple an implicit conversion which asserts that the element type\n    *                  of this Option is a triple.\n    *  @return         a triple of Options, containing, respectively, the first, second, and third\n    *                  elements from the element triple of this Option.\n    */\n  final def unzip3[A1, A2, A3](implicit asTriple: A \u003c:\u003c (A1, A2, A3)): (Option[A1], Option[A2], Option[A3]) \u003d {\n    if (isEmpty)\n      (None, None, None)\n    else {\n      val e \u003d asTriple(this.get)\n      (Some(e._1), Some(e._2), Some(e._3))\n    }\n  }\n\n  /** Returns a singleton iterator returning the $option\u0027s value\n   * if it is nonempty, or an empty iterator if the option is empty.\n   */\n  def iterator: Iterator[A] \u003d\n    if (isEmpty) collection.Iterator.empty else collection.Iterator.single(this.get)\n\n  /** Returns a singleton list containing the $option\u0027s value\n   * if it is nonempty, or the empty list if the $option is empty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e List(x)\n   *   case None    \u003d\u003e Nil\n   * }\n   * }}}\n   */\n  def toList: List[A] \u003d\n    if (isEmpty) List() else new ::(this.get, Nil)\n\n  /** Returns a [[scala.util.Left]] containing the given\n   * argument `left` if this $option is empty, or\n   * a [[scala.util.Right]] containing this $option\u0027s value if\n   * this is nonempty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Right(x)\n   *   case None    \u003d\u003e Left(left)\n   * }\n   * }}}\n   * @param left the expression to evaluate and return if this is empty\n   * @see toLeft\n   */\n  @inline final def toRight[X](left: \u003d\u003e X): Either[X, A] \u003d\n    if (isEmpty) Left(left) else Right(this.get)\n\n  /** Returns a [[scala.util.Right]] containing the given\n   * argument `right` if this is empty, or\n   * a [[scala.util.Left]] containing this $option\u0027s value\n   * if this $option is nonempty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Left(x)\n   *   case None    \u003d\u003e Right(right)\n   * }\n   * }}}\n   * @param right the expression to evaluate and return if this is empty\n   * @see toRight\n   */\n  @inline final def toLeft[X](right: \u003d\u003e X): Either[A, X] \u003d\n    if (isEmpty) Right(right) else Left(this.get)\n}\n\n/** Class `Some[A]` represents existing values of type\n *  `A`.\n */\n@SerialVersionUID(1234815782226070388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nfinal case class Some[+A](value: A) extends Option[A] {\n  def get: A \u003d value\n}\n\n\n/** This case object represents non-existent values.\n */\n@SerialVersionUID(5066590221178148012L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\ncase object None extends Option[Nothing] {\n  def get: Nothing \u003d throw new NoSuchElementException(\"None.get\")\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 1:26:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Option.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 01:26:34 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 1:26:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Option.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nobject Option {\n\n  import scala.language.implicitConversions\n\n  /** An implicit conversion that converts an option to an iterable value */\n  implicit def option2Iterable[A](xo: Option[A]): Iterable[A] \u003d\n    if (xo.isEmpty) Iterable.empty else Iterable.single(xo.get)\n\n  /** An Option factory which creates Some(x) if the argument is not null,\n   *  and None if it is null.\n   *\n   *  @param  x the value\n   *  @return   Some(value) if value !\u003d null, None if value \u003d\u003d null\n   */\n  def apply[A](x: A): Option[A] \u003d if (x \u003d\u003d null) None else Some(x)\n\n  /** An Option factory which returns `None` in a manner consistent with\n   *  the collections hierarchy.\n   */\n  def empty[A] : Option[A] \u003d None\n\n  /** When a given condition is true, evaluates the `a` argument and returns\n   *  Some(a). When the condition is false, `a` is not evaluated and None is\n   *  returned.\n   */\n  def when[A](cond: Boolean)(a: \u003d\u003e A): Option[A] \u003d\n    if (cond) Some(a) else None\n\n  /** Unless a given condition is true, this will evaluate the `a` argument and\n   *  return Some(a). Otherwise, `a` is not evaluated and None is returned.\n   */\n  @inline def unless[A](cond: Boolean)(a: \u003d\u003e A): Option[A] \u003d\n    when(!cond)(a)\n}\n\n/** Represents optional values. Instances of `Option`\n *  are either an instance of $some or the object $none.\n *\n *  The most idiomatic way to use an $option instance is to treat it\n *  as a collection or monad and use `map`,`flatMap`, `filter`, or\n *  `foreach`:\n *\n *  {{{\n *  val name: Option[String] \u003d request getParameter \"name\"\n *  val upper \u003d name map { _.trim } filter { _.length !\u003d 0 } map { _.toUpperCase }\n *  println(upper getOrElse \"\")\n *  }}}\n *\n *  Note that this is equivalent to {{{\n *  val upper \u003d for {\n *    name \u003c- request getParameter \"name\"\n *    trimmed \u003c- Some(name.trim)\n *    upper \u003c- Some(trimmed.toUpperCase) if trimmed.length !\u003d 0\n *  } yield upper\n *  println(upper getOrElse \"\")\n *  }}}\n *\n *  Because of how for comprehension works, if $none is returned\n *  from `request.getParameter`, the entire expression results in\n *  $none\n *\n *  This allows for sophisticated chaining of $option values without\n *  having to check for the existence of a value.\n *\n * These are useful methods that exist for both $some and $none.\n *  - [[isDefined]] — True if not empty\n *  - [[isEmpty]] — True if empty\n *  - [[nonEmpty]] — True if not empty\n *  - [[orElse]] — Evaluate and return alternate optional value if empty\n *  - [[getOrElse]] — Evaluate and return alternate value if empty\n *  - [[get]] — Return value, throw exception if empty\n *  - [[fold]] —  Apply function on optional value, return default if empty\n *  - [[map]] — Apply a function on the optional value\n *  - [[flatMap]] — Same as map but function must return an optional value\n *  - [[foreach]] — Apply a procedure on option value\n *  - [[collect]] — Apply partial pattern match on optional value\n *  - [[filter]] — An optional value satisfies predicate\n *  - [[filterNot]] — An optional value doesn\u0027t satisfy predicate\n *  - [[exists]] — Apply predicate on optional value, or false if empty\n *  - [[forall]] — Apply predicate on optional value, or true if empty\n *  - [[contains]] — Checks if value equals optional value, or false if empty\n *  - [[zip]] — Combine two optional values to make a paired optional value\n *  - [[unzip]] — Split an optional pair to two optional values\n *  - [[unzip3]] — Split an optional triple to three optional values\n *  - [[toList]] — Unary list of optional value, otherwise the empty list\n *\n *  A less-idiomatic way to use $option values is via pattern matching: {{{\n *  val nameMaybe \u003d request getParameter \"name\"\n *  nameMaybe match {\n *    case Some(name) \u003d\u003e\n *      println(name.trim.toUppercase)\n *    case None \u003d\u003e\n *      println(\"No name value\")\n *  }\n *  }}}\n *\n * Interacting with code that can occasionally return null can be\n * safely wrapped in $option to become $none and $some otherwise. {{{\n * val abc \u003d new java.util.HashMap[Int, String]\n * abc.put(1, \"A\")\n * bMaybe \u003d Option(abc.get(2))\n * bMaybe match {\n *   case Some(b) \u003d\u003e\n *     println(s\"Found \\$b\")\n *   case None \u003d\u003e\n *     println(\"Not found\")\n * }\n * }}}\n *\n *  @note Many of the methods in here are duplicative with those\n *  in the Iterable hierarchy, but they are duplicated for a reason:\n *  the implicit conversion tends to leave one with an Iterable in\n *  situations where one could have retained an Option.\n *\n *  @define none `None`\n *  @define some [[scala.Some]]\n *  @define option [[scala.Option]]\n *  @define p `p`\n *  @define f `f`\n *  @define coll option\n *  @define Coll `Option`\n *  @define orderDependent\n *  @define orderDependentFold\n *  @define mayNotTerminateInf\n *  @define willNotTerminateInf\n *  @define collectExample\n *  @define undefinedorder\n */\n@SerialVersionUID(-114498752079829388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nsealed abstract class Option[+A] extends IterableOnce[A] with Product with Serializable {\n  self \u003d\u003e\n\n  /** Returns true if the option is $none, false otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e false\n   *   case None    \u003d\u003e true\n   * }\n   * }}}\n   */\n  final def isEmpty: Boolean \u003d this eq None\n\n  /** Returns true if the option is an instance of $some, false otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e true\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   */\n  final def isDefined: Boolean \u003d !isEmpty\n\n  override final def knownSize: Int \u003d if (isEmpty) 0 else 1\n\n  /** Returns the option\u0027s value.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e throw new Exception\n   * }\n   * }}}\n   *  @note The option must be nonempty.\n   *  @throws NoSuchElementException if the option is empty.\n   */\n  def get: A\n\n  /** Returns the option\u0027s value if the option is nonempty, otherwise\n   * return the result of evaluating `default`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e default\n   * }\n   * }}}\n   *\n   *  @param default  the default expression.\n   */\n  @inline final def getOrElse[B \u003e: A](default: \u003d\u003e B): B \u003d\n    if (isEmpty) default else this.get\n\n  /** Returns the option\u0027s value if it is nonempty,\n   * or `null` if it is empty.\n   *\n   * Although the use of null is discouraged, code written to use\n   * $option must often interface with code that expects and returns nulls.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e null\n   * }\n   * }}}\n   * @example {{{\n   * val initialText: Option[String] \u003d getInitialText\n   * val textField \u003d new JComponent(initialText.orNull,20)\n   * }}}\n   */\n  @inline final def orNull[A1 \u003e: A](implicit ev: Null \u003c:\u003c A1): A1 \u003d this getOrElse ev(null)\n\n  /** Returns a $some containing the result of applying $f to this $option\u0027s\n   * value if this $option is nonempty.\n   * Otherwise return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Some(f(x))\n   *   case None    \u003d\u003e None\n   * }\n   * }}}\n   *  @note This is similar to `flatMap` except here,\n   *  $f does not need to wrap its result in an $option.\n   *\n   *  @param  f   the function to apply\n   *  @see flatMap\n   *  @see foreach\n   */\n  @inline final def map[B](f: A \u003d\u003e B): Option[B] \u003d\n    if (isEmpty) None else Some(f(this.get))\n\n  /** Returns the result of applying $f to this $option\u0027s\n   *  value if the $option is nonempty.  Otherwise, evaluates\n   *  expression `ifEmpty`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e ifEmpty\n   * }\n   * }}}\n   * This is also equivalent to:\n   * {{{\n   * option map f getOrElse ifEmpty\n   * }}}\n   *  @param  ifEmpty the expression to evaluate if empty.\n   *  @param  f       the function to apply if nonempty.\n   */\n  @inline final def fold[B](ifEmpty: \u003d\u003e B)(f: A \u003d\u003e B): B \u003d\n    if (isEmpty) ifEmpty else f(this.get)\n\n  /** Returns the result of applying $f to this $option\u0027s value if\n   * this $option is nonempty.\n   * Returns $none if this $option is empty.\n   * Slightly different from `map` in that $f is expected to\n   * return an $option (which could be $none).\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e None\n   * }\n   * }}}\n   *  @param  f   the function to apply\n   *  @see map\n   *  @see foreach\n   */\n  @inline final def flatMap[B](f: A \u003d\u003e Option[B]): Option[B] \u003d\n    if (isEmpty) None else f(this.get)\n\n  /** Returns the nested $option value if it is nonempty.  Otherwise,\n   * return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(Some(b)) \u003d\u003e Some(b)\n   *   case _             \u003d\u003e None\n   * }\n   * }}}\n   * @example {{{\n   * Some(Some(\"something\")).flatten\n   * }}}\n   *\n   * @param ev an implicit conversion that asserts that the value is\n   *           also an $option.\n   * @see flatMap\n   */\n  def flatten[B](implicit ev: A \u003c:\u003c Option[B]): Option[B] \u003d\n    if (isEmpty) None else ev(this.get)\n\n  /** Returns this $option if it is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 applying the predicate $p to\n   * this $option\u0027s value returns true. Otherwise, return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) if p(x) \u003d\u003e Some(x)\n   *   case _               \u003d\u003e None\n   * }\n   * }}}\n   *  @param  p   the predicate used for testing.\n   */\n  @inline final def filter(p: A \u003d\u003e Boolean): Option[A] \u003d\n    if (isEmpty || p(this.get)) this else None\n\n  /** Returns this $option if it is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 applying the predicate $p to\n   * this $option\u0027s value returns false. Otherwise, return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) if !p(x) \u003d\u003e Some(x)\n   *   case _                \u003d\u003e None\n   * }\n   * }}}\n   *  @param  p   the predicate used for testing.\n   */\n  @inline final def filterNot(p: A \u003d\u003e Boolean): Option[A] \u003d\n    if (isEmpty || !p(this.get)) this else None\n\n  /** Returns false if the option is $none, true otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e true\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @note   Implemented here to avoid the implicit conversion to Iterable.\n   */\n  final def nonEmpty: Boolean \u003d isDefined\n\n  /** Necessary to keep $option from being implicitly converted to\n   *  [[scala.collection.Iterable]] in `for` comprehensions.\n   */\n  @inline final def withFilter(p: A \u003d\u003e Boolean): WithFilter \u003d new WithFilter(p)\n\n  /** We need a whole WithFilter class to honor the \"doesn\u0027t create a new\n   *  collection\" contract even though it seems unlikely to matter much in a\n   *  collection with max size 1.\n   */\n  class WithFilter(p: A \u003d\u003e Boolean) {\n    def map[B](f: A \u003d\u003e B): Option[B] \u003d self filter p map f\n    def flatMap[B](f: A \u003d\u003e Option[B]): Option[B] \u003d self filter p flatMap f\n    def foreach[U](f: A \u003d\u003e U): Unit \u003d self filter p foreach f\n    def withFilter(q: A \u003d\u003e Boolean): WithFilter \u003d new WithFilter(x \u003d\u003e p(x) \u0026\u0026 q(x))\n  }\n\n  /** Tests whether the option contains a given value as an element.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x \u003d\u003d elem\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @example {{{\n   *  // Returns true because Some instance contains string \"something\" which equals \"something\".\n   *  Some(\"something\") contains \"something\"\n   *\n   *  // Returns false because \"something\" !\u003d \"anything\".\n   *  Some(\"something\") contains \"anything\"\n   *\n   *  // Returns false when method called on None.\n   *  None contains \"anything\"\n   *  }}}\n   *\n   *  @param elem the element to test.\n   *  @return `true` if the option has an element that is equal (as\n   *  determined by `\u003d\u003d`) to `elem`, `false` otherwise.\n   */\n  final def contains[A1 \u003e: A](elem: A1): Boolean \u003d\n    !isEmpty \u0026\u0026 this.get \u003d\u003d elem\n\n  /** Returns true if this option is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 the predicate\n   * $p returns true when applied to this $option\u0027s value.\n   * Otherwise, returns false.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e p(x)\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @param  p   the predicate to test\n   */\n  @inline final def exists(p: A \u003d\u003e Boolean): Boolean \u003d\n    !isEmpty \u0026\u0026 p(this.get)\n\n  /** Returns true if this option is empty \u0027\u0027\u0027or\u0027\u0027\u0027 the predicate\n   * $p returns true when applied to this $option\u0027s value.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e p(x)\n   *   case None    \u003d\u003e true\n   * }\n   * }}}\n   *  @param  p   the predicate to test\n   */\n  @inline final def forall(p: A \u003d\u003e Boolean): Boolean \u003d isEmpty || p(this.get)\n\n  /** Apply the given procedure $f to the option\u0027s value,\n   *  if it is nonempty. Otherwise, do nothing.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e ()\n   * }\n   * }}}\n   *  @param  f   the procedure to apply.\n   *  @see map\n   *  @see flatMap\n   */\n  @inline final def foreach[U](f: A \u003d\u003e U): Unit \u003d {\n    if (!isEmpty) f(this.get)\n  }\n\n  /** Returns a $some containing the result of\n   * applying `pf` to this $option\u0027s contained\n   * value, \u0027\u0027\u0027if\u0027\u0027\u0027 this option is\n   * nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 `pf` is defined for that value.\n   * Returns $none otherwise.\n   *\n   *  @example {{{\n   *  // Returns Some(HTTP) because the partial function covers the case.\n   *  Some(\"http\") collect {case \"http\" \u003d\u003e \"HTTP\"}\n   *\n   *  // Returns None because the partial function doesn\u0027t cover the case.\n   *  Some(\"ftp\") collect {case \"http\" \u003d\u003e \"HTTP\"}\n   *\n   *  // Returns None because the option is empty. There is no value to pass to the partial function.\n   *  None collect {case value \u003d\u003e value}\n   *  }}}\n   *\n   *  @param  pf   the partial function.\n   *  @return the result of applying `pf` to this $option\u0027s\n   *  value (if possible), or $none.\n   */\n  @inline final def collect[B](pf: PartialFunction[A, B]): Option[B] \u003d\n    if (!isEmpty) pf.lift(this.get) else None\n\n  /** Returns this $option if it is nonempty,\n   *  otherwise return the result of evaluating `alternative`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Some(x)\n   *   case None    \u003d\u003e alternative\n   * }\n   * }}}\n   *  @param alternative the alternative expression.\n   */\n  @inline final def orElse[B \u003e: A](alternative: \u003d\u003e Option[B]): Option[B] \u003d\n    if (isEmpty) alternative else this\n\n  /** Returns a $some formed from this option and another option\n   *  by combining the corresponding elements in a pair.\n   *  If either of the two options is empty, $none is returned.\n   *\n   *  This is equivalent to:\n   *  {{{\n   *  (option1, option2) match {\n   *    case (Some(x), Some(y)) \u003d\u003e Some((x, y))\n   *    case _                  \u003d\u003e None\n   *  }\n   *  }}}\n   *  @example {{{\n   *  // Returns Some((\"foo\", \"bar\")) because both options are nonempty.\n   *  Some(\"foo\") zip Some(\"bar\")\n   *\n   *  // Returns None because `that` option is empty.\n   *  Some(\"foo\") zip None\n   *\n   *  // Returns None because `this` option is empty.\n   *  None zip Some(\"bar\")\n   *  }}}\n   *\n   *  @param  that   the options which is going to be zipped\n   */\n  final def zip[A1 \u003e: A, B](that: Option[B]): Option[(A1, B)] \u003d\n    if (isEmpty || that.isEmpty) None else Some((this.get, that.get))\n\n  /** Converts an Option of a pair into an Option of the first element and an Option of the second element.\n    *\n    *  This is equivalent to:\n    *  {{{\n    *  option match {\n    *    case Some((x, y)) \u003d\u003e (Some(x), Some(y))\n    *    case _            \u003d\u003e (None,    None)\n    *  }\n    *  }}}\n    *  @tparam A1    the type of the first half of the element pair\n    *  @tparam A2    the type of the second half of the element pair\n    *  @param asPair an implicit conversion which asserts that the element type\n    *                of this Option is a pair.\n    *  @return       a pair of Options, containing, respectively, the first and second half\n    *                of the element pair of this Option.\n    */\n  final def unzip[A1, A2](implicit asPair: A \u003c:\u003c (A1, A2)): (Option[A1], Option[A2]) \u003d {\n    if (isEmpty)\n      (None, None)\n    else {\n      val e \u003d asPair(this.get)\n      (Some(e._1), Some(e._2))\n    }\n  }\n\n  /** Converts an Option of a triple into three Options, one containing the element from each position of the triple.\n    *\n    *  This is equivalent to:\n    *  {{{\n    *  option match {\n    *    case Some((x, y, z)) \u003d\u003e (Some(x), Some(y), Some(z))\n    *    case _               \u003d\u003e (None,    None,    None)\n    *  }\n    *  }}}\n    *  @tparam A1      the type of the first of three elements in the triple\n    *  @tparam A2      the type of the second of three elements in the triple\n    *  @tparam A3      the type of the third of three elements in the triple\n    *  @param asTriple an implicit conversion which asserts that the element type\n    *                  of this Option is a triple.\n    *  @return         a triple of Options, containing, respectively, the first, second, and third\n    *                  elements from the element triple of this Option.\n    */\n  final def unzip3[A1, A2, A3](implicit asTriple: A \u003c:\u003c (A1, A2, A3)): (Option[A1], Option[A2], Option[A3]) \u003d {\n    if (isEmpty)\n      (None, None, None)\n    else {\n      val e \u003d asTriple(this.get)\n      (Some(e._1), Some(e._2), Some(e._3))\n    }\n  }\n\n  /** Returns a singleton iterator returning the $option\u0027s value\n   * if it is nonempty, or an empty iterator if the option is empty.\n   */\n  def iterator: Iterator[A] \u003d\n    if (isEmpty) collection.Iterator.empty else collection.Iterator.single(this.get)\n\n  /** Returns a singleton list containing the $option\u0027s value\n   * if it is nonempty, or the empty list if the $option is empty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e List(x)\n   *   case None    \u003d\u003e Nil\n   * }\n   * }}}\n   */\n  def toList: List[A] \u003d\n    if (isEmpty) List() else new ::(this.get, Nil)\n\n  /** Returns a [[scala.util.Left]] containing the given\n   * argument `left` if this $option is empty, or\n   * a [[scala.util.Right]] containing this $option\u0027s value if\n   * this is nonempty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Right(x)\n   *   case None    \u003d\u003e Left(left)\n   * }\n   * }}}\n   * @param left the expression to evaluate and return if this is empty\n   * @see toLeft\n   */\n  @inline final def toRight[X](left: \u003d\u003e X): Either[X, A] \u003d\n    if (isEmpty) Left(left) else Right(this.get)\n\n  /** Returns a [[scala.util.Right]] containing the given\n   * argument `right` if this is empty, or\n   * a [[scala.util.Left]] containing this $option\u0027s value\n   * if this $option is nonempty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Left(x)\n   *   case None    \u003d\u003e Right(right)\n   * }\n   * }}}\n   * @param right the expression to evaluate and return if this is empty\n   * @see toRight\n   */\n  @inline final def toLeft[X](right: \u003d\u003e X): Either[A, X] \u003d\n    if (isEmpty) Right(right) else Left(this.get)\n}\n\n/** Class `Some[A]` represents existing values of type\n *  `A`.\n */\n@SerialVersionUID(1234815782226070388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nfinal case class Some[+A](value: A) extends Option[A] {\n  def get: A \u003d value\n}\n\n\n/** This case object represents non-existent values.\n */\n@SerialVersionUID(5066590221178148012L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\ncase object None extends Option[Nothing] {\n  def get: Nothing \u003d throw new NoSuchElementException(\"None.get\")\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 01:26:40 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 1:26:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\npackage collection\npackage immutable\n\nimport scala.annotation.unchecked.uncheckedVariance\nimport scala.annotation.tailrec\nimport mutable.{Builder, ListBuffer}\nimport scala.collection.generic.DefaultSerializable\nimport scala.runtime.Statics.releaseFence\n\n/** A class for immutable linked lists representing ordered collections\n  *  of elements of type `A`.\n  *\n  *  This class comes with two implementing case classes `scala.Nil`\n  *  and `scala.::` that implement the abstract members `isEmpty`,\n  *  `head` and `tail`.\n  *\n  *  This class is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access\n  *  pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.\n  *\n  *  \u003d\u003dPerformance\u003d\u003d\n  *  \u0027\u0027\u0027Time:\u0027\u0027\u0027 `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list.\n  *  This includes the index-based lookup of elements, `length`, `append` and `reverse`.\n  *\n  *  \u0027\u0027\u0027Space:\u0027\u0027\u0027 `List` implements \u0027\u0027\u0027structural sharing\u0027\u0027\u0027 of the tail list. This means that many operations are either\n  *  zero- or constant-memory cost.\n  *  {{{\n  *  val mainList \u003d List(3, 2, 1)\n  *  val with4 \u003d    4 :: mainList  // re-uses mainList, costs one :: instance\n  *  val with42 \u003d   42 :: mainList // also re-uses mainList, cost one :: instance\n  *  val shorter \u003d  mainList.tail  // costs nothing as it uses the same 2::1::Nil instances as mainList\n  *  }}}\n  *\n  *  @example {{{\n  *  // Make a list via the companion object factory\n  *  val days \u003d List(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\")\n  *\n  *  // Make a list element-by-element\n  *  val when \u003d \"AM\" :: \"PM\" :: Nil\n  *\n  *  // Pattern match\n  *  days match {\n  *    case firstDay :: otherDays \u003d\u003e\n  *      println(\"The first day of the week is: \" + firstDay)\n  *    case Nil \u003d\u003e\n  *      println(\"There don\u0027t seem to be any week days.\")\n  *  }\n  *  }}}\n  *\n  *  @note The functional list is characterized by persistence and structural sharing, thus offering considerable\n  *        performance and space consumption benefits in some scenarios if used correctly.\n  *        However, note that objects having multiple references into the same functional list (that is,\n  *        objects that rely on structural sharing), will be serialized and deserialized with multiple lists, one for\n  *        each reference to it. I.e. structural sharing is lost after serialization/deserialization.\n  *\n  *  @see  [[https://docs.scala-lang.org/overviews/collections-2.13/concrete-immutable-collection-classes.html#lists \"Scala\u0027s Collection Library overview\"]]\n  *  section on `Lists` for more information.\n  *\n  *  @define coll list\n  *  @define Coll `List`\n  *  @define orderDependent\n  *  @define orderDependentFold\n  *  @define mayNotTerminateInf\n  *  @define willNotTerminateInf\n  */\n@SerialVersionUID(3L)\nsealed abstract class List[+A]\n  extends AbstractSeq[A]\n    with LinearSeq[A]\n    with LinearSeqOps[A, List, List[A]]\n    with StrictOptimizedLinearSeqOps[A, List, List[A]]\n    with StrictOptimizedSeqOps[A, List, List[A]]\n    with IterableFactoryDefaults[A, List]\n    with DefaultSerializable {\n\n  override def iterableFactory: SeqFactory[List] \u003d List\n\n  /** Adds an element at the beginning of this list.\n    *  @param elem the element to prepend.\n    *  @return  a list which contains `x` as first element and\n    *           which continues with this list.\n    *  Example:\n    *  {{{1 :: List(2, 3) \u003d List(2, 3).::(1) \u003d List(1, 2, 3)}}}\n    */\n  def :: [B \u003e: A](elem: B): List[B] \u003d  new ::(elem, this)\n\n  /** Adds the elements of a given list in front of this list.\n    *\n    * Example:\n    * {{{List(1, 2) ::: List(3, 4) \u003d List(3, 4).:::(List(1, 2)) \u003d List(1, 2, 3, 4)}}}\n    *\n    *  @param prefix  The list elements to prepend.\n    *  @return a list resulting from the concatenation of the given\n    *    list `prefix` and this list.\n    */\n  def ::: [B \u003e: A](prefix: List[B]): List[B] \u003d\n    if (isEmpty) prefix\n    else if (prefix.isEmpty) this\n    else {\n      val result \u003d new ::[B](prefix.head, this)\n      var curr \u003d result\n      var that \u003d prefix.tail\n      while (!that.isEmpty) {\n        val temp \u003d new ::[B](that.head, this)\n        curr.next \u003d temp\n        curr \u003d temp\n        that \u003d that.tail\n      }\n      releaseFence()\n      result\n    }\n\n  /** Adds the elements of a given list in reverse order in front of this list.\n    *  `xs reverse_::: ys` is equivalent to\n    *  `xs.reverse ::: ys` but is more efficient.\n    *\n    *  @param prefix the prefix to reverse and then prepend\n    *  @return       the concatenation of the reversed prefix and the current list.\n    */\n  def reverse_:::[B \u003e: A](prefix: List[B]): List[B] \u003d {\n    var these: List[B] \u003d this\n    var pres \u003d prefix\n    while (!pres.isEmpty) {\n      these \u003d pres.head :: these\n      pres \u003d pres.tail\n    }\n    these\n  }\n\n  override final def isEmpty: Boolean \u003d this eq Nil\n\n  override def prepended[B \u003e: A](elem: B): List[B] \u003d elem :: this\n\n  override def prependedAll[B \u003e: A](prefix: collection.IterableOnce[B]): List[B] \u003d prefix match {\n    case xs: List[B] \u003d\u003e xs ::: this\n    case _ if prefix.knownSize \u003d\u003d 0 \u003d\u003e this\n    case b: ListBuffer[B] if this.isEmpty \u003d\u003e b.toList\n    case _ \u003d\u003e\n      val iter \u003d prefix.iterator\n      if (iter.hasNext) {\n        val result \u003d new ::[B](iter.next(), this)\n        var curr \u003d result\n        while (iter.hasNext) {\n          val temp \u003d new ::[B](iter.next(), this)\n          curr.next \u003d temp\n          curr \u003d temp\n        }\n        releaseFence()\n        result\n      } else {\n        this\n      }\n  }\n\n  // When calling appendAll with another list `suffix`, avoid copying `suffix`\n  override def appendedAll[B \u003e: A](suffix: collection.IterableOnce[B]): List[B] \u003d suffix match {\n    case xs: List[B] \u003d\u003e this ::: xs\n    case _ \u003d\u003e super.appendedAll(suffix)\n  }\n\n  override def take(n: Int): List[A] \u003d if (isEmpty || n \u003c\u003d 0) Nil else {\n    val h \u003d new ::(head, Nil)\n    var t \u003d h\n    var rest \u003d tail\n    var i \u003d 1\n    while ({if (rest.isEmpty) return this; i \u003c n}) {\n      i +\u003d 1\n      val nx \u003d new ::(rest.head, Nil)\n      t.next \u003d nx\n      t \u003d nx\n      rest \u003d rest.tail\n    }\n    releaseFence()\n    h\n  }\n\n  /**\n    *  @example {{{\n    *  // Given a list\n    *  val letters \u003d List(\u0027a\u0027,\u0027b\u0027,\u0027c\u0027,\u0027d\u0027,\u0027e\u0027)\n    *\n    *  // `slice` returns all elements beginning at index `from` and afterwards,\n    *  // up until index `until` (excluding index `until`.)\n    *  letters.slice(1,3) // Returns List(\u0027b\u0027,\u0027c\u0027)\n    *  }}}\n    */\n  override def slice(from: Int, until: Int): List[A] \u003d {\n    val lo \u003d scala.math.max(from, 0)\n    if (until \u003c\u003d lo || isEmpty) Nil\n    else this drop lo take (until - lo)\n  }\n\n  override def takeRight(n: Int): List[A] \u003d {\n    @tailrec\n    def loop(lead: List[A], lag: List[A]): List[A] \u003d lead match {\n      case Nil \u003d\u003e lag\n      case _ :: tail \u003d\u003e loop(tail, lag.tail)\n    }\n    loop(drop(n), this)\n  }\n\n  // dropRight is inherited from LinearSeq\n\n  override def splitAt(n: Int): (List[A], List[A]) \u003d {\n    val b \u003d new ListBuffer[A]\n    var i \u003d 0\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 i \u003c n) {\n      i +\u003d 1\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    (b.toList, these)\n  }\n\n  override def updated[B \u003e: A](index: Int, elem: B): List[B] \u003d {\n    var i \u003d 0\n    var current \u003d this\n    val prefix \u003d ListBuffer.empty[B]\n    while (i \u003c index \u0026\u0026 current.nonEmpty) {\n      i +\u003d 1\n      prefix +\u003d current.head\n      current \u003d current.tail\n    }\n    if (i \u003d\u003d index \u0026\u0026 current.nonEmpty) {\n      prefix.prependToList(elem :: current.tail)\n    } else {\n      throw new IndexOutOfBoundsException(s\"$index is out of bounds (min 0, max ${length-1})\")\n    }\n  }\n\n  final override def map[B](f: A \u003d\u003e B): List[B] \u003d {\n    if (this eq Nil) Nil else {\n      val h \u003d new ::[B](f(head), Nil)\n      var t: ::[B] \u003d h\n      var rest \u003d tail\n      while (rest ne Nil) {\n        val nx \u003d new ::(f(rest.head), Nil)\n        t.next \u003d nx\n        t \u003d nx\n        rest \u003d rest.tail\n      }\n      releaseFence()\n      h\n    }\n  }\n\n  final override def collect[B](pf: PartialFunction[A, B]): List[B] \u003d {\n    if (this eq Nil) Nil else {\n      var rest \u003d this\n      var h: ::[B] \u003d null\n      var x: Any \u003d null\n      // Special case for first element\n      while (h eq null) {\n        x \u003d pf.applyOrElse(rest.head, List.partialNotApplied)\n        if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) h \u003d new ::(x.asInstanceOf[B], Nil)\n        rest \u003d rest.tail\n        if (rest eq Nil) return if (h eq null) Nil else h\n      }\n      var t \u003d h\n      // Remaining elements\n      while (rest ne Nil) {\n        x \u003d pf.applyOrElse(rest.head, List.partialNotApplied)\n        if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) {\n          val nx \u003d new ::(x.asInstanceOf[B], Nil)\n          t.next \u003d nx\n          t \u003d nx\n        }\n        rest \u003d rest.tail\n      }\n      releaseFence()\n      h\n    }\n  }\n\n  final override def flatMap[B](f: A \u003d\u003e IterableOnce[B]): List[B] \u003d {\n    var rest \u003d this\n    var h: ::[B] \u003d null\n    var t: ::[B] \u003d null\n    while (rest ne Nil) {\n      val it \u003d f(rest.head).iterator\n      while (it.hasNext) {\n        val nx \u003d new ::(it.next(), Nil)\n        if (t eq null) {\n          h \u003d nx\n        } else {\n          t.next \u003d nx\n        }\n        t \u003d nx\n      }\n      rest \u003d rest.tail\n    }\n    if (h eq null) Nil else {releaseFence(); h}\n  }\n\n  @inline final override def takeWhile(p: A \u003d\u003e Boolean): List[A] \u003d {\n    val b \u003d new ListBuffer[A]\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 p(these.head)) {\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    b.toList\n  }\n\n  @inline final override def span(p: A \u003d\u003e Boolean): (List[A], List[A]) \u003d {\n    val b \u003d new ListBuffer[A]\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 p(these.head)) {\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    (b.toList, these)\n  }\n\n  // Overridden with an implementation identical to the inherited one (at this time)\n  // solely so it can be finalized and thus inlinable.\n  @inline final override def foreach[U](f: A \u003d\u003e U): Unit \u003d {\n    var these \u003d this\n    while (!these.isEmpty) {\n      f(these.head)\n      these \u003d these.tail\n    }\n  }\n\n  final override def reverse: List[A] \u003d {\n    var result: List[A] \u003d Nil\n    var these \u003d this\n    while (!these.isEmpty) {\n      result \u003d these.head :: result\n      these \u003d these.tail\n    }\n    result\n  }\n\n  final override def foldRight[B](z: B)(op: (A, B) \u003d\u003e B): B \u003d {\n    var acc \u003d z\n    var these: List[A] \u003d reverse\n    while (!these.isEmpty) {\n      acc \u003d op(these.head, acc)\n      these \u003d these.tail\n    }\n    acc\n  }\n\n  // Copy/Paste overrides to avoid interface calls inside loops.\n\n  override final def length: Int \u003d {\n    var these \u003d this\n    var len \u003d 0\n    while (!these.isEmpty) {\n      len +\u003d 1\n      these \u003d these.tail\n    }\n    len\n  }\n\n  override final def lengthCompare(len: Int): Int \u003d {\n    @tailrec def loop(i: Int, xs: List[A]): Int \u003d {\n      if (i \u003d\u003d len)\n        if (xs.isEmpty) 0 else 1\n      else if (xs.isEmpty)\n        -1\n      else\n        loop(i + 1, xs.tail)\n    }\n    if (len \u003c 0) 1\n    else loop(0, coll)\n  }\n\n  override final def forall(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (!p(these.head)) return false\n      these \u003d these.tail\n    }\n    true\n  }\n\n  override final def exists(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (p(these.head)) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override final def contains[A1 \u003e: A](elem: A1): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (these.head \u003d\u003d elem) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override final def find(p: A \u003d\u003e Boolean): Option[A] \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (p(these.head)) return Some(these.head)\n      these \u003d these.tail\n    }\n    None\n  }\n\n  override def last: A \u003d {\n    if (isEmpty) throw new NoSuchElementException(\"List.last\")\n    else {\n      var these \u003d this\n      var scout \u003d tail\n      while (!scout.isEmpty) {\n        these \u003d scout\n        scout \u003d scout.tail\n      }\n      these.head\n    }\n  }\n\n  override def corresponds[B](that: collection.Seq[B])(p: (A, B) \u003d\u003e Boolean): Boolean \u003d that match {\n    case that: LinearSeq[B] \u003d\u003e\n      var i \u003d this\n      var j \u003d that\n      while (!(i.isEmpty || j.isEmpty)) {\n        if (!p(i.head, j.head))\n          return false\n        i \u003d i.tail\n        j \u003d j.tail\n      }\n      i.isEmpty \u0026\u0026 j.isEmpty\n    case _ \u003d\u003e\n      super.corresponds(that)(p)\n  }\n\n  override protected[this] def className \u003d \"List\"\n\n  /** Builds a new list by applying a function to all elements of this list.\n    *  Like `xs map f`, but returns `xs` unchanged if function\n    *  `f` maps all elements to themselves (as determined by `eq`).\n    *\n    *  @param f      the function to apply to each element.\n    *  @tparam B     the element type of the returned collection.\n    *  @return       a list resulting from applying the given function\n    *                `f` to each element of this list and collecting the results.\n    */\n  @`inline` final def mapConserve[B \u003e: A \u003c: AnyRef](f: A \u003d\u003e B): List[B] \u003d {\n    // Note to developers: there exists a duplication between this function and `reflect.internal.util.Collections#map2Conserve`.\n    // If any successful optimization attempts or other changes are made, please rehash them there too.\n    @tailrec\n    def loop(mappedHead: List[B], mappedLast: ::[B], unchanged: List[A], pending: List[A]): List[B] \u003d {\n      if (pending.isEmpty) {\n        if (mappedHead eq null) unchanged\n        else {\n          mappedLast.next \u003d (unchanged: List[B])\n          mappedHead\n        }\n      }\n      else {\n        val head0 \u003d pending.head\n        val head1 \u003d f(head0)\n\n        if (head1 eq head0.asInstanceOf[AnyRef])\n          loop(mappedHead, mappedLast, unchanged, pending.tail)\n        else {\n          var xc \u003d unchanged\n          var mappedHead1: List[B] \u003d mappedHead\n          var mappedLast1: ::[B] \u003d mappedLast\n          while (xc ne pending) {\n            val next \u003d new ::[B](xc.head, Nil)\n            if (mappedHead1 eq null) mappedHead1 \u003d next\n            if (mappedLast1 ne null) mappedLast1.next \u003d next\n            mappedLast1 \u003d next\n            xc \u003d xc.tail\n          }\n          val next \u003d new ::(head1, Nil)\n          if (mappedHead1 eq null) mappedHead1 \u003d next\n          if (mappedLast1 ne null) mappedLast1.next \u003d next\n          mappedLast1 \u003d next\n          val tail0 \u003d pending.tail\n          loop(mappedHead1, mappedLast1, tail0, tail0)\n\n        }\n      }\n    }\n    val result \u003d loop(null, null, this, this)\n    releaseFence()\n    result\n  }\n\n  override def filter(p: A \u003d\u003e Boolean): List[A] \u003d filterCommon(p, isFlipped \u003d false)\n\n  override def filterNot(p: A \u003d\u003e Boolean): List[A] \u003d filterCommon(p, isFlipped \u003d true)\n\n  private[this] def filterCommon(p: A \u003d\u003e Boolean, isFlipped: Boolean): List[A] \u003d {\n\n    // everything seen so far so far is not included\n    @tailrec def noneIn(l: List[A]): List[A] \u003d {\n      if (l.isEmpty)\n        Nil\n      else {\n        val h \u003d l.head\n        val t \u003d l.tail\n        if (p(h) !\u003d isFlipped)\n          allIn(l, t)\n        else\n          noneIn(t)\n      }\n    }\n\n    // everything from \u0027start\u0027 is included, if everything from this point is in we can return the origin\n    // start otherwise if we discover an element that is out we must create a new partial list.\n    @tailrec def allIn(start: List[A], remaining: List[A]): List[A] \u003d {\n      if (remaining.isEmpty)\n        start\n      else {\n        val x \u003d remaining.head\n        if (p(x) !\u003d isFlipped)\n          allIn(start, remaining.tail)\n        else\n          partialFill(start, remaining)\n      }\n    }\n\n    // we have seen elements that should be included then one that should be excluded, start building\n    def partialFill(origStart: List[A], firstMiss: List[A]): List[A] \u003d {\n      val newHead \u003d new ::(origStart.head, Nil)\n      var toProcess \u003d origStart.tail\n      var currentLast \u003d newHead\n\n      // we know that all elements are :: until at least firstMiss.tail\n      while (!(toProcess eq firstMiss)) {\n        val newElem \u003d new ::(toProcess.head, Nil)\n        currentLast.next \u003d newElem\n        currentLast \u003d newElem\n        toProcess \u003d toProcess.tail\n      }\n\n      // at this point newHead points to a list which is a duplicate of all the \u0027in\u0027 elements up to the first miss.\n      // currentLast is the last element in that list.\n\n      // now we are going to try and share as much of the tail as we can, only moving elements across when we have to.\n      var next \u003d firstMiss.tail\n      var nextToCopy \u003d next // the next element we would need to copy to our list if we cant share.\n      while (!next.isEmpty) {\n        // generally recommended is next.isNonEmpty but this incurs an extra method call.\n        val head: A \u003d next.head\n        if (p(head) !\u003d isFlipped) {\n          next \u003d next.tail\n        } else {\n          // its not a match - do we have outstanding elements?\n          while (!(nextToCopy eq next)) {\n            val newElem \u003d new ::(nextToCopy.head, Nil)\n            currentLast.next \u003d newElem\n            currentLast \u003d newElem\n            nextToCopy \u003d nextToCopy.tail\n          }\n          nextToCopy \u003d next.tail\n          next \u003d next.tail\n        }\n      }\n\n      // we have remaining elements - they are unchanged attach them to the end\n      if (!nextToCopy.isEmpty)\n        currentLast.next \u003d nextToCopy\n\n      newHead\n    }\n\n    val result \u003d noneIn(this)\n    releaseFence()\n    result\n  }\n\n  override def partition(p: A \u003d\u003e Boolean): (List[A], List[A]) \u003d {\n    if (isEmpty) List.TupleOfNil\n    else super.partition(p) match {\n      case (Nil, xs) \u003d\u003e (Nil, this)\n      case (xs, Nil) \u003d\u003e (this, Nil)\n      case pair \u003d\u003e pair\n    }\n  }\n\n  final override def toList: List[A] \u003d this\n\n  // Override for performance\n  override def equals(o: scala.Any): Boolean \u003d {\n    @tailrec def listEq(a: List[_], b: List[_]): Boolean \u003d\n      (a eq b) || {\n        val aEmpty \u003d a.isEmpty\n        val bEmpty \u003d b.isEmpty\n        if (!(aEmpty || bEmpty) \u0026\u0026 a.head \u003d\u003d b.head) {\n          listEq(a.tail, b.tail)\n        }\n        else {\n          aEmpty \u0026\u0026 bEmpty\n        }\n      }\n\n    o match {\n      case that: List[_] \u003d\u003e listEq(this, that)\n      case _ \u003d\u003e super.equals(o)\n    }\n  }\n\n  // TODO: uncomment once bincompat allows (reference: scala/scala#9365)\n  /*\n  // Override for performance: traverse only as much as needed\n  // and share tail when nothing needs to be filtered out anymore\n  override def diff[B \u003e: A](that: collection.Seq[B]): AnyRef \u003d {\n    if (that.isEmpty || this.isEmpty) this\n    else if (tail.isEmpty) if (that.contains(head)) Nil else this\n    else {\n      val occ \u003d occCounts(that)\n      val b \u003d new ListBuffer[A]()\n      @tailrec\n      def rec(remainder: List[A]): List[A] \u003d {\n        if(occ.isEmpty) b.prependToList(remainder)\n        else remainder match {\n          case Nil \u003d\u003e b.result()\n          case head :: next \u003d\u003e {\n            occ.updateWith(head){\n              case None \u003d\u003e {\n                b.append(head)\n                None\n              }\n              case Some(1) \u003d\u003e None\n              case Some(n) \u003d\u003e Some(n - 1)\n            }\n            rec(next)\n          }\n        }\n      }\n      rec(this)\n    }\n  }\n  */\n\n}\n\n// Internal code that mutates `next` _must_ call `Statics.releaseFence()` if either immediately, or\n// before a newly-allocated, thread-local :: instance is aliased (e.g. in ListBuffer.toList)\nfinal case class :: [+A](override val head: A, private[scala] var next: List[A @uncheckedVariance]) // sound because `next` is used only locally\n  extends List[A] {\n  releaseFence()\n  override def headOption: Some[A] \u003d Some(head)\n  override def tail: List[A] \u003d next\n}\n\ncase object Nil extends List[Nothing] {\n  override def head: Nothing \u003d throw new NoSuchElementException(\"head of empty list\")\n  override def headOption: None.type \u003d None\n  override def tail: Nothing \u003d throw new UnsupportedOperationException(\"tail of empty list\")\n  override def last: Nothing \u003d throw new NoSuchElementException(\"last of empty list\")\n  override def init: Nothing \u003d throw new UnsupportedOperationException(\"init of empty list\")\n  override def knownSize: Int \u003d 0\n  override def iterator: Iterator[Nothing] \u003d Iterator.empty\n  override def unzip[A1, A2](implicit asPair: Nothing \u003d\u003e (A1, A2)): (List[A1], List[A2]) \u003d EmptyUnzip\n\n  @transient\n  private[this] val EmptyUnzip \u003d (Nil, Nil)\n}\n\n/**\n  * $factoryInfo\n  * @define coll list\n  * @define Coll `List`\n  */\n@SerialVersionUID(3L)\nobject List extends StrictOptimizedSeqFactory[List] {\n  private val TupleOfNil \u003d (Nil, Nil)\n\n  def from[B](coll: collection.IterableOnce[B]): List[B] \u003d Nil.prependedAll(coll)\n\n  def newBuilder[A]: Builder[A, List[A]] \u003d new ListBuffer()\n\n  def empty[A]: List[A] \u003d Nil\n\n  @transient\n  private[collection] val partialNotApplied \u003d new Function1[Any, Any] { def apply(x: Any): Any \u003d this }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 1:26:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 01:26:40 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 1:26:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\npackage collection\npackage immutable\n\nimport scala.annotation.unchecked.uncheckedVariance\nimport scala.annotation.tailrec\nimport mutable.{Builder, ListBuffer}\nimport scala.collection.generic.DefaultSerializable\nimport scala.runtime.Statics.releaseFence\n\n/** A class for immutable linked lists representing ordered collections\n  *  of elements of type `A`.\n  *\n  *  This class comes with two implementing case classes `scala.Nil`\n  *  and `scala.::` that implement the abstract members `isEmpty`,\n  *  `head` and `tail`.\n  *\n  *  This class is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access\n  *  pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.\n  *\n  *  \u003d\u003dPerformance\u003d\u003d\n  *  \u0027\u0027\u0027Time:\u0027\u0027\u0027 `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list.\n  *  This includes the index-based lookup of elements, `length`, `append` and `reverse`.\n  *\n  *  \u0027\u0027\u0027Space:\u0027\u0027\u0027 `List` implements \u0027\u0027\u0027structural sharing\u0027\u0027\u0027 of the tail list. This means that many operations are either\n  *  zero- or constant-memory cost.\n  *  {{{\n  *  val mainList \u003d List(3, 2, 1)\n  *  val with4 \u003d    4 :: mainList  // re-uses mainList, costs one :: instance\n  *  val with42 \u003d   42 :: mainList // also re-uses mainList, cost one :: instance\n  *  val shorter \u003d  mainList.tail  // costs nothing as it uses the same 2::1::Nil instances as mainList\n  *  }}}\n  *\n  *  @example {{{\n  *  // Make a list via the companion object factory\n  *  val days \u003d List(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\")\n  *\n  *  // Make a list element-by-element\n  *  val when \u003d \"AM\" :: \"PM\" :: Nil\n  *\n  *  // Pattern match\n  *  days match {\n  *    case firstDay :: otherDays \u003d\u003e\n  *      println(\"The first day of the week is: \" + firstDay)\n  *    case Nil \u003d\u003e\n  *      println(\"There don\u0027t seem to be any week days.\")\n  *  }\n  *  }}}\n  *\n  *  @note The functional list is characterized by persistence and structural sharing, thus offering considerable\n  *        performance and space consumption benefits in some scenarios if used correctly.\n  *        However, note that objects having multiple references into the same functional list (that is,\n  *        objects that rely on structural sharing), will be serialized and deserialized with multiple lists, one for\n  *        each reference to it. I.e. structural sharing is lost after serialization/deserialization.\n  *\n  *  @see  [[https://docs.scala-lang.org/overviews/collections-2.13/concrete-immutable-collection-classes.html#lists \"Scala\u0027s Collection Library overview\"]]\n  *  section on `Lists` for more information.\n  *\n  *  @define coll list\n  *  @define Coll `List`\n  *  @define orderDependent\n  *  @define orderDependentFold\n  *  @define mayNotTerminateInf\n  *  @define willNotTerminateInf\n  */\n@SerialVersionUID(3L)\nsealed abstract class List[+A]\n  extends AbstractSeq[A]\n    with LinearSeq[A]\n    with LinearSeqOps[A, List, List[A]]\n    with StrictOptimizedLinearSeqOps[A, List, List[A]]\n    with StrictOptimizedSeqOps[A, List, List[A]]\n    with IterableFactoryDefaults[A, List]\n    with DefaultSerializable {\n\n  override def iterableFactory: SeqFactory[List] \u003d List\n\n  /** Adds an element at the beginning of this list.\n    *  @param elem the element to prepend.\n    *  @return  a list which contains `x` as first element and\n    *           which continues with this list.\n    *  Example:\n    *  {{{1 :: List(2, 3) \u003d List(2, 3).::(1) \u003d List(1, 2, 3)}}}\n    */\n  def :: [B \u003e: A](elem: B): List[B] \u003d  new ::(elem, this)\n\n  /** Adds the elements of a given list in front of this list.\n    *\n    * Example:\n    * {{{List(1, 2) ::: List(3, 4) \u003d List(3, 4).:::(List(1, 2)) \u003d List(1, 2, 3, 4)}}}\n    *\n    *  @param prefix  The list elements to prepend.\n    *  @return a list resulting from the concatenation of the given\n    *    list `prefix` and this list.\n    */\n  def ::: [B \u003e: A](prefix: List[B]): List[B] \u003d\n    if (isEmpty) prefix\n    else if (prefix.isEmpty) this\n    else {\n      val result \u003d new ::[B](prefix.head, this)\n      var curr \u003d result\n      var that \u003d prefix.tail\n      while (!that.isEmpty) {\n        val temp \u003d new ::[B](that.head, this)\n        curr.next \u003d temp\n        curr \u003d temp\n        that \u003d that.tail\n      }\n      releaseFence()\n      result\n    }\n\n  /** Adds the elements of a given list in reverse order in front of this list.\n    *  `xs reverse_::: ys` is equivalent to\n    *  `xs.reverse ::: ys` but is more efficient.\n    *\n    *  @param prefix the prefix to reverse and then prepend\n    *  @return       the concatenation of the reversed prefix and the current list.\n    */\n  def reverse_:::[B \u003e: A](prefix: List[B]): List[B] \u003d {\n    var these: List[B] \u003d this\n    var pres \u003d prefix\n    while (!pres.isEmpty) {\n      these \u003d pres.head :: these\n      pres \u003d pres.tail\n    }\n    these\n  }\n\n  override final def isEmpty: Boolean \u003d this eq Nil\n\n  override def prepended[B \u003e: A](elem: B): List[B] \u003d elem :: this\n\n  override def prependedAll[B \u003e: A](prefix: collection.IterableOnce[B]): List[B] \u003d prefix match {\n    case xs: List[B] \u003d\u003e xs ::: this\n    case _ if prefix.knownSize \u003d\u003d 0 \u003d\u003e this\n    case b: ListBuffer[B] if this.isEmpty \u003d\u003e b.toList\n    case _ \u003d\u003e\n      val iter \u003d prefix.iterator\n      if (iter.hasNext) {\n        val result \u003d new ::[B](iter.next(), this)\n        var curr \u003d result\n        while (iter.hasNext) {\n          val temp \u003d new ::[B](iter.next(), this)\n          curr.next \u003d temp\n          curr \u003d temp\n        }\n        releaseFence()\n        result\n      } else {\n        this\n      }\n  }\n\n  // When calling appendAll with another list `suffix`, avoid copying `suffix`\n  override def appendedAll[B \u003e: A](suffix: collection.IterableOnce[B]): List[B] \u003d suffix match {\n    case xs: List[B] \u003d\u003e this ::: xs\n    case _ \u003d\u003e super.appendedAll(suffix)\n  }\n\n  override def take(n: Int): List[A] \u003d if (isEmpty || n \u003c\u003d 0) Nil else {\n    val h \u003d new ::(head, Nil)\n    var t \u003d h\n    var rest \u003d tail\n    var i \u003d 1\n    while ({if (rest.isEmpty) return this; i \u003c n}) {\n      i +\u003d 1\n      val nx \u003d new ::(rest.head, Nil)\n      t.next \u003d nx\n      t \u003d nx\n      rest \u003d rest.tail\n    }\n    releaseFence()\n    h\n  }\n\n  /**\n    *  @example {{{\n    *  // Given a list\n    *  val letters \u003d List(\u0027a\u0027,\u0027b\u0027,\u0027c\u0027,\u0027d\u0027,\u0027e\u0027)\n    *\n    *  // `slice` returns all elements beginning at index `from` and afterwards,\n    *  // up until index `until` (excluding index `until`.)\n    *  letters.slice(1,3) // Returns List(\u0027b\u0027,\u0027c\u0027)\n    *  }}}\n    */\n  override def slice(from: Int, until: Int): List[A] \u003d {\n    val lo \u003d scala.math.max(from, 0)\n    if (until \u003c\u003d lo || isEmpty) Nil\n    else this drop lo take (until - lo)\n  }\n\n  override def takeRight(n: Int): List[A] \u003d {\n    @tailrec\n    def loop(lead: List[A], lag: List[A]): List[A] \u003d lead match {\n      case Nil \u003d\u003e lag\n      case _ :: tail \u003d\u003e loop(tail, lag.tail)\n    }\n    loop(drop(n), this)\n  }\n\n  // dropRight is inherited from LinearSeq\n\n  override def splitAt(n: Int): (List[A], List[A]) \u003d {\n    val b \u003d new ListBuffer[A]\n    var i \u003d 0\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 i \u003c n) {\n      i +\u003d 1\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    (b.toList, these)\n  }\n\n  override def updated[B \u003e: A](index: Int, elem: B): List[B] \u003d {\n    var i \u003d 0\n    var current \u003d this\n    val prefix \u003d ListBuffer.empty[B]\n    while (i \u003c index \u0026\u0026 current.nonEmpty) {\n      i +\u003d 1\n      prefix +\u003d current.head\n      current \u003d current.tail\n    }\n    if (i \u003d\u003d index \u0026\u0026 current.nonEmpty) {\n      prefix.prependToList(elem :: current.tail)\n    } else {\n      throw new IndexOutOfBoundsException(s\"$index is out of bounds (min 0, max ${length-1})\")\n    }\n  }\n\n  final override def map[B](f: A \u003d\u003e B): List[B] \u003d {\n    if (this eq Nil) Nil else {\n      val h \u003d new ::[B](f(head), Nil)\n      var t: ::[B] \u003d h\n      var rest \u003d tail\n      while (rest ne Nil) {\n        val nx \u003d new ::(f(rest.head), Nil)\n        t.next \u003d nx\n        t \u003d nx\n        rest \u003d rest.tail\n      }\n      releaseFence()\n      h\n    }\n  }\n\n  final override def collect[B](pf: PartialFunction[A, B]): List[B] \u003d {\n    if (this eq Nil) Nil else {\n      var rest \u003d this\n      var h: ::[B] \u003d null\n      var x: Any \u003d null\n      // Special case for first element\n      while (h eq null) {\n        x \u003d pf.applyOrElse(rest.head, List.partialNotApplied)\n        if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) h \u003d new ::(x.asInstanceOf[B], Nil)\n        rest \u003d rest.tail\n        if (rest eq Nil) return if (h eq null) Nil else h\n      }\n      var t \u003d h\n      // Remaining elements\n      while (rest ne Nil) {\n        x \u003d pf.applyOrElse(rest.head, List.partialNotApplied)\n        if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) {\n          val nx \u003d new ::(x.asInstanceOf[B], Nil)\n          t.next \u003d nx\n          t \u003d nx\n        }\n        rest \u003d rest.tail\n      }\n      releaseFence()\n      h\n    }\n  }\n\n  final override def flatMap[B](f: A \u003d\u003e IterableOnce[B]): List[B] \u003d {\n    var rest \u003d this\n    var h: ::[B] \u003d null\n    var t: ::[B] \u003d null\n    while (rest ne Nil) {\n      val it \u003d f(rest.head).iterator\n      while (it.hasNext) {\n        val nx \u003d new ::(it.next(), Nil)\n        if (t eq null) {\n          h \u003d nx\n        } else {\n          t.next \u003d nx\n        }\n        t \u003d nx\n      }\n      rest \u003d rest.tail\n    }\n    if (h eq null) Nil else {releaseFence(); h}\n  }\n\n  @inline final override def takeWhile(p: A \u003d\u003e Boolean): List[A] \u003d {\n    val b \u003d new ListBuffer[A]\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 p(these.head)) {\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    b.toList\n  }\n\n  @inline final override def span(p: A \u003d\u003e Boolean): (List[A], List[A]) \u003d {\n    val b \u003d new ListBuffer[A]\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 p(these.head)) {\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    (b.toList, these)\n  }\n\n  // Overridden with an implementation identical to the inherited one (at this time)\n  // solely so it can be finalized and thus inlinable.\n  @inline final override def foreach[U](f: A \u003d\u003e U): Unit \u003d {\n    var these \u003d this\n    while (!these.isEmpty) {\n      f(these.head)\n      these \u003d these.tail\n    }\n  }\n\n  final override def reverse: List[A] \u003d {\n    var result: List[A] \u003d Nil\n    var these \u003d this\n    while (!these.isEmpty) {\n      result \u003d these.head :: result\n      these \u003d these.tail\n    }\n    result\n  }\n\n  final override def foldRight[B](z: B)(op: (A, B) \u003d\u003e B): B \u003d {\n    var acc \u003d z\n    var these: List[A] \u003d reverse\n    while (!these.isEmpty) {\n      acc \u003d op(these.head, acc)\n      these \u003d these.tail\n    }\n    acc\n  }\n\n  // Copy/Paste overrides to avoid interface calls inside loops.\n\n  override final def length: Int \u003d {\n    var these \u003d this\n    var len \u003d 0\n    while (!these.isEmpty) {\n      len +\u003d 1\n      these \u003d these.tail\n    }\n    len\n  }\n\n  override final def lengthCompare(len: Int): Int \u003d {\n    @tailrec def loop(i: Int, xs: List[A]): Int \u003d {\n      if (i \u003d\u003d len)\n        if (xs.isEmpty) 0 else 1\n      else if (xs.isEmpty)\n        -1\n      else\n        loop(i + 1, xs.tail)\n    }\n    if (len \u003c 0) 1\n    else loop(0, coll)\n  }\n\n  override final def forall(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (!p(these.head)) return false\n      these \u003d these.tail\n    }\n    true\n  }\n\n  override final def exists(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (p(these.head)) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override final def contains[A1 \u003e: A](elem: A1): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (these.head \u003d\u003d elem) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override final def find(p: A \u003d\u003e Boolean): Option[A] \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (p(these.head)) return Some(these.head)\n      these \u003d these.tail\n    }\n    None\n  }\n\n  override def last: A \u003d {\n    if (isEmpty) throw new NoSuchElementException(\"List.last\")\n    else {\n      var these \u003d this\n      var scout \u003d tail\n      while (!scout.isEmpty) {\n        these \u003d scout\n        scout \u003d scout.tail\n      }\n      these.head\n    }\n  }\n\n  override def corresponds[B](that: collection.Seq[B])(p: (A, B) \u003d\u003e Boolean): Boolean \u003d that match {\n    case that: LinearSeq[B] \u003d\u003e\n      var i \u003d this\n      var j \u003d that\n      while (!(i.isEmpty || j.isEmpty)) {\n        if (!p(i.head, j.head))\n          return false\n        i \u003d i.tail\n        j \u003d j.tail\n      }\n      i.isEmpty \u0026\u0026 j.isEmpty\n    case _ \u003d\u003e\n      super.corresponds(that)(p)\n  }\n\n  override protected[this] def className \u003d \"List\"\n\n  /** Builds a new list by applying a function to all elements of this list.\n    *  Like `xs map f`, but returns `xs` unchanged if function\n    *  `f` maps all elements to themselves (as determined by `eq`).\n    *\n    *  @param f      the function to apply to each element.\n    *  @tparam B     the element type of the returned collection.\n    *  @return       a list resulting from applying the given function\n    *                `f` to each element of this list and collecting the results.\n    */\n  @`inline` final def mapConserve[B \u003e: A \u003c: AnyRef](f: A \u003d\u003e B): List[B] \u003d {\n    // Note to developers: there exists a duplication between this function and `reflect.internal.util.Collections#map2Conserve`.\n    // If any successful optimization attempts or other changes are made, please rehash them there too.\n    @tailrec\n    def loop(mappedHead: List[B], mappedLast: ::[B], unchanged: List[A], pending: List[A]): List[B] \u003d {\n      if (pending.isEmpty) {\n        if (mappedHead eq null) unchanged\n        else {\n          mappedLast.next \u003d (unchanged: List[B])\n          mappedHead\n        }\n      }\n      else {\n        val head0 \u003d pending.head\n        val head1 \u003d f(head0)\n\n        if (head1 eq head0.asInstanceOf[AnyRef])\n          loop(mappedHead, mappedLast, unchanged, pending.tail)\n        else {\n          var xc \u003d unchanged\n          var mappedHead1: List[B] \u003d mappedHead\n          var mappedLast1: ::[B] \u003d mappedLast\n          while (xc ne pending) {\n            val next \u003d new ::[B](xc.head, Nil)\n            if (mappedHead1 eq null) mappedHead1 \u003d next\n            if (mappedLast1 ne null) mappedLast1.next \u003d next\n            mappedLast1 \u003d next\n            xc \u003d xc.tail\n          }\n          val next \u003d new ::(head1, Nil)\n          if (mappedHead1 eq null) mappedHead1 \u003d next\n          if (mappedLast1 ne null) mappedLast1.next \u003d next\n          mappedLast1 \u003d next\n          val tail0 \u003d pending.tail\n          loop(mappedHead1, mappedLast1, tail0, tail0)\n\n        }\n      }\n    }\n    val result \u003d loop(null, null, this, this)\n    releaseFence()\n    result\n  }\n\n  override def filter(p: A \u003d\u003e Boolean): List[A] \u003d filterCommon(p, isFlipped \u003d false)\n\n  override def filterNot(p: A \u003d\u003e Boolean): List[A] \u003d filterCommon(p, isFlipped \u003d true)\n\n  private[this] def filterCommon(p: A \u003d\u003e Boolean, isFlipped: Boolean): List[A] \u003d {\n\n    // everything seen so far so far is not included\n    @tailrec def noneIn(l: List[A]): List[A] \u003d {\n      if (l.isEmpty)\n        Nil\n      else {\n        val h \u003d l.head\n        val t \u003d l.tail\n        if (p(h) !\u003d isFlipped)\n          allIn(l, t)\n        else\n          noneIn(t)\n      }\n    }\n\n    // everything from \u0027start\u0027 is included, if everything from this point is in we can return the origin\n    // start otherwise if we discover an element that is out we must create a new partial list.\n    @tailrec def allIn(start: List[A], remaining: List[A]): List[A] \u003d {\n      if (remaining.isEmpty)\n        start\n      else {\n        val x \u003d remaining.head\n        if (p(x) !\u003d isFlipped)\n          allIn(start, remaining.tail)\n        else\n          partialFill(start, remaining)\n      }\n    }\n\n    // we have seen elements that should be included then one that should be excluded, start building\n    def partialFill(origStart: List[A], firstMiss: List[A]): List[A] \u003d {\n      val newHead \u003d new ::(origStart.head, Nil)\n      var toProcess \u003d origStart.tail\n      var currentLast \u003d newHead\n\n      // we know that all elements are :: until at least firstMiss.tail\n      while (!(toProcess eq firstMiss)) {\n        val newElem \u003d new ::(toProcess.head, Nil)\n        currentLast.next \u003d newElem\n        currentLast \u003d newElem\n        toProcess \u003d toProcess.tail\n      }\n\n      // at this point newHead points to a list which is a duplicate of all the \u0027in\u0027 elements up to the first miss.\n      // currentLast is the last element in that list.\n\n      // now we are going to try and share as much of the tail as we can, only moving elements across when we have to.\n      var next \u003d firstMiss.tail\n      var nextToCopy \u003d next // the next element we would need to copy to our list if we cant share.\n      while (!next.isEmpty) {\n        // generally recommended is next.isNonEmpty but this incurs an extra method call.\n        val head: A \u003d next.head\n        if (p(head) !\u003d isFlipped) {\n          next \u003d next.tail\n        } else {\n          // its not a match - do we have outstanding elements?\n          while (!(nextToCopy eq next)) {\n            val newElem \u003d new ::(nextToCopy.head, Nil)\n            currentLast.next \u003d newElem\n            currentLast \u003d newElem\n            nextToCopy \u003d nextToCopy.tail\n          }\n          nextToCopy \u003d next.tail\n          next \u003d next.tail\n        }\n      }\n\n      // we have remaining elements - they are unchanged attach them to the end\n      if (!nextToCopy.isEmpty)\n        currentLast.next \u003d nextToCopy\n\n      newHead\n    }\n\n    val result \u003d noneIn(this)\n    releaseFence()\n    result\n  }\n\n  override def partition(p: A \u003d\u003e Boolean): (List[A], List[A]) \u003d {\n    if (isEmpty) List.TupleOfNil\n    else super.partition(p) match {\n      case (Nil, xs) \u003d\u003e (Nil, this)\n      case (xs, Nil) \u003d\u003e (this, Nil)\n      case pair \u003d\u003e pair\n    }\n  }\n\n  final override def toList: List[A] \u003d this\n\n  // Override for performance\n  override def equals(o: scala.Any): Boolean \u003d {\n    @tailrec def listEq(a: List[_], b: List[_]): Boolean \u003d\n      (a eq b) || {\n        val aEmpty \u003d a.isEmpty\n        val bEmpty \u003d b.isEmpty\n        if (!(aEmpty || bEmpty) \u0026\u0026 a.head \u003d\u003d b.head) {\n          listEq(a.tail, b.tail)\n        }\n        else {\n          aEmpty \u0026\u0026 bEmpty\n        }\n      }\n\n    o match {\n      case that: List[_] \u003d\u003e listEq(this, that)\n      case _ \u003d\u003e super.equals(o)\n    }\n  }\n\n  // TODO: uncomment once bincompat allows (reference: scala/scala#9365)\n  /*\n  // Override for performance: traverse only as much as needed\n  // and share tail when nothing needs to be filtered out anymore\n  override def diff[B \u003e: A](that: collection.Seq[B]): AnyRef \u003d {\n    if (that.isEmpty || this.isEmpty) this\n    else if (tail.isEmpty) if (that.contains(head)) Nil else this\n    else {\n      val occ \u003d occCounts(that)\n      val b \u003d new ListBuffer[A]()\n      @tailrec\n      def rec(remainder: List[A]): List[A] \u003d {\n        if(occ.isEmpty) b.prependToList(remainder)\n        else remainder match {\n          case Nil \u003d\u003e b.result()\n          case head :: next \u003d\u003e {\n            occ.updateWith(head){\n              case None \u003d\u003e {\n                b.append(head)\n                None\n              }\n              case Some(1) \u003d\u003e None\n              case Some(n) \u003d\u003e Some(n - 1)\n            }\n            rec(next)\n          }\n        }\n      }\n      rec(this)\n    }\n  }\n  */\n\n}\n\n// Internal code that mutates `next` _must_ call `Statics.releaseFence()` if either immediately, or\n// before a newly-allocated, thread-local :: instance is aliased (e.g. in ListBuffer.toList)\nfinal case class :: [+A](override val head: A, private[scala] var next: List[A @uncheckedVariance]) // sound because `next` is used only locally\n  extends List[A] {\n  releaseFence()\n  override def headOption: Some[A] \u003d Some(head)\n  override def tail: List[A] \u003d next\n}\n\ncase object Nil extends List[Nothing] {\n  override def head: Nothing \u003d throw new NoSuchElementException(\"head of empty list\")\n  override def headOption: None.type \u003d None\n  override def tail: Nothing \u003d throw new UnsupportedOperationException(\"tail of empty list\")\n  override def last: Nothing \u003d throw new NoSuchElementException(\"last of empty list\")\n  override def init: Nothing \u003d throw new UnsupportedOperationException(\"init of empty list\")\n  override def knownSize: Int \u003d 0\n  override def iterator: Iterator[Nothing] \u003d Iterator.empty\n  override def unzip[A1, A2](implicit asPair: Nothing \u003d\u003e (A1, A2)): (List[A1], List[A2]) \u003d EmptyUnzip\n\n  @transient\n  private[this] val EmptyUnzip \u003d (Nil, Nil)\n}\n\n/**\n  * $factoryInfo\n  * @define coll list\n  * @define Coll `List`\n  */\n@SerialVersionUID(3L)\nobject List extends StrictOptimizedSeqFactory[List] {\n  private val TupleOfNil \u003d (Nil, Nil)\n\n  def from[B](coll: collection.IterableOnce[B]): List[B] \u003d Nil.prependedAll(coll)\n\n  def newBuilder[A]: Builder[A, List[A]] \u003d new ListBuffer()\n\n  def empty[A]: List[A] \u003d Nil\n\n  @transient\n  private[collection] val partialNotApplied \u003d new Function1[Any, Any] { def apply(x: Any): Any \u003d this }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 01:26:54 INFO  compiling root (2 scala sources)
2024.04.26 01:26:54 INFO  time: compiled root in 0.18s
2024.04.26 01:27:13 INFO  compiling root (2 scala sources)
2024.04.26 01:27:13 INFO  time: compiled root in 0.14s
2024.04.26 01:27:27 INFO  compiling root (2 scala sources)
2024.04.26 01:27:27 INFO  time: compiled root in 0.14s
2024.04.26 01:27:42 WARN  Using indexes to guess the definition of nextLPlus
2024.04.26 01:27:46 INFO  compiling root (2 scala sources)
2024.04.26 01:27:46 INFO  time: compiled root in 0.61s
2024.04.26 01:27:46 INFO  compiling root (1 scala source)
2024.04.26 01:27:46 INFO  time: compiled root in 88ms
2024.04.26 01:28:45 INFO  compiling root (5 scala sources)
2024.04.26 01:28:45 INFO  time: compiled root in 0.15s
2024.04.26 01:28:54 INFO  compiling root (5 scala sources)
2024.04.26 01:28:54 INFO  time: compiled root in 0.15s
Apr. 26, 2024 1:29:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 13073
Apr. 26, 2024 1:29:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 13076
Apr. 26, 2024 1:29:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Option.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 1:29:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 01:30:15 INFO  compiling root (5 scala sources)
2024.04.26 01:30:15 INFO  time: compiled root in 0.17s
2024.04.26 01:30:16 INFO  compiling root (5 scala sources)
2024.04.26 01:30:16 INFO  time: compiled root in 0.32s
2024.04.26 01:30:42 INFO  compiling root (5 scala sources)
2024.04.26 01:30:42 INFO  time: compiled root in 0.24s
2024.04.26 01:30:55 INFO  compiling root (5 scala sources)
2024.04.26 01:30:55 INFO  time: compiled root in 0.28s
2024.04.26 01:31:09 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 1:31:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Unit.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// DO NOT EDIT, CHANGES WILL BE LOST\n// This auto-generated code can be modified in \"project/GenerateAnyVals.scala\".\n// Afterwards, running \"sbt generateSources\" regenerates this source file.\n\npackage scala\n\n\n/** `Unit` is a subtype of [[scala.AnyVal]]. There is only one value of type\n *  `Unit`, `()`, and it is not represented by any object in the underlying\n *  runtime system. A method with return type `Unit` is analogous to a Java\n *  method which is declared `void`.\n */\nfinal abstract class Unit private extends AnyVal {\n  // Provide a more specific return type for Scaladoc\n  override def getClass(): Class[Unit] \u003d ???\n}\n\n@scala.annotation.compileTimeOnly(\"`Unit` companion object is not allowed in source; instead, use `()` for the unit value\")\nobject Unit extends AnyValCompanion {\n\n  /** Transform a value type into a boxed reference type.\n   *\n   *  This method is not intended for use in source code.\n   *  The runtime representation of this value is platform specific.\n   *\n   *  @param  x   the Unit to be boxed\n   *  @return     a scala.runtime.BoxedUnit offering `x` as its underlying value.\n   */\n  def box(x: Unit): scala.runtime.BoxedUnit \u003d scala.runtime.BoxedUnit.UNIT\n\n  /** Transform a boxed type into a value type.  Note that this\n   *  method is not typesafe: it accepts any Object, but will throw\n   *  an exception if the argument is not a scala.runtime.BoxedUnit.\n   *\n   *  This method is not intended for use in source code.\n   *  The result of successfully unboxing a value is `()`.\n   *\n   *  @param  x   the scala.runtime.BoxedUnit to be unboxed.\n   *  @throws     ClassCastException  if the argument is not a scala.runtime.BoxedUnit\n   *  @return     the Unit value ()\n   */\n  def unbox(x: java.lang.Object): Unit \u003d x.asInstanceOf[scala.runtime.BoxedUnit]\n\n  /** The String representation of the scala.Unit companion object. */\n  override def toString \u003d \"object scala.Unit\"\n}\n\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 1:31:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Unit.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 01:31:09 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 1:31:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Unit.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// DO NOT EDIT, CHANGES WILL BE LOST\n// This auto-generated code can be modified in \"project/GenerateAnyVals.scala\".\n// Afterwards, running \"sbt generateSources\" regenerates this source file.\n\npackage scala\n\n\n/** `Unit` is a subtype of [[scala.AnyVal]]. There is only one value of type\n *  `Unit`, `()`, and it is not represented by any object in the underlying\n *  runtime system. A method with return type `Unit` is analogous to a Java\n *  method which is declared `void`.\n */\nfinal abstract class Unit private extends AnyVal {\n  // Provide a more specific return type for Scaladoc\n  override def getClass(): Class[Unit] \u003d ???\n}\n\n@scala.annotation.compileTimeOnly(\"`Unit` companion object is not allowed in source; instead, use `()` for the unit value\")\nobject Unit extends AnyValCompanion {\n\n  /** Transform a value type into a boxed reference type.\n   *\n   *  This method is not intended for use in source code.\n   *  The runtime representation of this value is platform specific.\n   *\n   *  @param  x   the Unit to be boxed\n   *  @return     a scala.runtime.BoxedUnit offering `x` as its underlying value.\n   */\n  def box(x: Unit): scala.runtime.BoxedUnit \u003d scala.runtime.BoxedUnit.UNIT\n\n  /** Transform a boxed type into a value type.  Note that this\n   *  method is not typesafe: it accepts any Object, but will throw\n   *  an exception if the argument is not a scala.runtime.BoxedUnit.\n   *\n   *  This method is not intended for use in source code.\n   *  The result of successfully unboxing a value is `()`.\n   *\n   *  @param  x   the scala.runtime.BoxedUnit to be unboxed.\n   *  @throws     ClassCastException  if the argument is not a scala.runtime.BoxedUnit\n   *  @return     the Unit value ()\n   */\n  def unbox(x: java.lang.Object): Unit \u003d x.asInstanceOf[scala.runtime.BoxedUnit]\n\n  /** The String representation of the scala.Unit companion object. */\n  override def toString \u003d \"object scala.Unit\"\n}\n\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 01:32:14 INFO  compiling root (5 scala sources)
2024.04.26 01:32:14 INFO  time: compiled root in 0.26s
2024.04.26 01:32:48 INFO  compiling root (5 scala sources)
2024.04.26 01:32:48 INFO  time: compiled root in 0.24s
2024.04.26 01:33:00 INFO  compiling root (5 scala sources)
2024.04.26 01:33:00 INFO  time: compiled root in 0.26s
2024.04.26 01:33:03 INFO  compiling root (5 scala sources)
2024.04.26 01:33:03 INFO  time: compiled root in 0.28s
2024.04.26 01:33:09 INFO  compiling root (5 scala sources)
2024.04.26 01:33:09 INFO  time: compiled root in 0.26s
2024.04.26 01:33:13 INFO  compiling root (5 scala sources)
2024.04.26 01:33:13 INFO  time: compiled root in 0.22s
2024.04.26 01:33:30 WARN  Using indexes to guess the definition of printBoard
2024.04.26 01:33:30 INFO  compiling root (5 scala sources)
2024.04.26 01:33:30 INFO  time: compiled root in 0.15s
Apr. 26, 2024 1:34:08 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 13853
Apr. 26, 2024 1:34:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Unit.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Unit.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 01:34:24 INFO  compiling root (5 scala sources)
2024.04.26 01:34:24 INFO  time: compiled root in 0.16s
2024.04.26 01:34:35 INFO  compiling root (5 scala sources)
2024.04.26 01:34:35 INFO  time: compiled root in 0.16s
2024.04.26 01:35:09 INFO  compiling root (5 scala sources)
2024.04.26 01:35:09 INFO  time: compiled root in 0.17s
2024.04.26 01:35:10 INFO  compiling root (5 scala sources)
2024.04.26 01:35:10 INFO  time: compiled root in 0.2s
2024.04.26 01:35:10 INFO  compiling root (5 scala sources)
2024.04.26 01:35:10 INFO  time: compiled root in 0.16s
2024.04.26 01:35:18 INFO  compiling root (5 scala sources)
2024.04.26 01:35:18 INFO  time: compiled root in 0.16s
2024.04.26 01:35:24 INFO  compiling root (5 scala sources)
2024.04.26 01:35:24 INFO  time: compiled root in 0.17s
2024.04.26 01:35:28 INFO  compiling root (5 scala sources)
2024.04.26 01:35:28 INFO  time: compiled root in 0.14s
2024.04.26 01:36:05 INFO  compiling root (5 scala sources)
2024.04.26 01:36:05 INFO  time: compiled root in 0.15s
2024.04.26 01:36:13 INFO  compiling root (5 scala sources)
2024.04.26 01:36:13 INFO  time: compiled root in 0.14s
2024.04.26 01:36:49 INFO  compiling root (5 scala sources)
2024.04.26 01:36:49 INFO  time: compiled root in 0.14s
2024.04.26 01:37:03 INFO  compiling root (5 scala sources)
2024.04.26 01:37:03 INFO  time: compiled root in 0.45s
2024.04.26 01:37:12 INFO  compiling root (1 scala source)
2024.04.26 01:37:12 INFO  time: compiled root in 0.12s
2024.04.26 01:38:08 INFO  compiling root (1 scala source)
2024.04.26 01:38:08 INFO  time: compiled root in 0.1s
2024.04.26 01:38:08 INFO  compiling root (1 scala source)
2024.04.26 01:38:08 INFO  time: compiled root in 0.11s
2024.04.26 01:38:16 INFO  compiling root (1 scala source)
2024.04.26 01:38:16 INFO  time: compiled root in 0.12s
2024.04.26 01:38:20 INFO  compiling root (1 scala source)
2024.04.26 01:38:20 INFO  time: compiled root in 0.11s
2024.04.26 01:38:27 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 2h 32m 0.287s)
2024.04.26 01:38:27 INFO  compiling root-test (3 scala sources)
2024.04.26 01:38:27 INFO  time: compiled root-test in 0.27s
2024.04.26 01:38:28 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 01:38:28 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 01:38:28 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 01:38:27 INFO  Loaded expression compiler in 1 millisecond
2024.04.26 01:38:27 INFO  Loaded step filter in 0 milliseconds
2024.04.26 01:38:29 INFO  Loaded all sources and classes in 1 second
2024.04.26 01:38:29 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:64151 .
2024.04.26 01:38:29 INFO  Attaching to debuggee VM succeeded.
2024.04.26 01:38:30 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 01:38:29 INFO  Closing debug server tcp://0.0.0.0:64149
2024.04.26 01:38:48 INFO  compiling root (1 scala source)
2024.04.26 01:38:48 INFO  time: compiled root in 0.12s
2024.04.26 01:38:51 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 2h 32m 23.81s)
2024.04.26 01:38:51 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 01:38:51 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 01:38:51 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 01:38:51 INFO  Loaded expression compiler in 0 milliseconds
2024.04.26 01:38:51 INFO  Loaded step filter in 0 milliseconds
2024.04.26 01:38:52 INFO  Loaded all sources and classes in 1 second
2024.04.26 01:38:52 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:64167 .
2024.04.26 01:38:52 INFO  Attaching to debuggee VM succeeded.
2024.04.26 01:38:53 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 01:38:53 INFO  Closing debug server tcp://0.0.0.0:64165
2024.04.26 01:39:25 INFO  compiling root (1 scala source)
2024.04.26 01:39:25 INFO  time: compiled root in 0.22s
2024.04.26 01:39:34 INFO  compiling root (1 scala source)
2024.04.26 01:39:34 INFO  time: compiled root in 0.2s
2024.04.26 01:39:34 INFO  compiling root (1 scala source)
2024.04.26 01:39:34 INFO  time: compiled root in 0.11s
2024.04.26 01:39:38 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 2h 33m 11.122s)
2024.04.26 01:39:38 INFO  compiling root-test (3 scala sources)
2024.04.26 01:39:38 INFO  time: compiled root-test in 0.23s
2024.04.26 01:39:39 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 01:39:39 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 01:39:39 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 01:39:38 INFO  Loaded expression compiler in 0 milliseconds
2024.04.26 01:39:38 INFO  Loaded step filter in 0 milliseconds
2024.04.26 01:39:40 INFO  Loaded all sources and classes in 1 second
2024.04.26 01:39:40 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:64191 .
2024.04.26 01:39:40 INFO  Attaching to debuggee VM succeeded.
2024.04.26 01:39:41 INFO  Closing debug server tcp://0.0.0.0:64189
2024.04.26 01:39:41 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 01:40:26 INFO  compiling root (1 scala source)
2024.04.26 01:40:26 INFO  time: compiled root in 0.27s
2024.04.26 01:40:29 INFO  compiling root-test (3 scala sources)
2024.04.26 01:40:29 INFO  time: compiled root-test in 0.21s
2024.04.26 01:40:29 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 01:40:29 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 01:40:29 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 01:40:29 INFO  Loaded expression compiler in 0 milliseconds
2024.04.26 01:40:29 INFO  Loaded step filter in 0 milliseconds
2024.04.26 01:40:31 INFO  Loaded all sources and classes in 1 second
2024.04.26 01:40:31 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:64220 .
2024.04.26 01:40:31 INFO  Attaching to debuggee VM succeeded.
2024.04.26 01:40:31 INFO  Closing debug server tcp://0.0.0.0:64217
2024.04.26 01:40:31 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 01:40:49 INFO  compiling root (1 scala source)
2024.04.26 01:40:49 INFO  time: compiled root in 0.12s
2024.04.26 01:41:27 INFO  compiling root (1 scala source)
2024.04.26 01:41:27 INFO  time: compiled root in 0.21s
2024.04.26 01:41:31 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 2h 35m 3.405s)
2024.04.26 01:41:31 INFO  compiling root-test (3 scala sources)
2024.04.26 01:41:31 INFO  time: compiled root-test in 0.27s
2024.04.26 01:41:31 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 01:41:31 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 01:41:31 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 01:41:31 INFO  Loaded expression compiler in 0 milliseconds
2024.04.26 01:41:31 INFO  Loaded step filter in 0 milliseconds
2024.04.26 01:41:32 INFO  Loaded all sources and classes in 1 second
2024.04.26 01:41:32 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:64254 .
2024.04.26 01:41:32 INFO  Attaching to debuggee VM succeeded.
2024.04.26 01:41:32 INFO  Closing debug server tcp://0.0.0.0:64252
2024.04.26 01:41:33 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 01:41:58 INFO  compiling root (1 scala source)
2024.04.26 01:41:58 INFO  time: compiled root in 0.23s
2024.04.26 01:42:01 INFO  compiling root-test (3 scala sources)
2024.04.26 01:42:01 INFO  time: compiled root-test in 0.29s
2024.04.26 01:42:01 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 01:42:01 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 01:42:01 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 01:42:01 INFO  Loaded expression compiler in 0 milliseconds
2024.04.26 01:42:01 INFO  Loaded step filter in 0 milliseconds
2024.04.26 01:42:03 INFO  Loaded all sources and classes in 1 second
2024.04.26 01:42:03 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:64274 .
2024.04.26 01:42:03 INFO  Attaching to debuggee VM succeeded.
2024.04.26 01:42:04 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 01:42:04 INFO  Closing debug server tcp://0.0.0.0:64271
2024.04.26 01:42:49 INFO  compiling root-test (3 scala sources)
2024.04.26 01:42:49 INFO  time: compiled root-test in 0.18s
2024.04.26 01:42:49 INFO  compiling root (1 scala source)
2024.04.26 01:42:49 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 2h 36m 21.918s)
2024.04.26 01:42:49 INFO  compiling root (1 scala source)
2024.04.26 01:42:49 INFO  compiling root-test (3 scala sources)
2024.04.26 01:42:49 INFO  time: compiled root in 0.17s
2024.04.26 01:42:49 INFO  time: compiled root-test in 0.28s
2024.04.26 01:42:51 INFO  compiling root-test (3 scala sources)
2024.04.26 01:42:51 INFO  time: compiled root-test in 0.21s
2024.04.26 01:42:51 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 01:42:51 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 01:42:51 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 01:42:51 INFO  Loaded expression compiler in 0 milliseconds
2024.04.26 01:42:51 INFO  Loaded step filter in 0 milliseconds
2024.04.26 01:42:52 INFO  Loaded all sources and classes in 1 second
2024.04.26 01:42:52 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:64300 .
2024.04.26 01:42:52 INFO  Attaching to debuggee VM succeeded.
2024.04.26 01:42:53 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 01:42:52 INFO  Closing debug server tcp://0.0.0.0:64297
Apr. 26, 2024 1:45:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 14982
2024.04.26 01:48:39 INFO  compiling root (1 scala source)
2024.04.26 01:48:39 INFO  time: compiled root in 0.13s
2024.04.26 01:48:40 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
2024.04.26 01:48:45 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
2024.04.26 01:48:46 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
2024.04.26 01:48:47 INFO  compiling root (1 scala source)
2024.04.26 01:48:47 INFO  time: compiled root in 0.24s
2024.04.26 01:48:50 INFO  compiling root-test (3 scala sources)
2024.04.26 01:48:50 INFO  time: compiled root-test in 0.35s
2024.04.26 01:48:50 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 01:48:50 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 01:48:50 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 01:48:50 INFO  Loaded expression compiler in 0 milliseconds
2024.04.26 01:48:50 INFO  Loaded step filter in 0 milliseconds
2024.04.26 01:48:51 INFO  Loaded all sources and classes in 1 second
2024.04.26 01:48:51 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:64492 .
2024.04.26 01:48:51 INFO  Attaching to debuggee VM succeeded.
2024.04.26 01:48:52 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 01:48:51 INFO  Closing debug server tcp://0.0.0.0:64489
2024.04.26 01:49:17 INFO  compiling root (1 scala source)
2024.04.26 01:49:17 INFO  time: compiled root in 0.25s
2024.04.26 01:49:17 INFO  compiling root (1 scala source)
2024.04.26 01:49:17 INFO  time: compiled root in 0.13s
2024.04.26 01:49:17 INFO  compiling root (1 scala source)
2024.04.26 01:49:17 INFO  time: compiled root in 0.13s
2024.04.26 01:49:17 INFO  compiling root (1 scala source)
2024.04.26 01:49:18 INFO  time: compiled root in 0.42s
2024.04.26 01:49:18 INFO  {
  "jsonrpc": "2.0",
  "id": "807",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.26 01:49:18 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:509)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:509)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:484)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 01:49:28 INFO  compiling root (1 scala source)
2024.04.26 01:49:28 INFO  time: compiled root in 0.19s
2024.04.26 01:49:30 INFO  compiling root-test (3 scala sources)
2024.04.26 01:49:30 INFO  time: compiled root-test in 0.42s
2024.04.26 01:49:31 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 01:49:31 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 01:49:31 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 01:49:30 INFO  Loaded expression compiler in 0 milliseconds
2024.04.26 01:49:30 INFO  Loaded step filter in 0 milliseconds
2024.04.26 01:49:32 INFO  Loaded all sources and classes in 1 second
2024.04.26 01:49:33 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:64521 .
2024.04.26 01:49:33 INFO  Attaching to debuggee VM succeeded.
2024.04.26 01:49:34 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 01:49:33 INFO  Closing debug server tcp://0.0.0.0:64518
2024.04.26 01:57:49 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:36: error: unclosed comment
    /*sr.append(space*2 + "A" + space * 2 +
    ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:55)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:74)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:316)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 01:57:52 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:36: error: unclosed comment
    /*sr.append(space*2 + "A" + space * 2 +
    ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:55)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:74)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:316)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 01:57:55 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:36: error: unclosed comment
    /*sr.append(space*2 + "A" + space * 2 +
    ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:55)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:74)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:316)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 01:57:56 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:36: error: unclosed comment
    /*sr.append(space*2 + "A" + space * 2 +
    ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:55)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:74)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:316)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 01:57:56 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:36: error: unclosed comment
    /*sr.append(space*2 + "A" + space * 2 +
    ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:55)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:74)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:316)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 01:57:56 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:36: error: unclosed comment
    /*sr.append(space*2 + "A" + space * 2 +
    ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:55)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:74)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:316)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 01:57:58 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:36: error: unclosed comment
    /*sr.append(space*2 + "A" + space * 2 +
    ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:55)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:74)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:316)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

Apr. 26, 2024 2:04:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 15820
Apr. 26, 2024 2:05:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 15866
2024.04.26 02:05:20 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 2:05:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// DO NOT EDIT, CHANGES WILL BE LOST\n// This auto-generated code can be modified in \"project/GenerateAnyVals.scala\".\n// Afterwards, running \"sbt generateSources\" regenerates this source file.\n\npackage scala\n\n/** `Int`, a 32-bit signed integer (equivalent to Java\u0027s `int` primitive type) is a\n *  subtype of [[scala.AnyVal]]. Instances of `Int` are not\n *  represented by an object in the underlying runtime system.\n *\n *  There is an implicit conversion from [[scala.Int]] \u003d\u003e [[scala.runtime.RichInt]]\n *  which provides useful non-primitive operations.\n */\nfinal abstract class Int private extends AnyVal {\n  def toByte: Byte\n  def toShort: Short\n  def toChar: Char\n  def toInt: Int\n  def toLong: Long\n  def toFloat: Float\n  def toDouble: Double\n\n  /**\n * Returns the bitwise negation of this value.\n * @example {{{\n * ~5 \u003d\u003d -6\n * // in binary: ~00000101 \u003d\u003d\n * //             11111010\n * }}}\n */\n  def unary_~ : Int\n  /** Returns this value, unmodified. */\n  def unary_+ : Int\n  /** Returns the negation of this value. */\n  def unary_- : Int\n\n  @deprecated(\"Adding a number and a String is deprecated. Use the string interpolation `s\\\"$num$str\\\"`\", \"2.13.0\")\n  def +(x: String): String\n\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  def \u003c\u003c(x: Int): Int\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003c\u003c(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e\u003e(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e(x: Long): Int\n\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Short): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Char): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Int): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Long): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Float): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Short): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Char): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Int): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Long): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Float): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Byte): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Short): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Char): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Int): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Long): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Float): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Double): Boolean\n\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Short): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Char): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Int): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Long): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Float): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Byte): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Short): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Char): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Int): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Long): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Float): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Short): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Char): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Int): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Long): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Float): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Double): Boolean\n\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Byte): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Short): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Char): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Int): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Long): Long\n\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Byte): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Short): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Char): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Int): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Long): Long\n\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Byte): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Short): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Char): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Int): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Long): Long\n\n  /** Returns the sum of this value and `x`. */\n  def +(x: Byte): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Short): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Char): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Int): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Long): Long\n  /** Returns the sum of this value and `x`. */\n  def +(x: Float): Float\n  /** Returns the sum of this value and `x`. */\n  def +(x: Double): Double\n\n  /** Returns the difference of this value and `x`. */\n  def -(x: Byte): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Short): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Char): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Int): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Long): Long\n  /** Returns the difference of this value and `x`. */\n  def -(x: Float): Float\n  /** Returns the difference of this value and `x`. */\n  def -(x: Double): Double\n\n  /** Returns the product of this value and `x`. */\n  def *(x: Byte): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Short): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Char): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Int): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Long): Long\n  /** Returns the product of this value and `x`. */\n  def *(x: Float): Float\n  /** Returns the product of this value and `x`. */\n  def *(x: Double): Double\n\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Byte): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Short): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Char): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Int): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Long): Long\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Float): Float\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Double): Double\n\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Byte): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Short): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Char): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Int): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Long): Long\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Float): Float\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Double): Double\n\n  // Provide a more specific return type for Scaladoc\n  override def getClass(): Class[Int] \u003d ???\n}\n\nobject Int extends AnyValCompanion {\n  /** The smallest value representable as an Int. */\n  final val MinValue \u003d java.lang.Integer.MIN_VALUE\n\n  /** The largest value representable as an Int. */\n  final val MaxValue \u003d java.lang.Integer.MAX_VALUE\n\n  /** Transform a value type into a boxed reference type.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.boxToInteger`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the Int to be boxed\n   *  @return     a java.lang.Integer offering `x` as its underlying value.\n   */\n  def box(x: Int): java.lang.Integer \u003d ???\n\n  /** Transform a boxed type into a value type.  Note that this\n   *  method is not typesafe: it accepts any Object, but will throw\n   *  an exception if the argument is not a java.lang.Integer.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.unboxToInt`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the java.lang.Integer to be unboxed.\n   *  @throws     ClassCastException  if the argument is not a java.lang.Integer\n   *  @return     the Int resulting from calling intValue() on `x`\n   */\n  def unbox(x: java.lang.Object): Int \u003d ???\n\n  /** The String representation of the scala.Int companion object. */\n  override def toString \u003d \"object scala.Int\"\n  /** Language mandated coercions from Int to \"wider\" types. */\n  import scala.language.implicitConversions\n  @deprecated(\"Implicit conversion from Int to Float is dangerous because it loses precision. Write `.toFloat` instead.\", \"2.13.1\")\n  implicit def int2float(x: Int): Float \u003d x.toFloat\n  implicit def int2long(x: Int): Long \u003d x.toLong\n  implicit def int2double(x: Int): Double \u003d x.toDouble\n}\n\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 2:05:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:05:20 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 2:05:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// DO NOT EDIT, CHANGES WILL BE LOST\n// This auto-generated code can be modified in \"project/GenerateAnyVals.scala\".\n// Afterwards, running \"sbt generateSources\" regenerates this source file.\n\npackage scala\n\n/** `Int`, a 32-bit signed integer (equivalent to Java\u0027s `int` primitive type) is a\n *  subtype of [[scala.AnyVal]]. Instances of `Int` are not\n *  represented by an object in the underlying runtime system.\n *\n *  There is an implicit conversion from [[scala.Int]] \u003d\u003e [[scala.runtime.RichInt]]\n *  which provides useful non-primitive operations.\n */\nfinal abstract class Int private extends AnyVal {\n  def toByte: Byte\n  def toShort: Short\n  def toChar: Char\n  def toInt: Int\n  def toLong: Long\n  def toFloat: Float\n  def toDouble: Double\n\n  /**\n * Returns the bitwise negation of this value.\n * @example {{{\n * ~5 \u003d\u003d -6\n * // in binary: ~00000101 \u003d\u003d\n * //             11111010\n * }}}\n */\n  def unary_~ : Int\n  /** Returns this value, unmodified. */\n  def unary_+ : Int\n  /** Returns the negation of this value. */\n  def unary_- : Int\n\n  @deprecated(\"Adding a number and a String is deprecated. Use the string interpolation `s\\\"$num$str\\\"`\", \"2.13.0\")\n  def +(x: String): String\n\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  def \u003c\u003c(x: Int): Int\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003c\u003c(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e\u003e(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e(x: Long): Int\n\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Short): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Char): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Int): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Long): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Float): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Short): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Char): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Int): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Long): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Float): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Byte): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Short): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Char): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Int): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Long): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Float): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Double): Boolean\n\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Short): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Char): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Int): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Long): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Float): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Byte): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Short): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Char): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Int): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Long): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Float): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Short): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Char): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Int): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Long): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Float): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Double): Boolean\n\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Byte): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Short): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Char): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Int): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Long): Long\n\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Byte): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Short): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Char): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Int): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Long): Long\n\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Byte): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Short): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Char): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Int): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Long): Long\n\n  /** Returns the sum of this value and `x`. */\n  def +(x: Byte): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Short): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Char): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Int): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Long): Long\n  /** Returns the sum of this value and `x`. */\n  def +(x: Float): Float\n  /** Returns the sum of this value and `x`. */\n  def +(x: Double): Double\n\n  /** Returns the difference of this value and `x`. */\n  def -(x: Byte): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Short): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Char): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Int): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Long): Long\n  /** Returns the difference of this value and `x`. */\n  def -(x: Float): Float\n  /** Returns the difference of this value and `x`. */\n  def -(x: Double): Double\n\n  /** Returns the product of this value and `x`. */\n  def *(x: Byte): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Short): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Char): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Int): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Long): Long\n  /** Returns the product of this value and `x`. */\n  def *(x: Float): Float\n  /** Returns the product of this value and `x`. */\n  def *(x: Double): Double\n\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Byte): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Short): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Char): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Int): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Long): Long\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Float): Float\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Double): Double\n\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Byte): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Short): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Char): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Int): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Long): Long\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Float): Float\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Double): Double\n\n  // Provide a more specific return type for Scaladoc\n  override def getClass(): Class[Int] \u003d ???\n}\n\nobject Int extends AnyValCompanion {\n  /** The smallest value representable as an Int. */\n  final val MinValue \u003d java.lang.Integer.MIN_VALUE\n\n  /** The largest value representable as an Int. */\n  final val MaxValue \u003d java.lang.Integer.MAX_VALUE\n\n  /** Transform a value type into a boxed reference type.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.boxToInteger`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the Int to be boxed\n   *  @return     a java.lang.Integer offering `x` as its underlying value.\n   */\n  def box(x: Int): java.lang.Integer \u003d ???\n\n  /** Transform a boxed type into a value type.  Note that this\n   *  method is not typesafe: it accepts any Object, but will throw\n   *  an exception if the argument is not a java.lang.Integer.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.unboxToInt`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the java.lang.Integer to be unboxed.\n   *  @throws     ClassCastException  if the argument is not a java.lang.Integer\n   *  @return     the Int resulting from calling intValue() on `x`\n   */\n  def unbox(x: java.lang.Object): Int \u003d ???\n\n  /** The String representation of the scala.Int companion object. */\n  override def toString \u003d \"object scala.Int\"\n  /** Language mandated coercions from Int to \"wider\" types. */\n  import scala.language.implicitConversions\n  @deprecated(\"Implicit conversion from Int to Float is dangerous because it loses precision. Write `.toFloat` instead.\", \"2.13.1\")\n  implicit def int2float(x: Int): Float \u003d x.toFloat\n  implicit def int2long(x: Int): Long \u003d x.toLong\n  implicit def int2double(x: Int): Double \u003d x.toDouble\n}\n\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:05:30 INFO  Shutting down server
2024.04.26 02:05:30 INFO  shutting down Metals
2024.04.26 02:05:30 INFO  Shut down connection with build server.
2024.04.26 02:05:30 INFO  Shut down connection with build server.
Apr. 26, 2024 2:05:30 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint notify
INFORMATION: Failed to send notification message.
org.eclipse.lsp4j.jsonrpc.JsonRpcException: java.nio.channels.ClosedChannelException
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:72)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.notify(RemoteEndpoint.java:126)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.sendCancelNotification(RemoteEndpoint.java:180)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint$1.cancel(RemoteEndpoint.java:150)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.$anonfun$cancel$1(FutureWithTimeout.scala:37)
	at scala.runtime.java8.JFunction0$mcZ$sp.apply(JFunction0$mcZ$sp.scala:17)
	at scala.util.Try$.apply(Try.scala:217)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.cancel(FutureWithTimeout.scala:37)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.utils.RequestRegistry.cancel(RequestRegistry.scala:94)
	at scala.meta.internal.metals.BuildServerConnection.cancel(BuildServerConnection.scala:411)
	at scala.meta.internal.bsp.BspSession.$anonfun$cancel$1(BspSession.scala:34)
	at scala.meta.internal.bsp.BspSession.$anonfun$cancel$1$adapted(BspSession.scala:34)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.bsp.BspSession.cancel(BspSession.scala:34)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.MetalsLspService.cancel(MetalsLspService.scala:161)
	at scala.meta.internal.metals.MetalsLspService.onShutdown(MetalsLspService.scala:953)
	at scala.meta.internal.metals.WorkspaceLspService.$anonfun$shutdown$2(WorkspaceLspService.scala:1214)
	at scala.meta.internal.metals.WorkspaceLspService.$anonfun$shutdown$2$adapted(WorkspaceLspService.scala:1214)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.metals.WorkspaceLspService.shutdown(WorkspaceLspService.scala:1214)
	at scala.meta.metals.MetalsLanguageServer.shutdown(MetalsLanguageServer.scala:260)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.nio.channels.ClosedChannelException
	at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:222)
	at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:536)
	at java.base/sun.nio.ch.SinkChannelImpl.write(SinkChannelImpl.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.writeFully(ChannelOutputStream.java:68)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:102)
	at java.base/java.io.OutputStream.write(OutputStream.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:79)
	at scala.meta.internal.metals.ClosableOutputStream.write(ClosableOutputStream.scala:26)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:137)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:108)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:67)
	... 43 more

2024.04.26 02:05:30 INFO  Cancelling compilation on Bloop server
2024.04.26 02:05:30 INFO  Cancelling compilation on Bloop server
2024.04.26 02:05:30 INFO  Cancelling compilation on Bloop server
2024.04.26 02:05:30 INFO  Cancelling compilation on Bloop server
2024.04.26 02:05:30 INFO  Cancelling compilation on Bloop server
2024.04.26 02:05:30 INFO  Cancelling compilation on Bloop server
2024.04.26 02:05:30 INFO  Cancelling compilation on Bloop server
2024.04.26 02:05:30 INFO  Cancelling compilation on Bloop server
2024.04.26 02:05:30 INFO  Cancelling compilation on Bloop server
2024.04.26 02:05:30 INFO  Cancelling compilation on Bloop server
2024.04.26 02:05:30 INFO  Failed to run request with params DebugSessionAddress
2024.04.26 02:05:30 ERROR failed: Starting debug server
java.util.concurrent.CancellationException
	at java.util.concurrent.CompletableFuture.cancel(CompletableFuture.java:2510)
	at scala.meta.internal.metals.CancelTokens$$anon$1.cancel(CancelTokens.scala:35)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$startDebugSession$3(BuildServerConnection.scala:266)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$startDebugSession$3$adapted(BuildServerConnection.scala:266)
	at scala.util.Success.foreach(Try.scala:268)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:481)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:05:30 INFO  Failed to run request with params DebugSessionAddress
2024.04.26 02:05:30 INFO  Failed to run request with params DebugSessionAddress
2024.04.26 02:05:30 ERROR failed: Starting debug server
java.util.concurrent.CancellationException
	at java.util.concurrent.CompletableFuture.cancel(CompletableFuture.java:2510)
	at scala.meta.internal.metals.CancelTokens$$anon$1.cancel(CancelTokens.scala:35)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$startDebugSession$3(BuildServerConnection.scala:266)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$startDebugSession$3$adapted(BuildServerConnection.scala:266)
	at scala.util.Success.foreach(Try.scala:268)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:481)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:05:30 INFO  Failed to run request with params DebugSessionAddress
2024.04.26 02:05:30 ERROR failed: Starting debug server
java.util.concurrent.CancellationException
	at java.util.concurrent.CompletableFuture.cancel(CompletableFuture.java:2510)
	at scala.meta.internal.metals.CancelTokens$$anon$1.cancel(CancelTokens.scala:35)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$startDebugSession$3(BuildServerConnection.scala:266)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$startDebugSession$3$adapted(BuildServerConnection.scala:266)
	at scala.util.Success.foreach(Try.scala:268)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:481)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:05:30 INFO  Failed to run request with params DebugSessionAddress
2024.04.26 02:05:30 ERROR failed: Starting debug server
java.util.concurrent.CancellationException
	at java.util.concurrent.CompletableFuture.cancel(CompletableFuture.java:2510)
	at scala.meta.internal.metals.CancelTokens$$anon$1.cancel(CancelTokens.scala:35)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$startDebugSession$3(BuildServerConnection.scala:266)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$startDebugSession$3$adapted(BuildServerConnection.scala:266)
	at scala.util.Success.foreach(Try.scala:268)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:481)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:05:30 ERROR failed: Starting debug server
java.util.concurrent.CancellationException
	at java.util.concurrent.CompletableFuture.cancel(CompletableFuture.java:2510)
	at scala.meta.internal.metals.CancelTokens$$anon$1.cancel(CancelTokens.scala:35)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$startDebugSession$3(BuildServerConnection.scala:266)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$startDebugSession$3$adapted(BuildServerConnection.scala:266)
	at scala.util.Success.foreach(Try.scala:268)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:481)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:05:30 INFO  Failed to run request with params DebugSessionAddress
2024.04.26 02:05:30 ERROR failed: Starting debug server
java.util.concurrent.CancellationException
	at java.util.concurrent.CompletableFuture.cancel(CompletableFuture.java:2510)
	at scala.meta.internal.metals.CancelTokens$$anon$1.cancel(CancelTokens.scala:35)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$startDebugSession$3(BuildServerConnection.scala:266)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$startDebugSession$3$adapted(BuildServerConnection.scala:266)
	at scala.util.Success.foreach(Try.scala:268)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:481)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:05:30 INFO  Exiting server
2024.04.26 02:05:46 INFO  Started: Metals version 1.3.0 in folders 'C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG' for client Visual Studio Code 1.88.1.
SLF4J: Class path contains multiple SLF4J providers.
SLF4J: Found provider [scribe.slf4j.ScribeServiceProvider@5845859d]
SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@23aef418]
SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual provider is of type [scribe.slf4j.ScribeServiceProvider@5845859d]
2024.04.26 02:05:48 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.04.26 02:05:49 INFO  Attempting to connect to the build server...
2024.04.26 02:05:49 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.26 02:05:49 INFO  Attempting to connect to the build server...
2024.04.26 02:05:49 INFO  Attempting to connect to the build server...
2024.04.26 02:05:49 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\project\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.26 02:05:49 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.26 02:05:49 INFO  time: Connected to build server in 0.78s
2024.04.26 02:05:49 INFO  Connected to Build server: Bloop v1.5.17
Apr. 26, 2024 2:05:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3
Apr. 26, 2024 2:05:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4
Apr. 26, 2024 2:05:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1
2024.04.26 02:05:50 INFO  time: Imported build in 0.46s
2024.04.26 02:06:01 INFO  no build target found for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.04.26 02:06:12 INFO  Shutting down server
2024.04.26 02:06:12 INFO  shutting down Metals
2024.04.26 02:06:12 INFO  Shut down connection with build server.
2024.04.26 02:06:12 INFO  Shut down connection with build server.
2024.04.26 02:06:12 INFO  Shut down connection with build server.
2024.04.26 02:06:12 ERROR error processing file:///C:/Users/Gewin%20Singh/AppData/Local/Coursier/Cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.12.18/scala-library-2.12.18-sources.jar
org.h2.jdbc.JdbcSQLNonTransientConnectionException: Die Datenbank wurde bereits geschlossen (um das automatische Schliessen beim Stopp der VM zu deaktivieren, die Datenbank URL mit ";DB_CLOSE_ON_EXIT=FALSE" ergänzen)
Database is already closed (to disable automatic closing at VM shutdown, add ";DB_CLOSE_ON_EXIT=FALSE" to the db URL) [90121-224]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:690)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:489)
	at org.h2.message.DbException.get(DbException.java:223)
	at org.h2.message.DbException.get(DbException.java:199)
	at org.h2.message.DbException.get(DbException.java:188)
	at org.h2.jdbc.JdbcConnection.checkClosed(JdbcConnection.java:1425)
	at org.h2.jdbc.JdbcStatement.checkClosed(JdbcStatement.java:1289)
	at org.h2.jdbc.JdbcResultSet.checkClosed(JdbcResultSet.java:3539)
	at org.h2.jdbc.JdbcResultSet.checkColumnIndex(JdbcResultSet.java:3522)
	at org.h2.jdbc.JdbcResultSet.getBoolean(JdbcResultSet.java:580)
	at scala.meta.internal.metals.JarTopLevels.$anonfun$getTypeHierarchy$2(JarTopLevels.scala:79)
	at scala.meta.internal.metals.JdbcEnrichments$XtensionConnection.query(JdbcEnrichments.scala:40)
	at scala.meta.internal.metals.JarTopLevels.getTypeHierarchy(JarTopLevels.scala:71)
	at scala.meta.internal.metals.Indexer.addSourceJarSymbols(Indexer.scala:647)
	at scala.meta.internal.metals.Indexer.$anonfun$indexDependencySources$5(Indexer.scala:487)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:935)
	at scala.collection.IterableOps$WithFilter.foreach(Iterable.scala:905)
	at scala.meta.internal.metals.Indexer.$anonfun$indexDependencySources$1(Indexer.scala:478)
	at scala.meta.internal.metals.Indexer.$anonfun$indexDependencySources$1$adapted(Indexer.scala:477)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:935)
	at scala.meta.internal.metals.Indexer.indexDependencySources(Indexer.scala:477)
	at scala.meta.internal.metals.Indexer.$anonfun$indexWorkspace$24(Indexer.scala:396)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.Indexer.$anonfun$indexWorkspace$23(Indexer.scala:389)
	at scala.meta.internal.metals.Indexer.$anonfun$indexWorkspace$23$adapted(Indexer.scala:385)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.metals.Indexer.indexWorkspace(Indexer.scala:385)
	at scala.meta.internal.metals.Indexer.$anonfun$profiledIndexWorkspace$2(Indexer.scala:172)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.Indexer.$anonfun$profiledIndexWorkspace$1(Indexer.scala:172)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:06:12 INFO  Exiting server
2024.04.26 02:06:22 INFO  Started: Metals version 1.3.0 in folders 'C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG' for client Visual Studio Code 1.88.1.
2024.04.26 02:06:23 INFO  Shutting down server
2024.04.26 02:06:23 INFO  shutting down Metals
SLF4J: Class path contains multiple SLF4J providers.
SLF4J: Found provider [scribe.slf4j.ScribeServiceProvider@4a9bfaed]
SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@46a95a93]
SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual provider is of type [scribe.slf4j.ScribeServiceProvider@4a9bfaed]
2024.04.26 02:06:25 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.04.26 02:06:25 INFO  Exiting server
2024.04.26 02:06:34 INFO  Started: Metals version 1.3.0 in folders 'C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG' for client Visual Studio Code 1.88.1.
SLF4J: Class path contains multiple SLF4J providers.
SLF4J: Found provider [scribe.slf4j.ScribeServiceProvider@71b05b57]
SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@7112ccd4]
SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual provider is of type [scribe.slf4j.ScribeServiceProvider@71b05b57]
2024.04.26 02:06:35 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.04.26 02:06:35 INFO  Attempting to connect to the build server...
2024.04.26 02:06:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.26 02:06:35 INFO  Attempting to connect to the build server...
2024.04.26 02:06:35 INFO  Attempting to connect to the build server...
2024.04.26 02:06:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\project\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.26 02:06:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.26 02:06:35 INFO  time: Connected to build server in 0.67s
2024.04.26 02:06:35 INFO  Connected to Build server: Bloop v1.5.17
2024.04.26 02:06:36 INFO  time: Imported build in 0.36s
Apr. 26, 2024 2:06:38 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
2024.04.26 02:07:07 INFO  time: indexed workspace in 30s
2024.04.26 02:07:45 INFO  Shutting down server
2024.04.26 02:07:45 INFO  shutting down Metals
2024.04.26 02:07:45 INFO  Shut down connection with build server.
2024.04.26 02:07:45 INFO  Shut down connection with build server.
2024.04.26 02:07:45 INFO  Shut down connection with build server.
2024.04.26 02:07:45 INFO  Exiting server
2024.04.26 02:11:26 INFO  Started: Metals version 1.3.0 in folders 'C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG' for client Visual Studio Code 1.88.1.
SLF4J: Class path contains multiple SLF4J providers.
SLF4J: Found provider [scribe.slf4j.ScribeServiceProvider@4e968aed]
SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@4ac4df29]
SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual provider is of type [scribe.slf4j.ScribeServiceProvider@4e968aed]
2024.04.26 02:11:26 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.04.26 02:11:27 INFO  Attempting to connect to the build server...
2024.04.26 02:11:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.26 02:11:27 INFO  Attempting to connect to the build server...
2024.04.26 02:11:27 INFO  Attempting to connect to the build server...
2024.04.26 02:11:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\project\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.26 02:11:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.26 02:11:27 INFO  time: Connected to build server in 0.82s
2024.04.26 02:11:27 INFO  Connected to Build server: Bloop v1.5.17
Apr. 26, 2024 2:11:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2
2024.04.26 02:11:28 INFO  time: Imported build in 0.48s
2024.04.26 02:11:38 INFO  no build target found for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.04.26 02:11:46 INFO  no build target found for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala. Using presentation compiler with project's scala-library version: 3.3.3
Apr. 26, 2024 2:11:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 15
2024.04.26 02:12:07 INFO  time: indexed workspace in 29s
2024.04.26 02:12:07 INFO  compiling root (2 scala sources)
2024.04.26 02:12:07 INFO  time: compiled root in 0.43s
2024.04.26 02:12:07 INFO  compiling root (2 scala sources)
2024.04.26 02:12:08 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:08 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:08 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:08 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:09 INFO  time: compiled root in 0.69s
2024.04.26 02:12:09 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:24 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:25 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:25 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:28 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:34 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:37 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:37 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:38 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:37 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:37 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:37 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:37 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:38 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:39 WARN  Could not load snapshot text for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
2024.04.26 02:12:39 INFO  compiling root (2 scala sources)
2024.04.26 02:12:39 INFO  time: compiled root in 0.42s
2024.04.26 02:12:44 INFO  compiling root (1 scala source)
2024.04.26 02:12:44 INFO  time: compiled root in 0.17s
2024.04.26 02:12:57 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 02:12:57 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 02:12:57 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 02:12:57 INFO  Loaded expression compiler in 0 milliseconds
2024.04.26 02:12:57 INFO  Loaded step filter in 0 milliseconds
2024.04.26 02:12:58 INFO  Loaded all sources and classes in 1 second
2024.04.26 02:12:58 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:65506 .
2024.04.26 02:12:58 INFO  Attaching to debuggee VM succeeded.
2024.04.26 02:13:05 ERROR Could not find any completions for the debugger
java.lang.Exception: No source data available
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$15(DebugProxy.scala:174)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$1(DebugProxy.scala:174)
	at scala.meta.internal.metals.debug.MessageIdAdapter.$anonfun$listen$1(MessageIdAdapter.scala:57)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at scala.meta.internal.metals.debug.SocketEndpoint.listen(SocketEndpoint.scala:26)
	at scala.meta.internal.metals.debug.MessageIdAdapter.listen(MessageIdAdapter.scala:47)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$listenToClient$1(DebugProxy.scala:81)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:13:05 ERROR Could not find any completions for the debugger
java.lang.Exception: No source data available
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$15(DebugProxy.scala:174)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$1(DebugProxy.scala:174)
	at scala.meta.internal.metals.debug.MessageIdAdapter.$anonfun$listen$1(MessageIdAdapter.scala:57)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at scala.meta.internal.metals.debug.SocketEndpoint.listen(SocketEndpoint.scala:26)
	at scala.meta.internal.metals.debug.MessageIdAdapter.listen(MessageIdAdapter.scala:47)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$listenToClient$1(DebugProxy.scala:81)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:13:06 ERROR Could not find any completions for the debugger
java.lang.Exception: No source data available
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$15(DebugProxy.scala:174)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$1(DebugProxy.scala:174)
	at scala.meta.internal.metals.debug.MessageIdAdapter.$anonfun$listen$1(MessageIdAdapter.scala:57)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at scala.meta.internal.metals.debug.SocketEndpoint.listen(SocketEndpoint.scala:26)
	at scala.meta.internal.metals.debug.MessageIdAdapter.listen(MessageIdAdapter.scala:47)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$listenToClient$1(DebugProxy.scala:81)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:13:07 ERROR Could not find any completions for the debugger
java.lang.Exception: No source data available
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$15(DebugProxy.scala:174)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$1(DebugProxy.scala:174)
	at scala.meta.internal.metals.debug.MessageIdAdapter.$anonfun$listen$1(MessageIdAdapter.scala:57)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at scala.meta.internal.metals.debug.SocketEndpoint.listen(SocketEndpoint.scala:26)
	at scala.meta.internal.metals.debug.MessageIdAdapter.listen(MessageIdAdapter.scala:47)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$listenToClient$1(DebugProxy.scala:81)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:13:25 ERROR Could not find any completions for the debugger
java.lang.Exception: No source data available
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$15(DebugProxy.scala:174)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$1(DebugProxy.scala:174)
	at scala.meta.internal.metals.debug.MessageIdAdapter.$anonfun$listen$1(MessageIdAdapter.scala:57)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at scala.meta.internal.metals.debug.SocketEndpoint.listen(SocketEndpoint.scala:26)
	at scala.meta.internal.metals.debug.MessageIdAdapter.listen(MessageIdAdapter.scala:47)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$listenToClient$1(DebugProxy.scala:81)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:13:26 ERROR Could not find any completions for the debugger
java.lang.Exception: No source data available
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$15(DebugProxy.scala:174)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$1(DebugProxy.scala:174)
	at scala.meta.internal.metals.debug.MessageIdAdapter.$anonfun$listen$1(MessageIdAdapter.scala:57)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at scala.meta.internal.metals.debug.SocketEndpoint.listen(SocketEndpoint.scala:26)
	at scala.meta.internal.metals.debug.MessageIdAdapter.listen(MessageIdAdapter.scala:47)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$listenToClient$1(DebugProxy.scala:81)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:15:08 INFO  Closing debug server tcp://0.0.0.0:65504
2024.04.26 02:15:08 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 02:15:09 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 3m 41.765s)
2024.04.26 02:15:09 INFO  compiling root-test (3 scala sources)
2024.04.26 02:15:09 INFO  time: compiled root-test in 0.27s
2024.04.26 02:15:09 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 02:15:09 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 02:15:09 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 02:15:09 INFO  Loaded expression compiler in 0 milliseconds
2024.04.26 02:15:09 INFO  Loaded step filter in 0 milliseconds
2024.04.26 02:15:11 INFO  Loaded all sources and classes in 1 second
2024.04.26 02:15:11 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:49208 .
2024.04.26 02:15:11 INFO  Attaching to debuggee VM succeeded.
2024.04.26 02:15:11 ERROR Could not find any completions for the debugger
java.lang.Exception: No source data available
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$15(DebugProxy.scala:174)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$1(DebugProxy.scala:174)
	at scala.meta.internal.metals.debug.MessageIdAdapter.$anonfun$listen$1(MessageIdAdapter.scala:57)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at scala.meta.internal.metals.debug.SocketEndpoint.listen(SocketEndpoint.scala:26)
	at scala.meta.internal.metals.debug.MessageIdAdapter.listen(MessageIdAdapter.scala:47)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$listenToClient$1(DebugProxy.scala:81)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:15:13 ERROR Could not find any completions for the debugger
java.lang.Exception: No source data available
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$15(DebugProxy.scala:174)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$1(DebugProxy.scala:174)
	at scala.meta.internal.metals.debug.MessageIdAdapter.$anonfun$listen$1(MessageIdAdapter.scala:57)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at scala.meta.internal.metals.debug.SocketEndpoint.listen(SocketEndpoint.scala:26)
	at scala.meta.internal.metals.debug.MessageIdAdapter.listen(MessageIdAdapter.scala:47)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$listenToClient$1(DebugProxy.scala:81)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:15:22 INFO  Closing debug server tcp://0.0.0.0:49205
2024.04.26 02:15:22 INFO  Canceling debug proxy for [Chess.ChessGame]
Apr. 26, 2024 2:15:35 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
Apr. 26, 2024 2:16:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 257
2024.04.26 02:16:33 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
scala.meta.tokenizers.TokenizeException: <input>:14: error: invalid escape character
    print("\Gib die Koordinaten im Format Buchstabe-Zahl Buchstabe-Zahl (z.B. a1 b3) ein: ")
            ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.invalidEscape(LegacyScanner.scala:751)
	at scala.meta.internal.tokenizers.LegacyScanner.getLitChar(LegacyScanner.scala:739)
	at scala.meta.internal.tokenizers.LegacyScanner.getLitChars(LegacyScanner.scala:760)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:16:42 INFO  compiling root (1 scala source)
2024.04.26 02:16:42 INFO  time: compiled root in 0.16s
2024.04.26 02:19:31 INFO  compiling root (1 scala source)
2024.04.26 02:19:31 INFO  time: compiled root in 0.28s
2024.04.26 02:19:36 INFO  Shutting down server
2024.04.26 02:19:36 INFO  shutting down Metals
2024.04.26 02:19:36 INFO  Shut down connection with build server.
2024.04.26 02:19:36 INFO  Shut down connection with build server.
2024.04.26 02:19:36 INFO  Shut down connection with build server.
2024.04.26 02:19:36 INFO  Exiting server
2024.04.26 02:19:58 INFO  Started: Metals version 1.3.0 in folders 'C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG' for client Visual Studio Code 1.88.1.
SLF4J: Class path contains multiple SLF4J providers.
SLF4J: Found provider [scribe.slf4j.ScribeServiceProvider@5845859d]
SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@23aef418]
SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual provider is of type [scribe.slf4j.ScribeServiceProvider@5845859d]
2024.04.26 02:19:58 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.04.26 02:20:01 INFO  Attempting to connect to the build server...
2024.04.26 02:20:01 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.26 02:20:01 INFO  Attempting to connect to the build server...
2024.04.26 02:20:01 INFO  Attempting to connect to the build server...
2024.04.26 02:20:01 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\project\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.26 02:20:01 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\project\.metals\bsp.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.26 02:20:01 INFO  time: Connected to build server in 0.74s
2024.04.26 02:20:01 INFO  Connected to Build server: Bloop v1.5.17
2024.04.26 02:20:01 INFO  time: Imported build in 0.45s
2024.04.26 02:20:13 INFO  no build target found for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala. Using presentation compiler with project's scala-library version: 3.3.3
Apr. 26, 2024 2:20:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9
Apr. 26, 2024 2:20:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 15
Apr. 26, 2024 2:20:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 13
Apr. 26, 2024 2:20:14 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 21
Apr. 26, 2024 2:20:14 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 22
Apr. 26, 2024 2:20:14 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 23
2024.04.26 02:20:45 INFO  time: indexed workspace in 31s
2024.04.26 02:20:45 INFO  compiling root-test (3 scala sources)
2024.04.26 02:20:53 INFO  time: compiled root-test in 8.06s
Apr. 26, 2024 2:20:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 71
2024.04.26 02:21:22 INFO  compiling root (1 scala source)
2024.04.26 02:21:22 INFO  time: compiled root in 0.23s
2024.04.26 02:21:59 INFO  compiling root (1 scala source)
2024.04.26 02:21:59 INFO  time: compiled root in 0.13s
2024.04.26 02:22:10 INFO  compiling root (1 scala source)
2024.04.26 02:22:10 INFO  time: compiled root in 0.12s
Apr. 26, 2024 2:22:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
java.util.concurrent.CompletionException: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptNow(CompletableFuture.java:747)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptStage(CompletableFuture.java:735)
	at java.base/java.util.concurrent.CompletableFuture.thenAcceptAsync(CompletableFuture.java:2218)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.thenAccept(FutureConvertersImpl.scala:37)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:279)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$.<clinit>(DebugProvider.scala:1024)
	at scala.meta.internal.metals.debug.DebugProvider.debugDiscovery(DebugProvider.scala:586)
	at scala.meta.internal.metals.debug.DebugProvider.runCommandDiscovery(DebugProvider.scala:522)
	at scala.meta.internal.metals.MetalsLspService.discoverMainClasses(MetalsLspService.scala:1825)
	at scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:731)
	at scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	... 9 more

2024.04.26 02:22:24 INFO  compiling root (1 scala source)
2024.04.26 02:22:24 INFO  time: compiled root in 0.36s
Apr. 26, 2024 2:22:30 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$: There is nothing to run or test in the current file.
java.util.concurrent.CompletionException: scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$: There is nothing to run or test in the current file.
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptNow(CompletableFuture.java:747)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptStage(CompletableFuture.java:735)
	at java.base/java.util.concurrent.CompletableFuture.thenAcceptAsync(CompletableFuture.java:2218)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.thenAccept(FutureConvertersImpl.scala:37)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:279)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$: There is nothing to run or test in the current file.
	at scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$.<clinit>(DebugProvider.scala:1028)
	at scala.meta.internal.metals.debug.DebugProvider.$anonfun$resolveInFile$2(DebugProvider.scala:478)
	at scala.Option.fold(Option.scala:263)
	at scala.meta.internal.metals.debug.DebugProvider.resolveInFile(DebugProvider.scala:449)
	at scala.meta.internal.metals.debug.DebugProvider.debugDiscovery(DebugProvider.scala:594)
	at scala.meta.internal.metals.debug.DebugProvider.runCommandDiscovery(DebugProvider.scala:522)
	at scala.meta.internal.metals.MetalsLspService.discoverMainClasses(MetalsLspService.scala:1825)
	at scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:731)
	at scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	... 9 more

2024.04.26 02:22:47 INFO  compiling root (1 scala source)
2024.04.26 02:22:47 INFO  time: compiled root in 0.25s
2024.04.26 02:23:12 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:36: error: unclosed string interpolation
    sr.append(space*2 + "A" + space * 2 +\n")
                                            ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:666)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:364)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:23:29 INFO  compiling root (1 scala source)
2024.04.26 02:23:29 INFO  time: compiled root in 0.28s
2024.04.26 02:23:33 INFO  compiling root-test (3 scala sources)
2024.04.26 02:23:33 INFO  time: compiled root-test in 0.3s
2024.04.26 02:23:33 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 02:23:33 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 02:23:34 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 02:23:33 INFO  Loaded expression compiler in 1 millisecond
2024.04.26 02:23:33 INFO  Loaded step filter in 0 milliseconds
2024.04.26 02:23:35 INFO  Loaded all sources and classes in 1 second
2024.04.26 02:23:35 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:49799 .
2024.04.26 02:23:35 INFO  Attaching to debuggee VM succeeded.
2024.04.26 02:23:50 INFO  compiling root (1 scala source)
2024.04.26 02:23:50 INFO  time: compiled root in 0.25s
Apr. 26, 2024 2:23:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$: There is nothing to run or test in the current file.
java.util.concurrent.CompletionException: scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$: There is nothing to run or test in the current file.
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptNow(CompletableFuture.java:747)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptStage(CompletableFuture.java:735)
	at java.base/java.util.concurrent.CompletableFuture.thenAcceptAsync(CompletableFuture.java:2218)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.thenAccept(FutureConvertersImpl.scala:37)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:279)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$: There is nothing to run or test in the current file.
	at scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$.<clinit>(DebugProvider.scala:1028)
	at scala.meta.internal.metals.debug.DebugProvider.$anonfun$resolveInFile$2(DebugProvider.scala:478)
	at scala.Option.fold(Option.scala:263)
	at scala.meta.internal.metals.debug.DebugProvider.resolveInFile(DebugProvider.scala:449)
	at scala.meta.internal.metals.debug.DebugProvider.debugDiscovery(DebugProvider.scala:594)
	at scala.meta.internal.metals.debug.DebugProvider.runCommandDiscovery(DebugProvider.scala:522)
	at scala.meta.internal.metals.MetalsLspService.discoverMainClasses(MetalsLspService.scala:1825)
	at scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:731)
	at scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	... 9 more

2024.04.26 02:24:03 INFO  Closing debug server tcp://0.0.0.0:49797
2024.04.26 02:24:03 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 02:24:29 INFO  compiling root (1 scala source)
2024.04.26 02:24:29 INFO  time: compiled root in 0.2s
2024.04.26 02:24:50 INFO  compiling root (1 scala source)
2024.04.26 02:24:50 INFO  time: compiled root in 0.23s
2024.04.26 02:24:59 INFO  compiling root (1 scala source)
2024.04.26 02:24:59 INFO  time: compiled root in 0.39s
Apr. 26, 2024 2:25:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$: There is nothing to run or test in the current file.
java.util.concurrent.CompletionException: scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$: There is nothing to run or test in the current file.
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptNow(CompletableFuture.java:747)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptStage(CompletableFuture.java:735)
	at java.base/java.util.concurrent.CompletableFuture.thenAcceptAsync(CompletableFuture.java:2218)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.thenAccept(FutureConvertersImpl.scala:37)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:279)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$: There is nothing to run or test in the current file.
	at scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$.<clinit>(DebugProvider.scala:1028)
	at scala.meta.internal.metals.debug.DebugProvider.$anonfun$resolveInFile$2(DebugProvider.scala:478)
	at scala.Option.fold(Option.scala:263)
	at scala.meta.internal.metals.debug.DebugProvider.resolveInFile(DebugProvider.scala:449)
	at scala.meta.internal.metals.debug.DebugProvider.debugDiscovery(DebugProvider.scala:594)
	at scala.meta.internal.metals.debug.DebugProvider.runCommandDiscovery(DebugProvider.scala:522)
	at scala.meta.internal.metals.MetalsLspService.discoverMainClasses(MetalsLspService.scala:1825)
	at scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:731)
	at scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	... 9 more

2024.04.26 02:25:38 INFO  compiling root (1 scala source)
2024.04.26 02:25:38 INFO  time: compiled root in 0.2s
2024.04.26 02:27:06 INFO  compiling root (1 scala source)
2024.04.26 02:27:06 INFO  time: compiled root in 0.1s
2024.04.26 02:27:16 INFO  compiling root (1 scala source)
2024.04.26 02:27:16 INFO  time: compiled root in 0.1s
2024.04.26 02:27:20 INFO  compiling root (1 scala source)
2024.04.26 02:27:20 INFO  time: compiled root in 0.21s
2024.04.26 02:27:32 INFO  compiling root (1 scala source)
2024.04.26 02:27:32 INFO  time: compiled root in 0.33s
2024.04.26 02:28:14 INFO  compiling root (1 scala source)
2024.04.26 02:28:14 INFO  time: compiled root in 0.25s
2024.04.26 02:28:33 INFO  compiling root (1 scala source)
2024.04.26 02:28:33 INFO  time: compiled root in 0.2s
2024.04.26 02:29:16 INFO  compiling root (1 scala source)
2024.04.26 02:29:16 INFO  time: compiled root in 0.2s
2024.04.26 02:30:13 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 2:30:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/mutable/StringBuilder.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala.collection.mutable\n\nimport scala.collection.{IterableFactoryDefaults, IterableOnce}\nimport scala.collection.immutable.WrappedString\n\nimport scala.Predef.{ // unimport char-related implicit conversions to avoid triggering them accidentally\n  genericArrayOps \u003d\u003e _,\n  charArrayOps \u003d\u003e _,\n  genericWrapArray \u003d\u003e _,\n  wrapCharArray \u003d\u003e _,\n  wrapString \u003d\u003e _,\n //_\n}\n\n/** A builder of `String` which is also a mutable sequence of characters.\n *\n *  This class provides an API mostly compatible with `java.lang.StringBuilder`,\n *  except where there are conflicts with the Scala collections API, such as the `reverse` method:\n *  [[reverse]] produces a new `StringBuilder`, and [[reverseInPlace]] mutates this builder.\n *\n *  Mutating operations return either `this.type`, i.e., the current builder, or `Unit`.\n *\n *  Other methods extract data or information from the builder without mutating it.\n *\n *  The distinction is also reflected in naming conventions used by collections,\n *  such as `append`, which mutates, and `appended`, which does not, or `reverse`,\n *  which does not mutate, and `reverseInPlace`, which does.\n *\n *  The `String` result may be obtained using either `result()` or `toString`.\n *\n *  $multipleResults\n *\n *  @see [[https://docs.scala-lang.org/overviews/collections-2.13/concrete-mutable-collection-classes.html#stringbuilders \"Scala\u0027s Collection Library overview\"]]\n *  section on `StringBuilders` for more information.\n *\n *  @define Coll `mutable.IndexedSeq`\n *  @define coll string builder\n */\n@SerialVersionUID(3L)\nfinal class StringBuilder(val underlying: java.lang.StringBuilder) extends AbstractSeq[Char]\n  with ReusableBuilder[Char, String]\n  with IndexedSeq[Char]\n  with IndexedSeqOps[Char, IndexedSeq, StringBuilder]\n  with IterableFactoryDefaults[Char, IndexedSeq]\n  with java.lang.CharSequence\n  with Serializable {\n\n  def this() \u003d this(new java.lang.StringBuilder)\n\n  /** Constructs a string builder with no characters in it and an\n    *  initial capacity specified by the `capacity` argument.\n    *\n    *  @param  capacity  the initial capacity.\n    *  @throws java.lang.NegativeArraySizeException  if capacity \u003c 0.\n    */\n  def this(capacity: Int) \u003d this(new java.lang.StringBuilder(capacity))\n\n  /** Constructs a string builder with initial characters\n    *  equal to characters of `str`.\n    */\n  def this(str: String) \u003d this(new java.lang.StringBuilder(str))\n\n  /** Constructs a string builder initialized with string value `initValue`\n    *  and with additional character capacity `initCapacity`.\n    */\n  def this(initCapacity: Int, initValue: String) \u003d\n    this(new java.lang.StringBuilder(initValue.length + initCapacity) append initValue)\n\n  // Methods required to make this an IndexedSeq:\n  def apply(i: Int): Char \u003d underlying.charAt(i)\n\n  override protected def fromSpecific(coll: scala.collection.IterableOnce[Char]): StringBuilder \u003d\n    new StringBuilder() appendAll coll\n\n  override protected def newSpecificBuilder: Builder[Char, StringBuilder] \u003d\n    new GrowableBuilder(new StringBuilder())\n\n  override def empty: StringBuilder \u003d new StringBuilder()\n\n  @inline def length: Int \u003d underlying.length\n\n  def length_\u003d(n: Int): Unit \u003d underlying.setLength(n)\n\n  override def knownSize: Int \u003d super[IndexedSeqOps].knownSize\n\n  def addOne(x: Char): this.type \u003d { underlying.append(x); this }\n\n  def clear(): Unit \u003d underlying.setLength(0)\n\n  /** Overloaded version of `addAll` that takes a string */\n  def addAll(s: String): this.type \u003d { underlying.append(s); this }\n\n  /** Alias for `addAll` */\n  def ++\u003d (s: String): this.type \u003d addAll(s)\n\n  def result() \u003d underlying.toString\n\n  override def toString: String \u003d result()\n\n  override def toArray[B \u003e: Char](implicit ct: scala.reflect.ClassTag[B]) \u003d\n    ct.runtimeClass match {\n      case java.lang.Character.TYPE \u003d\u003e toCharArray.asInstanceOf[Array[B]]\n      case _ \u003d\u003e super.toArray\n    }\n\n  /** Returns the contents of this StringBuilder as an `Array[Char]`.\n   *\n   *  @return  An array with the characters from this builder.\n   */\n  def toCharArray: Array[Char] \u003d {\n    val len \u003d underlying.length\n    val arr \u003d new Array[Char](len)\n    underlying.getChars(0, len, arr, 0)\n    arr\n  }\n\n  // append* methods delegate to the underlying java.lang.StringBuilder:\n\n  def appendAll(xs: String): this.type \u003d {\n    underlying append xs\n    this\n  }\n\n  /** Appends the string representation of the given argument,\n    *  which is converted to a String with `String.valueOf`.\n    *\n    *  @param  x   an `Any` object.\n    *  @return     this StringBuilder.\n    */\n  def append(x: Any): this.type \u003d {\n    underlying append String.valueOf(x)\n    this\n  }\n\n  /** Appends the given String to this sequence.\n    *\n    *  @param  s   a String.\n    *  @return     this StringBuilder.\n    */\n  def append(s: String): this.type \u003d {\n    underlying append s\n    this\n  }\n\n  /** Appends the given CharSequence to this sequence.\n    *\n    *  @param  cs   a CharSequence.\n    *  @return     this StringBuilder.\n    */\n  def append(cs: java.lang.CharSequence): this.type \u003d {\n    underlying.append(cs match {\n      // Both cases call into append(\u003cCharSequence\u003e), but java SB\n      // looks up type at runtime and has fast path for SB.\n      case s: StringBuilder \u003d\u003e s.underlying\n      case _                \u003d\u003e cs\n    })\n    this\n  }\n\n  /** Appends the specified string builder to this sequence.\n    *\n    *  @param s\n    *  @return\n    */\n  def append(s: StringBuilder): this.type \u003d {\n    underlying append s.underlying\n    this\n  }\n\n  /** Appends all the Chars in the given IterableOnce[Char] to this sequence.\n    *\n    *  @param  xs  the characters to be appended.\n    *  @return     this StringBuilder.\n    */\n  def appendAll(xs: IterableOnce[Char]): this.type \u003d {\n    xs match {\n      case x: WrappedString \u003d\u003e underlying append x.unwrap\n      case x: ArraySeq.ofChar \u003d\u003e underlying append x.array\n      case x: StringBuilder \u003d\u003e underlying append x.underlying\n      case _ \u003d\u003e\n        val ks \u003d xs.knownSize\n        if (ks !\u003d 0) {\n          val b \u003d underlying\n          if (ks \u003e 0) b.ensureCapacity(b.length + ks)\n          val it \u003d xs.iterator\n          while (it.hasNext) { b append it.next() }\n        }\n    }\n    this\n  }\n\n  /** Appends all the Chars in the given Array[Char] to this sequence.\n    *\n    *  @param  xs  the characters to be appended.\n    *  @return     a reference to this object.\n    */\n  def appendAll(xs: Array[Char]): this.type \u003d {\n    underlying append xs\n    this\n  }\n\n  /** Appends a portion of the given Array[Char] to this sequence.\n    *\n    *  @param  xs      the Array containing Chars to be appended.\n    *  @param  offset  the index of the first Char to append.\n    *  @param  len     the numbers of Chars to append.\n    *  @return         this StringBuilder.\n    */\n  def appendAll(xs: Array[Char], offset: Int, len: Int): this.type \u003d {\n    underlying.append(xs, offset, len)\n    this\n  }\n\n  /** Append the String representation of the given primitive type\n    *  to this sequence.  The argument is converted to a String with\n    *  String.valueOf.\n    *\n    *  @param   x  a primitive value\n    *  @return     This StringBuilder.\n    */\n  def append(x: Boolean): this.type \u003d { underlying append x ; this }\n  def append(x: Byte): this.type \u003d append(x.toInt)\n  def append(x: Short): this.type \u003d append(x.toInt)\n  def append(x: Int): this.type \u003d { underlying append x ; this }\n  def append(x: Long): this.type \u003d { underlying append x ; this }\n  def append(x: Float): this.type \u003d { underlying append x ; this }\n  def append(x: Double): this.type \u003d { underlying append x ; this }\n  def append(x: Char): this.type \u003d { underlying append x ; this }\n\n  /** Remove a subsequence of Chars from this sequence, starting at the\n    *  given start index (inclusive) and extending to the end index (exclusive)\n    *  or to the end of the String, whichever comes first.\n    *\n    *  @param  start  The beginning index, inclusive.\n    *  @param  end    The ending index, exclusive.\n    *  @return        This StringBuilder.\n    *  @throws StringIndexOutOfBoundsException   if start \u003c 0 || start \u003e end\n    */\n  def delete(start: Int, end: Int): this.type \u003d {\n    underlying.delete(start, end)\n    this\n  }\n\n  /** Replaces a subsequence of Chars with the given String.  The semantics\n    *  are as in delete, with the String argument then inserted at index \u0027start\u0027.\n    *\n    *  @param  start  The beginning index, inclusive.\n    *  @param  end    The ending index, exclusive.\n    *  @param  str    The String to be inserted at the start index.\n    *  @return        This StringBuilder.\n    *  @throws StringIndexOutOfBoundsException if start \u003c 0, start \u003e length, or start \u003e end\n    */\n  def replace(start: Int, end: Int, str: String): this.type \u003d {\n    underlying.replace(start, end, str)\n    this\n  }\n\n  /** Inserts a subarray of the given Array[Char] at the given index\n    *  of this sequence.\n    *\n    * @param  index   index at which to insert the subarray.\n    * @param  str     the Array from which Chars will be taken.\n    * @param  offset  the index of the first Char to insert.\n    * @param  len     the number of Chars from \u0027str\u0027 to insert.\n    * @return         This StringBuilder.\n    *\n    * @throws StringIndexOutOfBoundsException  if index \u003c 0, index \u003e length,\n    *         offset \u003c 0, len \u003c 0, or (offset + len) \u003e str.length.\n    */\n  def insertAll(index: Int, str: Array[Char], offset: Int, len: Int): this.type \u003d {\n    underlying.insert(index, str, offset, len)\n    this\n  }\n\n  /** Inserts the String representation (via String.valueOf) of the given\n    *  argument into this sequence at the given index.\n    *\n    *  @param  index   the index at which to insert.\n    *  @param  x       a value.\n    *  @return         this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insert(index: Int, x: Any): this.type \u003d insert(index, String.valueOf(x))\n\n  /** Inserts the String into this character sequence.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  x     a String.\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insert(index: Int, x: String): this.type \u003d {\n    underlying.insert(index, x)\n    this\n  }\n\n  /** Inserts the given Seq[Char] into this sequence at the given index.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  xs    the Seq[Char].\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insertAll(index: Int, xs: IterableOnce[Char]): this.type \u003d\n    insertAll(index, (ArrayBuilder.make[Char] ++\u003d xs).result())\n\n  /** Inserts the given Array[Char] into this sequence at the given index.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  xs    the Array[Char].\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insertAll(index: Int, xs: Array[Char]): this.type \u003d {\n    underlying.insert(index, xs)\n    this\n  }\n\n  /** Calls String.valueOf on the given primitive value, and inserts the\n    *  String at the given index.\n    *\n    *  @param  index the offset position.\n    *  @param  x     a primitive value.\n    *  @return       this StringBuilder.\n    */\n  def insert(index: Int, x: Boolean): this.type \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Byte): this.type    \u003d insert(index, x.toInt)\n  def insert(index: Int, x: Short): this.type   \u003d insert(index, x.toInt)\n  def insert(index: Int, x: Int): this.type     \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Long): this.type    \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Float): this.type   \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Double): this.type  \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Char): this.type    \u003d insert(index, String.valueOf(x))\n\n  /** Sets the length of the character sequence.  If the current sequence\n    *  is shorter than the given length, it is padded with nulls; if it is\n    *  longer, it is truncated.\n    *\n    *  @param  len  the new length\n    *  @throws IndexOutOfBoundsException if the argument is negative.\n    */\n  def setLength(len: Int): Unit \u003d underlying.setLength(len)\n\n  def update(idx: Int, elem: Char): Unit \u003d underlying.setCharAt(idx, elem)\n\n\n  /** Like reverse, but destructively updates the target StringBuilder.\n   *\n   *  @return   the reversed StringBuilder (same as the target StringBuilder)\n   */\n  @deprecated(\"Use reverseInPlace instead\", \"2.13.0\")\n  final def reverseContents(): this.type \u003d reverseInPlace()\n\n  /** Like reverse, but destructively updates the target StringBuilder.\n   *\n   *  @return   the reversed StringBuilder (same as the target StringBuilder)\n   */\n  def reverseInPlace(): this.type \u003d {\n    underlying.reverse()\n    this\n  }\n\n\n  /** Returns the current capacity, which is the size of the underlying array.\n   *  A new array will be allocated if the current capacity is exceeded.\n   *\n   *  @return  the capacity\n   */\n  def capacity: Int \u003d underlying.capacity\n\n  /** Ensure that the capacity is at least the given argument.\n   *  If the argument is greater than the current capacity, new\n   *  storage will be allocated with size equal to the given\n   *  argument or to `(2 * capacity + 2)`, whichever is larger.\n   *\n   *  @param newCapacity    the minimum desired capacity.\n   */\n  def ensureCapacity(newCapacity: Int): Unit \u003d { underlying.ensureCapacity(newCapacity) }\n\n  /** Returns the Char at the specified index, counting from 0 as in Arrays.\n   *\n   *  @param  index   the index to look up\n   *  @return         the Char at the given index.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def charAt(index: Int): Char \u003d underlying.charAt(index)\n\n  /** Removes the Char at the specified index.  The sequence is\n   *  shortened by one.\n   *\n   *  @param  index  The index to remove.\n   *  @return        This StringBuilder.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def deleteCharAt(index: Int): this.type \u003d {\n    underlying.deleteCharAt(index)\n    this\n  }\n\n  /** Update the sequence at the given index to hold the specified Char.\n   *\n   *  @param  index   the index to modify.\n   *  @param  ch      the new Char.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def setCharAt(index: Int, ch: Char): this.type \u003d {\n    underlying.setCharAt(index, ch)\n    this\n  }\n\n  /** Returns a new String made up of a subsequence of this sequence,\n   *  beginning at the given index and extending to the end of the sequence.\n   *\n   *  target.substring(start)  is equivalent to  target.drop(start)\n   *\n   *  @param  start  The starting index, inclusive.\n   *  @return        The new String.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def substring(start: Int): String \u003d underlying.substring(start, length)\n\n  /** Returns a new String made up of a subsequence of this sequence,\n   *  beginning at the start index (inclusive) and extending to the\n   *  end index (exclusive).\n   *\n   *  target.substring(start, end)  is equivalent to  target.slice(start, end).mkString\n   *\n   *  @param  start  The beginning index, inclusive.\n   *  @param  end    The ending index, exclusive.\n   *  @return The new String.\n   *  @throws StringIndexOutOfBoundsException If either index is out of bounds,\n   *          or if start \u003e end.\n   */\n  def substring(start: Int, end: Int): String \u003d underlying.substring(start, end)\n\n  /** For implementing CharSequence.\n   */\n  def subSequence(start: Int, end: Int): java.lang.CharSequence \u003d\n    underlying.substring(start, end)\n\n  /** Finds the index of the first occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @return             the first applicable index where target occurs, or -1 if not found.\n   */\n  def indexOf(str: String): Int \u003d underlying.indexOf(str)\n\n  /** Finds the index of the first occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @param    fromIndex the smallest index in the source string to consider\n   *  @return             the first applicable index where target occurs, or -1 if not found.\n   */\n  def indexOf(str: String, fromIndex: Int): Int \u003d underlying.indexOf(str, fromIndex)\n\n  /** Finds the index of the last occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @return             the last applicable index where target occurs, or -1 if not found.\n   */\n  def lastIndexOf(str: String): Int \u003d underlying.lastIndexOf(str)\n\n  /** Finds the index of the last occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @param    fromIndex the smallest index in the source string to consider\n   *  @return             the last applicable index where target occurs, or -1 if not found.\n   */\n  def lastIndexOf(str: String, fromIndex: Int): Int \u003d underlying.lastIndexOf(str, fromIndex)\n\n  /** Tests whether this builder is empty.\n   *\n   *  This method is required for JDK15+ compatibility\n   *\n   *  @return  `true` if this builder contains nothing, `false` otherwise.\n   */\n  override def isEmpty: Boolean \u003d underlying.length() \u003d\u003d 0\n}\n\nobject StringBuilder {\n  @deprecated(\"Use `new StringBuilder()` instead of `StringBuilder.newBuilder`\", \"2.13.0\")\n  def newBuilder \u003d new StringBuilder\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 2:30:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/mutable/StringBuilder.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:30:13 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 2:30:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/mutable/StringBuilder.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala.collection.mutable\n\nimport scala.collection.{IterableFactoryDefaults, IterableOnce}\nimport scala.collection.immutable.WrappedString\n\nimport scala.Predef.{ // unimport char-related implicit conversions to avoid triggering them accidentally\n  genericArrayOps \u003d\u003e _,\n  charArrayOps \u003d\u003e _,\n  genericWrapArray \u003d\u003e _,\n  wrapCharArray \u003d\u003e _,\n  wrapString \u003d\u003e _,\n //_\n}\n\n/** A builder of `String` which is also a mutable sequence of characters.\n *\n *  This class provides an API mostly compatible with `java.lang.StringBuilder`,\n *  except where there are conflicts with the Scala collections API, such as the `reverse` method:\n *  [[reverse]] produces a new `StringBuilder`, and [[reverseInPlace]] mutates this builder.\n *\n *  Mutating operations return either `this.type`, i.e., the current builder, or `Unit`.\n *\n *  Other methods extract data or information from the builder without mutating it.\n *\n *  The distinction is also reflected in naming conventions used by collections,\n *  such as `append`, which mutates, and `appended`, which does not, or `reverse`,\n *  which does not mutate, and `reverseInPlace`, which does.\n *\n *  The `String` result may be obtained using either `result()` or `toString`.\n *\n *  $multipleResults\n *\n *  @see [[https://docs.scala-lang.org/overviews/collections-2.13/concrete-mutable-collection-classes.html#stringbuilders \"Scala\u0027s Collection Library overview\"]]\n *  section on `StringBuilders` for more information.\n *\n *  @define Coll `mutable.IndexedSeq`\n *  @define coll string builder\n */\n@SerialVersionUID(3L)\nfinal class StringBuilder(val underlying: java.lang.StringBuilder) extends AbstractSeq[Char]\n  with ReusableBuilder[Char, String]\n  with IndexedSeq[Char]\n  with IndexedSeqOps[Char, IndexedSeq, StringBuilder]\n  with IterableFactoryDefaults[Char, IndexedSeq]\n  with java.lang.CharSequence\n  with Serializable {\n\n  def this() \u003d this(new java.lang.StringBuilder)\n\n  /** Constructs a string builder with no characters in it and an\n    *  initial capacity specified by the `capacity` argument.\n    *\n    *  @param  capacity  the initial capacity.\n    *  @throws java.lang.NegativeArraySizeException  if capacity \u003c 0.\n    */\n  def this(capacity: Int) \u003d this(new java.lang.StringBuilder(capacity))\n\n  /** Constructs a string builder with initial characters\n    *  equal to characters of `str`.\n    */\n  def this(str: String) \u003d this(new java.lang.StringBuilder(str))\n\n  /** Constructs a string builder initialized with string value `initValue`\n    *  and with additional character capacity `initCapacity`.\n    */\n  def this(initCapacity: Int, initValue: String) \u003d\n    this(new java.lang.StringBuilder(initValue.length + initCapacity) append initValue)\n\n  // Methods required to make this an IndexedSeq:\n  def apply(i: Int): Char \u003d underlying.charAt(i)\n\n  override protected def fromSpecific(coll: scala.collection.IterableOnce[Char]): StringBuilder \u003d\n    new StringBuilder() appendAll coll\n\n  override protected def newSpecificBuilder: Builder[Char, StringBuilder] \u003d\n    new GrowableBuilder(new StringBuilder())\n\n  override def empty: StringBuilder \u003d new StringBuilder()\n\n  @inline def length: Int \u003d underlying.length\n\n  def length_\u003d(n: Int): Unit \u003d underlying.setLength(n)\n\n  override def knownSize: Int \u003d super[IndexedSeqOps].knownSize\n\n  def addOne(x: Char): this.type \u003d { underlying.append(x); this }\n\n  def clear(): Unit \u003d underlying.setLength(0)\n\n  /** Overloaded version of `addAll` that takes a string */\n  def addAll(s: String): this.type \u003d { underlying.append(s); this }\n\n  /** Alias for `addAll` */\n  def ++\u003d (s: String): this.type \u003d addAll(s)\n\n  def result() \u003d underlying.toString\n\n  override def toString: String \u003d result()\n\n  override def toArray[B \u003e: Char](implicit ct: scala.reflect.ClassTag[B]) \u003d\n    ct.runtimeClass match {\n      case java.lang.Character.TYPE \u003d\u003e toCharArray.asInstanceOf[Array[B]]\n      case _ \u003d\u003e super.toArray\n    }\n\n  /** Returns the contents of this StringBuilder as an `Array[Char]`.\n   *\n   *  @return  An array with the characters from this builder.\n   */\n  def toCharArray: Array[Char] \u003d {\n    val len \u003d underlying.length\n    val arr \u003d new Array[Char](len)\n    underlying.getChars(0, len, arr, 0)\n    arr\n  }\n\n  // append* methods delegate to the underlying java.lang.StringBuilder:\n\n  def appendAll(xs: String): this.type \u003d {\n    underlying append xs\n    this\n  }\n\n  /** Appends the string representation of the given argument,\n    *  which is converted to a String with `String.valueOf`.\n    *\n    *  @param  x   an `Any` object.\n    *  @return     this StringBuilder.\n    */\n  def append(x: Any): this.type \u003d {\n    underlying append String.valueOf(x)\n    this\n  }\n\n  /** Appends the given String to this sequence.\n    *\n    *  @param  s   a String.\n    *  @return     this StringBuilder.\n    */\n  def append(s: String): this.type \u003d {\n    underlying append s\n    this\n  }\n\n  /** Appends the given CharSequence to this sequence.\n    *\n    *  @param  cs   a CharSequence.\n    *  @return     this StringBuilder.\n    */\n  def append(cs: java.lang.CharSequence): this.type \u003d {\n    underlying.append(cs match {\n      // Both cases call into append(\u003cCharSequence\u003e), but java SB\n      // looks up type at runtime and has fast path for SB.\n      case s: StringBuilder \u003d\u003e s.underlying\n      case _                \u003d\u003e cs\n    })\n    this\n  }\n\n  /** Appends the specified string builder to this sequence.\n    *\n    *  @param s\n    *  @return\n    */\n  def append(s: StringBuilder): this.type \u003d {\n    underlying append s.underlying\n    this\n  }\n\n  /** Appends all the Chars in the given IterableOnce[Char] to this sequence.\n    *\n    *  @param  xs  the characters to be appended.\n    *  @return     this StringBuilder.\n    */\n  def appendAll(xs: IterableOnce[Char]): this.type \u003d {\n    xs match {\n      case x: WrappedString \u003d\u003e underlying append x.unwrap\n      case x: ArraySeq.ofChar \u003d\u003e underlying append x.array\n      case x: StringBuilder \u003d\u003e underlying append x.underlying\n      case _ \u003d\u003e\n        val ks \u003d xs.knownSize\n        if (ks !\u003d 0) {\n          val b \u003d underlying\n          if (ks \u003e 0) b.ensureCapacity(b.length + ks)\n          val it \u003d xs.iterator\n          while (it.hasNext) { b append it.next() }\n        }\n    }\n    this\n  }\n\n  /** Appends all the Chars in the given Array[Char] to this sequence.\n    *\n    *  @param  xs  the characters to be appended.\n    *  @return     a reference to this object.\n    */\n  def appendAll(xs: Array[Char]): this.type \u003d {\n    underlying append xs\n    this\n  }\n\n  /** Appends a portion of the given Array[Char] to this sequence.\n    *\n    *  @param  xs      the Array containing Chars to be appended.\n    *  @param  offset  the index of the first Char to append.\n    *  @param  len     the numbers of Chars to append.\n    *  @return         this StringBuilder.\n    */\n  def appendAll(xs: Array[Char], offset: Int, len: Int): this.type \u003d {\n    underlying.append(xs, offset, len)\n    this\n  }\n\n  /** Append the String representation of the given primitive type\n    *  to this sequence.  The argument is converted to a String with\n    *  String.valueOf.\n    *\n    *  @param   x  a primitive value\n    *  @return     This StringBuilder.\n    */\n  def append(x: Boolean): this.type \u003d { underlying append x ; this }\n  def append(x: Byte): this.type \u003d append(x.toInt)\n  def append(x: Short): this.type \u003d append(x.toInt)\n  def append(x: Int): this.type \u003d { underlying append x ; this }\n  def append(x: Long): this.type \u003d { underlying append x ; this }\n  def append(x: Float): this.type \u003d { underlying append x ; this }\n  def append(x: Double): this.type \u003d { underlying append x ; this }\n  def append(x: Char): this.type \u003d { underlying append x ; this }\n\n  /** Remove a subsequence of Chars from this sequence, starting at the\n    *  given start index (inclusive) and extending to the end index (exclusive)\n    *  or to the end of the String, whichever comes first.\n    *\n    *  @param  start  The beginning index, inclusive.\n    *  @param  end    The ending index, exclusive.\n    *  @return        This StringBuilder.\n    *  @throws StringIndexOutOfBoundsException   if start \u003c 0 || start \u003e end\n    */\n  def delete(start: Int, end: Int): this.type \u003d {\n    underlying.delete(start, end)\n    this\n  }\n\n  /** Replaces a subsequence of Chars with the given String.  The semantics\n    *  are as in delete, with the String argument then inserted at index \u0027start\u0027.\n    *\n    *  @param  start  The beginning index, inclusive.\n    *  @param  end    The ending index, exclusive.\n    *  @param  str    The String to be inserted at the start index.\n    *  @return        This StringBuilder.\n    *  @throws StringIndexOutOfBoundsException if start \u003c 0, start \u003e length, or start \u003e end\n    */\n  def replace(start: Int, end: Int, str: String): this.type \u003d {\n    underlying.replace(start, end, str)\n    this\n  }\n\n  /** Inserts a subarray of the given Array[Char] at the given index\n    *  of this sequence.\n    *\n    * @param  index   index at which to insert the subarray.\n    * @param  str     the Array from which Chars will be taken.\n    * @param  offset  the index of the first Char to insert.\n    * @param  len     the number of Chars from \u0027str\u0027 to insert.\n    * @return         This StringBuilder.\n    *\n    * @throws StringIndexOutOfBoundsException  if index \u003c 0, index \u003e length,\n    *         offset \u003c 0, len \u003c 0, or (offset + len) \u003e str.length.\n    */\n  def insertAll(index: Int, str: Array[Char], offset: Int, len: Int): this.type \u003d {\n    underlying.insert(index, str, offset, len)\n    this\n  }\n\n  /** Inserts the String representation (via String.valueOf) of the given\n    *  argument into this sequence at the given index.\n    *\n    *  @param  index   the index at which to insert.\n    *  @param  x       a value.\n    *  @return         this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insert(index: Int, x: Any): this.type \u003d insert(index, String.valueOf(x))\n\n  /** Inserts the String into this character sequence.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  x     a String.\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insert(index: Int, x: String): this.type \u003d {\n    underlying.insert(index, x)\n    this\n  }\n\n  /** Inserts the given Seq[Char] into this sequence at the given index.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  xs    the Seq[Char].\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insertAll(index: Int, xs: IterableOnce[Char]): this.type \u003d\n    insertAll(index, (ArrayBuilder.make[Char] ++\u003d xs).result())\n\n  /** Inserts the given Array[Char] into this sequence at the given index.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  xs    the Array[Char].\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insertAll(index: Int, xs: Array[Char]): this.type \u003d {\n    underlying.insert(index, xs)\n    this\n  }\n\n  /** Calls String.valueOf on the given primitive value, and inserts the\n    *  String at the given index.\n    *\n    *  @param  index the offset position.\n    *  @param  x     a primitive value.\n    *  @return       this StringBuilder.\n    */\n  def insert(index: Int, x: Boolean): this.type \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Byte): this.type    \u003d insert(index, x.toInt)\n  def insert(index: Int, x: Short): this.type   \u003d insert(index, x.toInt)\n  def insert(index: Int, x: Int): this.type     \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Long): this.type    \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Float): this.type   \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Double): this.type  \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Char): this.type    \u003d insert(index, String.valueOf(x))\n\n  /** Sets the length of the character sequence.  If the current sequence\n    *  is shorter than the given length, it is padded with nulls; if it is\n    *  longer, it is truncated.\n    *\n    *  @param  len  the new length\n    *  @throws IndexOutOfBoundsException if the argument is negative.\n    */\n  def setLength(len: Int): Unit \u003d underlying.setLength(len)\n\n  def update(idx: Int, elem: Char): Unit \u003d underlying.setCharAt(idx, elem)\n\n\n  /** Like reverse, but destructively updates the target StringBuilder.\n   *\n   *  @return   the reversed StringBuilder (same as the target StringBuilder)\n   */\n  @deprecated(\"Use reverseInPlace instead\", \"2.13.0\")\n  final def reverseContents(): this.type \u003d reverseInPlace()\n\n  /** Like reverse, but destructively updates the target StringBuilder.\n   *\n   *  @return   the reversed StringBuilder (same as the target StringBuilder)\n   */\n  def reverseInPlace(): this.type \u003d {\n    underlying.reverse()\n    this\n  }\n\n\n  /** Returns the current capacity, which is the size of the underlying array.\n   *  A new array will be allocated if the current capacity is exceeded.\n   *\n   *  @return  the capacity\n   */\n  def capacity: Int \u003d underlying.capacity\n\n  /** Ensure that the capacity is at least the given argument.\n   *  If the argument is greater than the current capacity, new\n   *  storage will be allocated with size equal to the given\n   *  argument or to `(2 * capacity + 2)`, whichever is larger.\n   *\n   *  @param newCapacity    the minimum desired capacity.\n   */\n  def ensureCapacity(newCapacity: Int): Unit \u003d { underlying.ensureCapacity(newCapacity) }\n\n  /** Returns the Char at the specified index, counting from 0 as in Arrays.\n   *\n   *  @param  index   the index to look up\n   *  @return         the Char at the given index.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def charAt(index: Int): Char \u003d underlying.charAt(index)\n\n  /** Removes the Char at the specified index.  The sequence is\n   *  shortened by one.\n   *\n   *  @param  index  The index to remove.\n   *  @return        This StringBuilder.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def deleteCharAt(index: Int): this.type \u003d {\n    underlying.deleteCharAt(index)\n    this\n  }\n\n  /** Update the sequence at the given index to hold the specified Char.\n   *\n   *  @param  index   the index to modify.\n   *  @param  ch      the new Char.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def setCharAt(index: Int, ch: Char): this.type \u003d {\n    underlying.setCharAt(index, ch)\n    this\n  }\n\n  /** Returns a new String made up of a subsequence of this sequence,\n   *  beginning at the given index and extending to the end of the sequence.\n   *\n   *  target.substring(start)  is equivalent to  target.drop(start)\n   *\n   *  @param  start  The starting index, inclusive.\n   *  @return        The new String.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def substring(start: Int): String \u003d underlying.substring(start, length)\n\n  /** Returns a new String made up of a subsequence of this sequence,\n   *  beginning at the start index (inclusive) and extending to the\n   *  end index (exclusive).\n   *\n   *  target.substring(start, end)  is equivalent to  target.slice(start, end).mkString\n   *\n   *  @param  start  The beginning index, inclusive.\n   *  @param  end    The ending index, exclusive.\n   *  @return The new String.\n   *  @throws StringIndexOutOfBoundsException If either index is out of bounds,\n   *          or if start \u003e end.\n   */\n  def substring(start: Int, end: Int): String \u003d underlying.substring(start, end)\n\n  /** For implementing CharSequence.\n   */\n  def subSequence(start: Int, end: Int): java.lang.CharSequence \u003d\n    underlying.substring(start, end)\n\n  /** Finds the index of the first occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @return             the first applicable index where target occurs, or -1 if not found.\n   */\n  def indexOf(str: String): Int \u003d underlying.indexOf(str)\n\n  /** Finds the index of the first occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @param    fromIndex the smallest index in the source string to consider\n   *  @return             the first applicable index where target occurs, or -1 if not found.\n   */\n  def indexOf(str: String, fromIndex: Int): Int \u003d underlying.indexOf(str, fromIndex)\n\n  /** Finds the index of the last occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @return             the last applicable index where target occurs, or -1 if not found.\n   */\n  def lastIndexOf(str: String): Int \u003d underlying.lastIndexOf(str)\n\n  /** Finds the index of the last occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @param    fromIndex the smallest index in the source string to consider\n   *  @return             the last applicable index where target occurs, or -1 if not found.\n   */\n  def lastIndexOf(str: String, fromIndex: Int): Int \u003d underlying.lastIndexOf(str, fromIndex)\n\n  /** Tests whether this builder is empty.\n   *\n   *  This method is required for JDK15+ compatibility\n   *\n   *  @return  `true` if this builder contains nothing, `false` otherwise.\n   */\n  override def isEmpty: Boolean \u003d underlying.length() \u003d\u003d 0\n}\n\nobject StringBuilder {\n  @deprecated(\"Use `new StringBuilder()` instead of `StringBuilder.newBuilder`\", \"2.13.0\")\n  def newBuilder \u003d new StringBuilder\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:30:14 WARN  Using indexes to guess the definition of y
2024.04.26 02:30:25 INFO  compiling root (1 scala source)
2024.04.26 02:30:25 INFO  time: compiled root in 0.2s
Apr. 26, 2024 2:32:52 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1684
Apr. 26, 2024 2:32:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1703
Apr. 26, 2024 2:33:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1731
2024.04.26 02:33:13 INFO  compiling root (1 scala source)
2024.04.26 02:33:13 INFO  time: compiled root in 0.28s
Apr. 26, 2024 2:33:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/mutable/StringBuilder.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 2:34:26 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMATION: Unsupported notification method: $/setTrace
2024.04.26 02:37:21 INFO  compiling root-test (3 scala sources)
2024.04.26 02:37:21 INFO  time: compiled root-test in 0.25s
Apr. 26, 2024 2:38:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2188
Apr. 26, 2024 2:38:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2227
2024.04.26 02:39:29 INFO  compiling root (1 scala source)
2024.04.26 02:39:29 INFO  time: compiled root in 0.13s
2024.04.26 02:40:06 INFO  compiling root (1 scala source)
2024.04.26 02:40:06 INFO  time: compiled root in 95ms
Apr. 26, 2024 2:40:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2714
2024.04.26 02:40:43 INFO  compiling root (1 scala source)
2024.04.26 02:40:43 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 2:40:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Option.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nobject Option {\n\n  import scala.language.implicitConversions\n\n  /** An implicit conversion that converts an option to an iterable value */\n  implicit def option2Iterable[A](xo: Option[A]): Iterable[A] \u003d\n    if (xo.isEmpty) Iterable.empty else Iterable.single(xo.get)\n\n  /** An Option factory which creates Some(x) if the argument is not null,\n   *  and None if it is null.\n   *\n   *  @param  x the value\n   *  @return   Some(value) if value !\u003d null, None if value \u003d\u003d null\n   */\n  def apply[A](x: A): Option[A] \u003d if (x \u003d\u003d null) None else Some(x)\n\n  /** An Option factory which returns `None` in a manner consistent with\n   *  the collections hierarchy.\n   */\n  def empty[A] : Option[A] \u003d None\n\n  /** When a given condition is true, evaluates the `a` argument and returns\n   *  Some(a). When the condition is false, `a` is not evaluated and None is\n   *  returned.\n   */\n  def when[A](cond: Boolean)(a: \u003d\u003e A): Option[A] \u003d\n    if (cond) Some(a) else None\n\n  /** Unless a given condition is true, this will evaluate the `a` argument and\n   *  return Some(a). Otherwise, `a` is not evaluated and None is returned.\n   */\n  @inline def unless[A](cond: Boolean)(a: \u003d\u003e A): Option[A] \u003d\n    when(!cond)(a)\n}\n\n/** Represents optional values. Instances of `Option`\n *  are either an instance of $some or the object $none.\n *\n *  The most idiomatic way to use an $option instance is to treat it\n *  as a collection or monad and use `map`,`flatMap`, `filter`, or\n *  `foreach`:\n *\n *  {{{\n *  val name: Option[String] \u003d request getParameter \"name\"\n *  val upper \u003d name map { _.trim } filter { _.length !\u003d 0 } map { _.toUpperCase }\n *  println(upper getOrElse \"\")\n *  }}}\n *\n *  Note that this is equivalent to {{{\n *  val upper \u003d for {\n *    name \u003c- request getParameter \"name\"\n *    trimmed \u003c- Some(name.trim)\n *    upper \u003c- Some(trimmed.toUpperCase) if trimmed.length !\u003d 0\n *  } yield upper\n *  println(upper getOrElse \"\")\n *  }}}\n *\n *  Because of how for comprehension works, if $none is returned\n *  from `request.getParameter`, the entire expression results in\n *  $none\n *\n *  This allows for sophisticated chaining of $option values without\n *  having to check for the existence of a value.\n *\n * These are useful methods that exist for both $some and $none.\n *  - [[isDefined]] — True if not empty\n *  - [[isEmpty]] — True if empty\n *  - [[nonEmpty]] — True if not empty\n *  - [[orElse]] — Evaluate and return alternate optional value if empty\n *  - [[getOrElse]] — Evaluate and return alternate value if empty\n *  - [[get]] — Return value, throw exception if empty\n *  - [[fold]] —  Apply function on optional value, return default if empty\n *  - [[map]] — Apply a function on the optional value\n *  - [[flatMap]] — Same as map but function must return an optional value\n *  - [[foreach]] — Apply a procedure on option value\n *  - [[collect]] — Apply partial pattern match on optional value\n *  - [[filter]] — An optional value satisfies predicate\n *  - [[filterNot]] — An optional value doesn\u0027t satisfy predicate\n *  - [[exists]] — Apply predicate on optional value, or false if empty\n *  - [[forall]] — Apply predicate on optional value, or true if empty\n *  - [[contains]] — Checks if value equals optional value, or false if empty\n *  - [[zip]] — Combine two optional values to make a paired optional value\n *  - [[unzip]] — Split an optional pair to two optional values\n *  - [[unzip3]] — Split an optional triple to three optional values\n *  - [[toList]] — Unary list of optional value, otherwise the empty list\n *\n *  A less-idiomatic way to use $option values is via pattern matching: {{{\n *  val nameMaybe \u003d request getParameter \"name\"\n *  nameMaybe match {\n *    case Some(name) \u003d\u003e\n *      println(name.trim.toUppercase)\n *    case None \u003d\u003e\n *      println(\"No name value\")\n *  }\n *  }}}\n *\n * Interacting with code that can occasionally return null can be\n * safely wrapped in $option to become $none and $some otherwise. {{{\n * val abc \u003d new java.util.HashMap[Int, String]\n * abc.put(1, \"A\")\n * bMaybe \u003d Option(abc.get(2))\n * bMaybe match {\n *   case Some(b) \u003d\u003e\n *     println(s\"Found \\$b\")\n *   case None \u003d\u003e\n *     println(\"Not found\")\n * }\n * }}}\n *\n *  @note Many of the methods in here are duplicative with those\n *  in the Iterable hierarchy, but they are duplicated for a reason:\n *  the implicit conversion tends to leave one with an Iterable in\n *  situations where one could have retained an Option.\n *\n *  @define none `None`\n *  @define some [[scala.Some]]\n *  @define option [[scala.Option]]\n *  @define p `p`\n *  @define f `f`\n *  @define coll option\n *  @define Coll `Option`\n *  @define orderDependent\n *  @define orderDependentFold\n *  @define mayNotTerminateInf\n *  @define willNotTerminateInf\n *  @define collectExample\n *  @define undefinedorder\n */\n@SerialVersionUID(-114498752079829388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nsealed abstract class Option[+A] extends IterableOnce[A] with Product with Serializable {\n  self \u003d\u003e\n\n  /** Returns true if the option is $none, false otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e false\n   *   case None    \u003d\u003e true\n   * }\n   * }}}\n   */\n  final def isEmpty: Boolean \u003d this eq None\n\n  /** Returns true if the option is an instance of $some, false otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e true\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   */\n  final def isDefined: Boolean \u003d !isEmpty\n\n  override final def knownSize: Int \u003d if (isEmpty) 0 else 1\n\n  /** Returns the option\u0027s value.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e throw new Exception\n   * }\n   * }}}\n   *  @note The option must be nonempty.\n   *  @throws NoSuchElementException if the option is empty.\n   */\n  def get: A\n\n  /** Returns the option\u0027s value if the option is nonempty, otherwise\n   * return the result of evaluating `default`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e default\n   * }\n   * }}}\n   *\n   *  @param default  the default expression.\n   */\n  @inline final def getOrElse[B \u003e: A](default: \u003d\u003e B): B \u003d\n    if (isEmpty) default else this.get\n\n  /** Returns the option\u0027s value if it is nonempty,\n   * or `null` if it is empty.\n   *\n   * Although the use of null is discouraged, code written to use\n   * $option must often interface with code that expects and returns nulls.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e null\n   * }\n   * }}}\n   * @example {{{\n   * val initialText: Option[String] \u003d getInitialText\n   * val textField \u003d new JComponent(initialText.orNull,20)\n   * }}}\n   */\n  @inline final def orNull[A1 \u003e: A](implicit ev: Null \u003c:\u003c A1): A1 \u003d this getOrElse ev(null)\n\n  /** Returns a $some containing the result of applying $f to this $option\u0027s\n   * value if this $option is nonempty.\n   * Otherwise return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Some(f(x))\n   *   case None    \u003d\u003e None\n   * }\n   * }}}\n   *  @note This is similar to `flatMap` except here,\n   *  $f does not need to wrap its result in an $option.\n   *\n   *  @param  f   the function to apply\n   *  @see flatMap\n   *  @see foreach\n   */\n  @inline final def map[B](f: A \u003d\u003e B): Option[B] \u003d\n    if (isEmpty) None else Some(f(this.get))\n\n  /** Returns the result of applying $f to this $option\u0027s\n   *  value if the $option is nonempty.  Otherwise, evaluates\n   *  expression `ifEmpty`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e ifEmpty\n   * }\n   * }}}\n   * This is also equivalent to:\n   * {{{\n   * option map f getOrElse ifEmpty\n   * }}}\n   *  @param  ifEmpty the expression to evaluate if empty.\n   *  @param  f       the function to apply if nonempty.\n   */\n  @inline final def fold[B](ifEmpty: \u003d\u003e B)(f: A \u003d\u003e B): B \u003d\n    if (isEmpty) ifEmpty else f(this.get)\n\n  /** Returns the result of applying $f to this $option\u0027s value if\n   * this $option is nonempty.\n   * Returns $none if this $option is empty.\n   * Slightly different from `map` in that $f is expected to\n   * return an $option (which could be $none).\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e None\n   * }\n   * }}}\n   *  @param  f   the function to apply\n   *  @see map\n   *  @see foreach\n   */\n  @inline final def flatMap[B](f: A \u003d\u003e Option[B]): Option[B] \u003d\n    if (isEmpty) None else f(this.get)\n\n  /** Returns the nested $option value if it is nonempty.  Otherwise,\n   * return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(Some(b)) \u003d\u003e Some(b)\n   *   case _             \u003d\u003e None\n   * }\n   * }}}\n   * @example {{{\n   * Some(Some(\"something\")).flatten\n   * }}}\n   *\n   * @param ev an implicit conversion that asserts that the value is\n   *           also an $option.\n   * @see flatMap\n   */\n  def flatten[B](implicit ev: A \u003c:\u003c Option[B]): Option[B] \u003d\n    if (isEmpty) None else ev(this.get)\n\n  /** Returns this $option if it is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 applying the predicate $p to\n   * this $option\u0027s value returns true. Otherwise, return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) if p(x) \u003d\u003e Some(x)\n   *   case _               \u003d\u003e None\n   * }\n   * }}}\n   *  @param  p   the predicate used for testing.\n   */\n  @inline final def filter(p: A \u003d\u003e Boolean): Option[A] \u003d\n    if (isEmpty || p(this.get)) this else None\n\n  /** Returns this $option if it is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 applying the predicate $p to\n   * this $option\u0027s value returns false. Otherwise, return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) if !p(x) \u003d\u003e Some(x)\n   *   case _                \u003d\u003e None\n   * }\n   * }}}\n   *  @param  p   the predicate used for testing.\n   */\n  @inline final def filterNot(p: A \u003d\u003e Boolean): Option[A] \u003d\n    if (isEmpty || !p(this.get)) this else None\n\n  /** Returns false if the option is $none, true otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e true\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @note   Implemented here to avoid the implicit conversion to Iterable.\n   */\n  final def nonEmpty: Boolean \u003d isDefined\n\n  /** Necessary to keep $option from being implicitly converted to\n   *  [[scala.collection.Iterable]] in `for` comprehensions.\n   */\n  @inline final def withFilter(p: A \u003d\u003e Boolean): WithFilter \u003d new WithFilter(p)\n\n  /** We need a whole WithFilter class to honor the \"doesn\u0027t create a new\n   *  collection\" contract even though it seems unlikely to matter much in a\n   *  collection with max size 1.\n   */\n  class WithFilter(p: A \u003d\u003e Boolean) {\n    def map[B](f: A \u003d\u003e B): Option[B] \u003d self filter p map f\n    def flatMap[B](f: A \u003d\u003e Option[B]): Option[B] \u003d self filter p flatMap f\n    def foreach[U](f: A \u003d\u003e U): Unit \u003d self filter p foreach f\n    def withFilter(q: A \u003d\u003e Boolean): WithFilter \u003d new WithFilter(x \u003d\u003e p(x) \u0026\u0026 q(x))\n  }\n\n  /** Tests whether the option contains a given value as an element.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x \u003d\u003d elem\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @example {{{\n   *  // Returns true because Some instance contains string \"something\" which equals \"something\".\n   *  Some(\"something\") contains \"something\"\n   *\n   *  // Returns false because \"something\" !\u003d \"anything\".\n   *  Some(\"something\") contains \"anything\"\n   *\n   *  // Returns false when method called on None.\n   *  None contains \"anything\"\n   *  }}}\n   *\n   *  @param elem the element to test.\n   *  @return `true` if the option has an element that is equal (as\n   *  determined by `\u003d\u003d`) to `elem`, `false` otherwise.\n   */\n  final def contains[A1 \u003e: A](elem: A1): Boolean \u003d\n    !isEmpty \u0026\u0026 this.get \u003d\u003d elem\n\n  /** Returns true if this option is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 the predicate\n   * $p returns true when applied to this $option\u0027s value.\n   * Otherwise, returns false.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e p(x)\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @param  p   the predicate to test\n   */\n  @inline final def exists(p: A \u003d\u003e Boolean): Boolean \u003d\n    !isEmpty \u0026\u0026 p(this.get)\n\n  /** Returns true if this option is empty \u0027\u0027\u0027or\u0027\u0027\u0027 the predicate\n   * $p returns true when applied to this $option\u0027s value.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e p(x)\n   *   case None    \u003d\u003e true\n   * }\n   * }}}\n   *  @param  p   the predicate to test\n   */\n  @inline final def forall(p: A \u003d\u003e Boolean): Boolean \u003d isEmpty || p(this.get)\n\n  /** Apply the given procedure $f to the option\u0027s value,\n   *  if it is nonempty. Otherwise, do nothing.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e ()\n   * }\n   * }}}\n   *  @param  f   the procedure to apply.\n   *  @see map\n   *  @see flatMap\n   */\n  @inline final def foreach[U](f: A \u003d\u003e U): Unit \u003d {\n    if (!isEmpty) f(this.get)\n  }\n\n  /** Returns a $some containing the result of\n   * applying `pf` to this $option\u0027s contained\n   * value, \u0027\u0027\u0027if\u0027\u0027\u0027 this option is\n   * nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 `pf` is defined for that value.\n   * Returns $none otherwise.\n   *\n   *  @example {{{\n   *  // Returns Some(HTTP) because the partial function covers the case.\n   *  Some(\"http\") collect {case \"http\" \u003d\u003e \"HTTP\"}\n   *\n   *  // Returns None because the partial function doesn\u0027t cover the case.\n   *  Some(\"ftp\") collect {case \"http\" \u003d\u003e \"HTTP\"}\n   *\n   *  // Returns None because the option is empty. There is no value to pass to the partial function.\n   *  None collect {case value \u003d\u003e value}\n   *  }}}\n   *\n   *  @param  pf   the partial function.\n   *  @return the result of applying `pf` to this $option\u0027s\n   *  value (if possible), or $none.\n   */\n  @inline final def collect[B](pf: PartialFunction[A, B]): Option[B] \u003d\n    if (!isEmpty) pf.lift(this.get) else None\n\n  /** Returns this $option if it is nonempty,\n   *  otherwise return the result of evaluating `alternative`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Some(x)\n   *   case None    \u003d\u003e alternative\n   * }\n   * }}}\n   *  @param alternative the alternative expression.\n   */\n  @inline final def orElse[B \u003e: A](alternative: \u003d\u003e Option[B]): Option[B] \u003d\n    if (isEmpty) alternative else this\n\n  /** Returns a $some formed from this option and another option\n   *  by combining the corresponding elements in a pair.\n   *  If either of the two options is empty, $none is returned.\n   *\n   *  This is equivalent to:\n   *  {{{\n   *  (option1, option2) match {\n   *    case (Some(x), Some(y)) \u003d\u003e Some((x, y))\n   *    case _                  \u003d\u003e None\n   *  }\n   *  }}}\n   *  @example {{{\n   *  // Returns Some((\"foo\", \"bar\")) because both options are nonempty.\n   *  Some(\"foo\") zip Some(\"bar\")\n   *\n   *  // Returns None because `that` option is empty.\n   *  Some(\"foo\") zip None\n   *\n   *  // Returns None because `this` option is empty.\n   *  None zip Some(\"bar\")\n   *  }}}\n   *\n   *  @param  that   the options which is going to be zipped\n   */\n  final def zip[A1 \u003e: A, B](that: Option[B]): Option[(A1, B)] \u003d\n    if (isEmpty || that.isEmpty) None else Some((this.get, that.get))\n\n  /** Converts an Option of a pair into an Option of the first element and an Option of the second element.\n    *\n    *  This is equivalent to:\n    *  {{{\n    *  option match {\n    *    case Some((x, y)) \u003d\u003e (Some(x), Some(y))\n    *    case _            \u003d\u003e (None,    None)\n    *  }\n    *  }}}\n    *  @tparam A1    the type of the first half of the element pair\n    *  @tparam A2    the type of the second half of the element pair\n    *  @param asPair an implicit conversion which asserts that the element type\n    *                of this Option is a pair.\n    *  @return       a pair of Options, containing, respectively, the first and second half\n    *                of the element pair of this Option.\n    */\n  final def unzip[A1, A2](implicit asPair: A \u003c:\u003c (A1, A2)): (Option[A1], Option[A2]) \u003d {\n    if (isEmpty)\n      (None, None)\n    else {\n      val e \u003d asPair(this.get)\n      (Some(e._1), Some(e._2))\n    }\n  }\n\n  /** Converts an Option of a triple into three Options, one containing the element from each position of the triple.\n    *\n    *  This is equivalent to:\n    *  {{{\n    *  option match {\n    *    case Some((x, y, z)) \u003d\u003e (Some(x), Some(y), Some(z))\n    *    case _               \u003d\u003e (None,    None,    None)\n    *  }\n    *  }}}\n    *  @tparam A1      the type of the first of three elements in the triple\n    *  @tparam A2      the type of the second of three elements in the triple\n    *  @tparam A3      the type of the third of three elements in the triple\n    *  @param asTriple an implicit conversion which asserts that the element type\n    *                  of this Option is a triple.\n    *  @return         a triple of Options, containing, respectively, the first, second, and third\n    *                  elements from the element triple of this Option.\n    */\n  final def unzip3[A1, A2, A3](implicit asTriple: A \u003c:\u003c (A1, A2, A3)): (Option[A1], Option[A2], Option[A3]) \u003d {\n    if (isEmpty)\n      (None, None, None)\n    else {\n      val e \u003d asTriple(this.get)\n      (Some(e._1), Some(e._2), Some(e._3))\n    }\n  }\n\n  /** Returns a singleton iterator returning the $option\u0027s value\n   * if it is nonempty, or an empty iterator if the option is empty.\n   */\n  def iterator: Iterator[A] \u003d\n    if (isEmpty) collection.Iterator.empty else collection.Iterator.single(this.get)\n\n  /** Returns a singleton list containing the $option\u0027s value\n   * if it is nonempty, or the empty list if the $option is empty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e List(x)\n   *   case None    \u003d\u003e Nil\n   * }\n   * }}}\n   */\n  def toList: List[A] \u003d\n    if (isEmpty) List() else new ::(this.get, Nil)\n\n  /** Returns a [[scala.util.Left]] containing the given\n   * argument `left` if this $option is empty, or\n   * a [[scala.util.Right]] containing this $option\u0027s value if\n   * this is nonempty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Right(x)\n   *   case None    \u003d\u003e Left(left)\n   * }\n   * }}}\n   * @param left the expression to evaluate and return if this is empty\n   * @see toLeft\n   */\n  @inline final def toRight[X](left: \u003d\u003e X): Either[X, A] \u003d\n    if (isEmpty) Left(left) else Right(this.get)\n\n  /** Returns a [[scala.util.Right]] containing the given\n   * argument `right` if this is empty, or\n   * a [[scala.util.Left]] containing this $option\u0027s value\n   * if this $option is nonempty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Left(x)\n   *   case None    \u003d\u003e Right(right)\n   * }\n   * }}}\n   * @param right the expression to evaluate and return if this is empty\n   * @see toRight\n   */\n  @inline final def toLeft[X](right: \u003d\u003e X): Either[A, X] \u003d\n    if (isEmpty) Right(right) else Left(this.get)\n}\n\n/** Class `Some[A]` represents existing values of type\n *  `A`.\n */\n@SerialVersionUID(1234815782226070388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nfinal case class Some[+A](value: A) extends Option[A] {\n  def get: A \u003d value\n}\n\n\n/** This case object represents non-existent values.\n */\n@SerialVersionUID(5066590221178148012L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\ncase object None extends Option[Nothing] {\n  def get: Nothing \u003d throw new NoSuchElementException(\"None.get\")\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 2:40:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Option.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:40:43 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 2:40:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Option.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nobject Option {\n\n  import scala.language.implicitConversions\n\n  /** An implicit conversion that converts an option to an iterable value */\n  implicit def option2Iterable[A](xo: Option[A]): Iterable[A] \u003d\n    if (xo.isEmpty) Iterable.empty else Iterable.single(xo.get)\n\n  /** An Option factory which creates Some(x) if the argument is not null,\n   *  and None if it is null.\n   *\n   *  @param  x the value\n   *  @return   Some(value) if value !\u003d null, None if value \u003d\u003d null\n   */\n  def apply[A](x: A): Option[A] \u003d if (x \u003d\u003d null) None else Some(x)\n\n  /** An Option factory which returns `None` in a manner consistent with\n   *  the collections hierarchy.\n   */\n  def empty[A] : Option[A] \u003d None\n\n  /** When a given condition is true, evaluates the `a` argument and returns\n   *  Some(a). When the condition is false, `a` is not evaluated and None is\n   *  returned.\n   */\n  def when[A](cond: Boolean)(a: \u003d\u003e A): Option[A] \u003d\n    if (cond) Some(a) else None\n\n  /** Unless a given condition is true, this will evaluate the `a` argument and\n   *  return Some(a). Otherwise, `a` is not evaluated and None is returned.\n   */\n  @inline def unless[A](cond: Boolean)(a: \u003d\u003e A): Option[A] \u003d\n    when(!cond)(a)\n}\n\n/** Represents optional values. Instances of `Option`\n *  are either an instance of $some or the object $none.\n *\n *  The most idiomatic way to use an $option instance is to treat it\n *  as a collection or monad and use `map`,`flatMap`, `filter`, or\n *  `foreach`:\n *\n *  {{{\n *  val name: Option[String] \u003d request getParameter \"name\"\n *  val upper \u003d name map { _.trim } filter { _.length !\u003d 0 } map { _.toUpperCase }\n *  println(upper getOrElse \"\")\n *  }}}\n *\n *  Note that this is equivalent to {{{\n *  val upper \u003d for {\n *    name \u003c- request getParameter \"name\"\n *    trimmed \u003c- Some(name.trim)\n *    upper \u003c- Some(trimmed.toUpperCase) if trimmed.length !\u003d 0\n *  } yield upper\n *  println(upper getOrElse \"\")\n *  }}}\n *\n *  Because of how for comprehension works, if $none is returned\n *  from `request.getParameter`, the entire expression results in\n *  $none\n *\n *  This allows for sophisticated chaining of $option values without\n *  having to check for the existence of a value.\n *\n * These are useful methods that exist for both $some and $none.\n *  - [[isDefined]] — True if not empty\n *  - [[isEmpty]] — True if empty\n *  - [[nonEmpty]] — True if not empty\n *  - [[orElse]] — Evaluate and return alternate optional value if empty\n *  - [[getOrElse]] — Evaluate and return alternate value if empty\n *  - [[get]] — Return value, throw exception if empty\n *  - [[fold]] —  Apply function on optional value, return default if empty\n *  - [[map]] — Apply a function on the optional value\n *  - [[flatMap]] — Same as map but function must return an optional value\n *  - [[foreach]] — Apply a procedure on option value\n *  - [[collect]] — Apply partial pattern match on optional value\n *  - [[filter]] — An optional value satisfies predicate\n *  - [[filterNot]] — An optional value doesn\u0027t satisfy predicate\n *  - [[exists]] — Apply predicate on optional value, or false if empty\n *  - [[forall]] — Apply predicate on optional value, or true if empty\n *  - [[contains]] — Checks if value equals optional value, or false if empty\n *  - [[zip]] — Combine two optional values to make a paired optional value\n *  - [[unzip]] — Split an optional pair to two optional values\n *  - [[unzip3]] — Split an optional triple to three optional values\n *  - [[toList]] — Unary list of optional value, otherwise the empty list\n *\n *  A less-idiomatic way to use $option values is via pattern matching: {{{\n *  val nameMaybe \u003d request getParameter \"name\"\n *  nameMaybe match {\n *    case Some(name) \u003d\u003e\n *      println(name.trim.toUppercase)\n *    case None \u003d\u003e\n *      println(\"No name value\")\n *  }\n *  }}}\n *\n * Interacting with code that can occasionally return null can be\n * safely wrapped in $option to become $none and $some otherwise. {{{\n * val abc \u003d new java.util.HashMap[Int, String]\n * abc.put(1, \"A\")\n * bMaybe \u003d Option(abc.get(2))\n * bMaybe match {\n *   case Some(b) \u003d\u003e\n *     println(s\"Found \\$b\")\n *   case None \u003d\u003e\n *     println(\"Not found\")\n * }\n * }}}\n *\n *  @note Many of the methods in here are duplicative with those\n *  in the Iterable hierarchy, but they are duplicated for a reason:\n *  the implicit conversion tends to leave one with an Iterable in\n *  situations where one could have retained an Option.\n *\n *  @define none `None`\n *  @define some [[scala.Some]]\n *  @define option [[scala.Option]]\n *  @define p `p`\n *  @define f `f`\n *  @define coll option\n *  @define Coll `Option`\n *  @define orderDependent\n *  @define orderDependentFold\n *  @define mayNotTerminateInf\n *  @define willNotTerminateInf\n *  @define collectExample\n *  @define undefinedorder\n */\n@SerialVersionUID(-114498752079829388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nsealed abstract class Option[+A] extends IterableOnce[A] with Product with Serializable {\n  self \u003d\u003e\n\n  /** Returns true if the option is $none, false otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e false\n   *   case None    \u003d\u003e true\n   * }\n   * }}}\n   */\n  final def isEmpty: Boolean \u003d this eq None\n\n  /** Returns true if the option is an instance of $some, false otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e true\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   */\n  final def isDefined: Boolean \u003d !isEmpty\n\n  override final def knownSize: Int \u003d if (isEmpty) 0 else 1\n\n  /** Returns the option\u0027s value.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e throw new Exception\n   * }\n   * }}}\n   *  @note The option must be nonempty.\n   *  @throws NoSuchElementException if the option is empty.\n   */\n  def get: A\n\n  /** Returns the option\u0027s value if the option is nonempty, otherwise\n   * return the result of evaluating `default`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e default\n   * }\n   * }}}\n   *\n   *  @param default  the default expression.\n   */\n  @inline final def getOrElse[B \u003e: A](default: \u003d\u003e B): B \u003d\n    if (isEmpty) default else this.get\n\n  /** Returns the option\u0027s value if it is nonempty,\n   * or `null` if it is empty.\n   *\n   * Although the use of null is discouraged, code written to use\n   * $option must often interface with code that expects and returns nulls.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e null\n   * }\n   * }}}\n   * @example {{{\n   * val initialText: Option[String] \u003d getInitialText\n   * val textField \u003d new JComponent(initialText.orNull,20)\n   * }}}\n   */\n  @inline final def orNull[A1 \u003e: A](implicit ev: Null \u003c:\u003c A1): A1 \u003d this getOrElse ev(null)\n\n  /** Returns a $some containing the result of applying $f to this $option\u0027s\n   * value if this $option is nonempty.\n   * Otherwise return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Some(f(x))\n   *   case None    \u003d\u003e None\n   * }\n   * }}}\n   *  @note This is similar to `flatMap` except here,\n   *  $f does not need to wrap its result in an $option.\n   *\n   *  @param  f   the function to apply\n   *  @see flatMap\n   *  @see foreach\n   */\n  @inline final def map[B](f: A \u003d\u003e B): Option[B] \u003d\n    if (isEmpty) None else Some(f(this.get))\n\n  /** Returns the result of applying $f to this $option\u0027s\n   *  value if the $option is nonempty.  Otherwise, evaluates\n   *  expression `ifEmpty`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e ifEmpty\n   * }\n   * }}}\n   * This is also equivalent to:\n   * {{{\n   * option map f getOrElse ifEmpty\n   * }}}\n   *  @param  ifEmpty the expression to evaluate if empty.\n   *  @param  f       the function to apply if nonempty.\n   */\n  @inline final def fold[B](ifEmpty: \u003d\u003e B)(f: A \u003d\u003e B): B \u003d\n    if (isEmpty) ifEmpty else f(this.get)\n\n  /** Returns the result of applying $f to this $option\u0027s value if\n   * this $option is nonempty.\n   * Returns $none if this $option is empty.\n   * Slightly different from `map` in that $f is expected to\n   * return an $option (which could be $none).\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e None\n   * }\n   * }}}\n   *  @param  f   the function to apply\n   *  @see map\n   *  @see foreach\n   */\n  @inline final def flatMap[B](f: A \u003d\u003e Option[B]): Option[B] \u003d\n    if (isEmpty) None else f(this.get)\n\n  /** Returns the nested $option value if it is nonempty.  Otherwise,\n   * return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(Some(b)) \u003d\u003e Some(b)\n   *   case _             \u003d\u003e None\n   * }\n   * }}}\n   * @example {{{\n   * Some(Some(\"something\")).flatten\n   * }}}\n   *\n   * @param ev an implicit conversion that asserts that the value is\n   *           also an $option.\n   * @see flatMap\n   */\n  def flatten[B](implicit ev: A \u003c:\u003c Option[B]): Option[B] \u003d\n    if (isEmpty) None else ev(this.get)\n\n  /** Returns this $option if it is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 applying the predicate $p to\n   * this $option\u0027s value returns true. Otherwise, return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) if p(x) \u003d\u003e Some(x)\n   *   case _               \u003d\u003e None\n   * }\n   * }}}\n   *  @param  p   the predicate used for testing.\n   */\n  @inline final def filter(p: A \u003d\u003e Boolean): Option[A] \u003d\n    if (isEmpty || p(this.get)) this else None\n\n  /** Returns this $option if it is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 applying the predicate $p to\n   * this $option\u0027s value returns false. Otherwise, return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) if !p(x) \u003d\u003e Some(x)\n   *   case _                \u003d\u003e None\n   * }\n   * }}}\n   *  @param  p   the predicate used for testing.\n   */\n  @inline final def filterNot(p: A \u003d\u003e Boolean): Option[A] \u003d\n    if (isEmpty || !p(this.get)) this else None\n\n  /** Returns false if the option is $none, true otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e true\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @note   Implemented here to avoid the implicit conversion to Iterable.\n   */\n  final def nonEmpty: Boolean \u003d isDefined\n\n  /** Necessary to keep $option from being implicitly converted to\n   *  [[scala.collection.Iterable]] in `for` comprehensions.\n   */\n  @inline final def withFilter(p: A \u003d\u003e Boolean): WithFilter \u003d new WithFilter(p)\n\n  /** We need a whole WithFilter class to honor the \"doesn\u0027t create a new\n   *  collection\" contract even though it seems unlikely to matter much in a\n   *  collection with max size 1.\n   */\n  class WithFilter(p: A \u003d\u003e Boolean) {\n    def map[B](f: A \u003d\u003e B): Option[B] \u003d self filter p map f\n    def flatMap[B](f: A \u003d\u003e Option[B]): Option[B] \u003d self filter p flatMap f\n    def foreach[U](f: A \u003d\u003e U): Unit \u003d self filter p foreach f\n    def withFilter(q: A \u003d\u003e Boolean): WithFilter \u003d new WithFilter(x \u003d\u003e p(x) \u0026\u0026 q(x))\n  }\n\n  /** Tests whether the option contains a given value as an element.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x \u003d\u003d elem\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @example {{{\n   *  // Returns true because Some instance contains string \"something\" which equals \"something\".\n   *  Some(\"something\") contains \"something\"\n   *\n   *  // Returns false because \"something\" !\u003d \"anything\".\n   *  Some(\"something\") contains \"anything\"\n   *\n   *  // Returns false when method called on None.\n   *  None contains \"anything\"\n   *  }}}\n   *\n   *  @param elem the element to test.\n   *  @return `true` if the option has an element that is equal (as\n   *  determined by `\u003d\u003d`) to `elem`, `false` otherwise.\n   */\n  final def contains[A1 \u003e: A](elem: A1): Boolean \u003d\n    !isEmpty \u0026\u0026 this.get \u003d\u003d elem\n\n  /** Returns true if this option is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 the predicate\n   * $p returns true when applied to this $option\u0027s value.\n   * Otherwise, returns false.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e p(x)\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @param  p   the predicate to test\n   */\n  @inline final def exists(p: A \u003d\u003e Boolean): Boolean \u003d\n    !isEmpty \u0026\u0026 p(this.get)\n\n  /** Returns true if this option is empty \u0027\u0027\u0027or\u0027\u0027\u0027 the predicate\n   * $p returns true when applied to this $option\u0027s value.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e p(x)\n   *   case None    \u003d\u003e true\n   * }\n   * }}}\n   *  @param  p   the predicate to test\n   */\n  @inline final def forall(p: A \u003d\u003e Boolean): Boolean \u003d isEmpty || p(this.get)\n\n  /** Apply the given procedure $f to the option\u0027s value,\n   *  if it is nonempty. Otherwise, do nothing.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e ()\n   * }\n   * }}}\n   *  @param  f   the procedure to apply.\n   *  @see map\n   *  @see flatMap\n   */\n  @inline final def foreach[U](f: A \u003d\u003e U): Unit \u003d {\n    if (!isEmpty) f(this.get)\n  }\n\n  /** Returns a $some containing the result of\n   * applying `pf` to this $option\u0027s contained\n   * value, \u0027\u0027\u0027if\u0027\u0027\u0027 this option is\n   * nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 `pf` is defined for that value.\n   * Returns $none otherwise.\n   *\n   *  @example {{{\n   *  // Returns Some(HTTP) because the partial function covers the case.\n   *  Some(\"http\") collect {case \"http\" \u003d\u003e \"HTTP\"}\n   *\n   *  // Returns None because the partial function doesn\u0027t cover the case.\n   *  Some(\"ftp\") collect {case \"http\" \u003d\u003e \"HTTP\"}\n   *\n   *  // Returns None because the option is empty. There is no value to pass to the partial function.\n   *  None collect {case value \u003d\u003e value}\n   *  }}}\n   *\n   *  @param  pf   the partial function.\n   *  @return the result of applying `pf` to this $option\u0027s\n   *  value (if possible), or $none.\n   */\n  @inline final def collect[B](pf: PartialFunction[A, B]): Option[B] \u003d\n    if (!isEmpty) pf.lift(this.get) else None\n\n  /** Returns this $option if it is nonempty,\n   *  otherwise return the result of evaluating `alternative`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Some(x)\n   *   case None    \u003d\u003e alternative\n   * }\n   * }}}\n   *  @param alternative the alternative expression.\n   */\n  @inline final def orElse[B \u003e: A](alternative: \u003d\u003e Option[B]): Option[B] \u003d\n    if (isEmpty) alternative else this\n\n  /** Returns a $some formed from this option and another option\n   *  by combining the corresponding elements in a pair.\n   *  If either of the two options is empty, $none is returned.\n   *\n   *  This is equivalent to:\n   *  {{{\n   *  (option1, option2) match {\n   *    case (Some(x), Some(y)) \u003d\u003e Some((x, y))\n   *    case _                  \u003d\u003e None\n   *  }\n   *  }}}\n   *  @example {{{\n   *  // Returns Some((\"foo\", \"bar\")) because both options are nonempty.\n   *  Some(\"foo\") zip Some(\"bar\")\n   *\n   *  // Returns None because `that` option is empty.\n   *  Some(\"foo\") zip None\n   *\n   *  // Returns None because `this` option is empty.\n   *  None zip Some(\"bar\")\n   *  }}}\n   *\n   *  @param  that   the options which is going to be zipped\n   */\n  final def zip[A1 \u003e: A, B](that: Option[B]): Option[(A1, B)] \u003d\n    if (isEmpty || that.isEmpty) None else Some((this.get, that.get))\n\n  /** Converts an Option of a pair into an Option of the first element and an Option of the second element.\n    *\n    *  This is equivalent to:\n    *  {{{\n    *  option match {\n    *    case Some((x, y)) \u003d\u003e (Some(x), Some(y))\n    *    case _            \u003d\u003e (None,    None)\n    *  }\n    *  }}}\n    *  @tparam A1    the type of the first half of the element pair\n    *  @tparam A2    the type of the second half of the element pair\n    *  @param asPair an implicit conversion which asserts that the element type\n    *                of this Option is a pair.\n    *  @return       a pair of Options, containing, respectively, the first and second half\n    *                of the element pair of this Option.\n    */\n  final def unzip[A1, A2](implicit asPair: A \u003c:\u003c (A1, A2)): (Option[A1], Option[A2]) \u003d {\n    if (isEmpty)\n      (None, None)\n    else {\n      val e \u003d asPair(this.get)\n      (Some(e._1), Some(e._2))\n    }\n  }\n\n  /** Converts an Option of a triple into three Options, one containing the element from each position of the triple.\n    *\n    *  This is equivalent to:\n    *  {{{\n    *  option match {\n    *    case Some((x, y, z)) \u003d\u003e (Some(x), Some(y), Some(z))\n    *    case _               \u003d\u003e (None,    None,    None)\n    *  }\n    *  }}}\n    *  @tparam A1      the type of the first of three elements in the triple\n    *  @tparam A2      the type of the second of three elements in the triple\n    *  @tparam A3      the type of the third of three elements in the triple\n    *  @param asTriple an implicit conversion which asserts that the element type\n    *                  of this Option is a triple.\n    *  @return         a triple of Options, containing, respectively, the first, second, and third\n    *                  elements from the element triple of this Option.\n    */\n  final def unzip3[A1, A2, A3](implicit asTriple: A \u003c:\u003c (A1, A2, A3)): (Option[A1], Option[A2], Option[A3]) \u003d {\n    if (isEmpty)\n      (None, None, None)\n    else {\n      val e \u003d asTriple(this.get)\n      (Some(e._1), Some(e._2), Some(e._3))\n    }\n  }\n\n  /** Returns a singleton iterator returning the $option\u0027s value\n   * if it is nonempty, or an empty iterator if the option is empty.\n   */\n  def iterator: Iterator[A] \u003d\n    if (isEmpty) collection.Iterator.empty else collection.Iterator.single(this.get)\n\n  /** Returns a singleton list containing the $option\u0027s value\n   * if it is nonempty, or the empty list if the $option is empty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e List(x)\n   *   case None    \u003d\u003e Nil\n   * }\n   * }}}\n   */\n  def toList: List[A] \u003d\n    if (isEmpty) List() else new ::(this.get, Nil)\n\n  /** Returns a [[scala.util.Left]] containing the given\n   * argument `left` if this $option is empty, or\n   * a [[scala.util.Right]] containing this $option\u0027s value if\n   * this is nonempty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Right(x)\n   *   case None    \u003d\u003e Left(left)\n   * }\n   * }}}\n   * @param left the expression to evaluate and return if this is empty\n   * @see toLeft\n   */\n  @inline final def toRight[X](left: \u003d\u003e X): Either[X, A] \u003d\n    if (isEmpty) Left(left) else Right(this.get)\n\n  /** Returns a [[scala.util.Right]] containing the given\n   * argument `right` if this is empty, or\n   * a [[scala.util.Left]] containing this $option\u0027s value\n   * if this $option is nonempty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Left(x)\n   *   case None    \u003d\u003e Right(right)\n   * }\n   * }}}\n   * @param right the expression to evaluate and return if this is empty\n   * @see toRight\n   */\n  @inline final def toLeft[X](right: \u003d\u003e X): Either[A, X] \u003d\n    if (isEmpty) Right(right) else Left(this.get)\n}\n\n/** Class `Some[A]` represents existing values of type\n *  `A`.\n */\n@SerialVersionUID(1234815782226070388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nfinal case class Some[+A](value: A) extends Option[A] {\n  def get: A \u003d value\n}\n\n\n/** This case object represents non-existent values.\n */\n@SerialVersionUID(5066590221178148012L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\ncase object None extends Option[Nothing] {\n  def get: Nothing \u003d throw new NoSuchElementException(\"None.get\")\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:40:43 INFO  time: compiled root in 0.15s
2024.04.26 02:41:36 INFO  compiling root (1 scala source)
2024.04.26 02:41:36 INFO  time: compiled root in 0.11s
Apr. 26, 2024 2:43:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Option.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:47:48 INFO  compiling root (1 scala source)
2024.04.26 02:47:48 INFO  time: compiled root in 0.11s
2024.04.26 02:47:57 INFO  compiling root (1 scala source)
2024.04.26 02:47:57 INFO  time: compiled root in 0.11s
2024.04.26 02:48:13 INFO  compiling root (1 scala source)
2024.04.26 02:48:13 INFO  time: compiled root in 95ms
2024.04.26 02:48:29 INFO  compiling root (1 scala source)
2024.04.26 02:48:29 INFO  time: compiled root in 95ms
Apr. 26, 2024 2:50:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3803
2024.04.26 02:50:38 INFO  compiling root (1 scala source)
2024.04.26 02:50:38 INFO  time: compiled root in 0.21s
Apr. 26, 2024 2:50:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3838
2024.04.26 02:51:02 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 2:51:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Option.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nobject Option {\n\n  import scala.language.implicitConversions\n\n  /** An implicit conversion that converts an option to an iterable value */\n  implicit def option2Iterable[A](xo: Option[A]): Iterable[A] \u003d\n    if (xo.isEmpty) Iterable.empty else Iterable.single(xo.get)\n\n  /** An Option factory which creates Some(x) if the argument is not null,\n   *  and None if it is null.\n   *\n   *  @param  x the value\n   *  @return   Some(value) if value !\u003d null, None if value \u003d\u003d null\n   */\n  def apply[A](x: A): Option[A] \u003d if (x \u003d\u003d null) None else Some(x)\n\n  /** An Option factory which returns `None` in a manner consistent with\n   *  the collections hierarchy.\n   */\n  def empty[A] : Option[A] \u003d None\n\n  /** When a given condition is true, evaluates the `a` argument and returns\n   *  Some(a). When the condition is false, `a` is not evaluated and None is\n   *  returned.\n   */\n  def when[A](cond: Boolean)(a: \u003d\u003e A): Option[A] \u003d\n    if (cond) Some(a) else None\n\n  /** Unless a given condition is true, this will evaluate the `a` argument and\n   *  return Some(a). Otherwise, `a` is not evaluated and None is returned.\n   */\n  @inline def unless[A](cond: Boolean)(a: \u003d\u003e A): Option[A] \u003d\n    when(!cond)(a)\n}\n\n/** Represents optional values. Instances of `Option`\n *  are either an instance of $some or the object $none.\n *\n *  The most idiomatic way to use an $option instance is to treat it\n *  as a collection or monad and use `map`,`flatMap`, `filter`, or\n *  `foreach`:\n *\n *  {{{\n *  val name: Option[String] \u003d request getParameter \"name\"\n *  val upper \u003d name map { _.trim } filter { _.length !\u003d 0 } map { _.toUpperCase }\n *  println(upper getOrElse \"\")\n *  }}}\n *\n *  Note that this is equivalent to {{{\n *  val upper \u003d for {\n *    name \u003c- request getParameter \"name\"\n *    trimmed \u003c- Some(name.trim)\n *    upper \u003c- Some(trimmed.toUpperCase) if trimmed.length !\u003d 0\n *  } yield upper\n *  println(upper getOrElse \"\")\n *  }}}\n *\n *  Because of how for comprehension works, if $none is returned\n *  from `request.getParameter`, the entire expression results in\n *  $none\n *\n *  This allows for sophisticated chaining of $option values without\n *  having to check for the existence of a value.\n *\n * These are useful methods that exist for both $some and $none.\n *  - [[isDefined]] — True if not empty\n *  - [[isEmpty]] — True if empty\n *  - [[nonEmpty]] — True if not empty\n *  - [[orElse]] — Evaluate and return alternate optional value if empty\n *  - [[getOrElse]] — Evaluate and return alternate value if empty\n *  - [[get]] — Return value, throw exception if empty\n *  - [[fold]] —  Apply function on optional value, return default if empty\n *  - [[map]] — Apply a function on the optional value\n *  - [[flatMap]] — Same as map but function must return an optional value\n *  - [[foreach]] — Apply a procedure on option value\n *  - [[collect]] — Apply partial pattern match on optional value\n *  - [[filter]] — An optional value satisfies predicate\n *  - [[filterNot]] — An optional value doesn\u0027t satisfy predicate\n *  - [[exists]] — Apply predicate on optional value, or false if empty\n *  - [[forall]] — Apply predicate on optional value, or true if empty\n *  - [[contains]] — Checks if value equals optional value, or false if empty\n *  - [[zip]] — Combine two optional values to make a paired optional value\n *  - [[unzip]] — Split an optional pair to two optional values\n *  - [[unzip3]] — Split an optional triple to three optional values\n *  - [[toList]] — Unary list of optional value, otherwise the empty list\n *\n *  A less-idiomatic way to use $option values is via pattern matching: {{{\n *  val nameMaybe \u003d request getParameter \"name\"\n *  nameMaybe match {\n *    case Some(name) \u003d\u003e\n *      println(name.trim.toUppercase)\n *    case None \u003d\u003e\n *      println(\"No name value\")\n *  }\n *  }}}\n *\n * Interacting with code that can occasionally return null can be\n * safely wrapped in $option to become $none and $some otherwise. {{{\n * val abc \u003d new java.util.HashMap[Int, String]\n * abc.put(1, \"A\")\n * bMaybe \u003d Option(abc.get(2))\n * bMaybe match {\n *   case Some(b) \u003d\u003e\n *     println(s\"Found \\$b\")\n *   case None \u003d\u003e\n *     println(\"Not found\")\n * }\n * }}}\n *\n *  @note Many of the methods in here are duplicative with those\n *  in the Iterable hierarchy, but they are duplicated for a reason:\n *  the implicit conversion tends to leave one with an Iterable in\n *  situations where one could have retained an Option.\n *\n *  @define none `None`\n *  @define some [[scala.Some]]\n *  @define option [[scala.Option]]\n *  @define p `p`\n *  @define f `f`\n *  @define coll option\n *  @define Coll `Option`\n *  @define orderDependent\n *  @define orderDependentFold\n *  @define mayNotTerminateInf\n *  @define willNotTerminateInf\n *  @define collectExample\n *  @define undefinedorder\n */\n@SerialVersionUID(-114498752079829388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nsealed abstract class Option[+A] extends IterableOnce[A] with Product with Serializable {\n  self \u003d\u003e\n\n  /** Returns true if the option is $none, false otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e false\n   *   case None    \u003d\u003e true\n   * }\n   * }}}\n   */\n  final def isEmpty: Boolean \u003d this eq None\n\n  /** Returns true if the option is an instance of $some, false otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e true\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   */\n  final def isDefined: Boolean \u003d !isEmpty\n\n  override final def knownSize: Int \u003d if (isEmpty) 0 else 1\n\n  /** Returns the option\u0027s value.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e throw new Exception\n   * }\n   * }}}\n   *  @note The option must be nonempty.\n   *  @throws NoSuchElementException if the option is empty.\n   */\n  def get: A\n\n  /** Returns the option\u0027s value if the option is nonempty, otherwise\n   * return the result of evaluating `default`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e default\n   * }\n   * }}}\n   *\n   *  @param default  the default expression.\n   */\n  @inline final def getOrElse[B \u003e: A](default: \u003d\u003e B): B \u003d\n    if (isEmpty) default else this.get\n\n  /** Returns the option\u0027s value if it is nonempty,\n   * or `null` if it is empty.\n   *\n   * Although the use of null is discouraged, code written to use\n   * $option must often interface with code that expects and returns nulls.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e null\n   * }\n   * }}}\n   * @example {{{\n   * val initialText: Option[String] \u003d getInitialText\n   * val textField \u003d new JComponent(initialText.orNull,20)\n   * }}}\n   */\n  @inline final def orNull[A1 \u003e: A](implicit ev: Null \u003c:\u003c A1): A1 \u003d this getOrElse ev(null)\n\n  /** Returns a $some containing the result of applying $f to this $option\u0027s\n   * value if this $option is nonempty.\n   * Otherwise return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Some(f(x))\n   *   case None    \u003d\u003e None\n   * }\n   * }}}\n   *  @note This is similar to `flatMap` except here,\n   *  $f does not need to wrap its result in an $option.\n   *\n   *  @param  f   the function to apply\n   *  @see flatMap\n   *  @see foreach\n   */\n  @inline final def map[B](f: A \u003d\u003e B): Option[B] \u003d\n    if (isEmpty) None else Some(f(this.get))\n\n  /** Returns the result of applying $f to this $option\u0027s\n   *  value if the $option is nonempty.  Otherwise, evaluates\n   *  expression `ifEmpty`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e ifEmpty\n   * }\n   * }}}\n   * This is also equivalent to:\n   * {{{\n   * option map f getOrElse ifEmpty\n   * }}}\n   *  @param  ifEmpty the expression to evaluate if empty.\n   *  @param  f       the function to apply if nonempty.\n   */\n  @inline final def fold[B](ifEmpty: \u003d\u003e B)(f: A \u003d\u003e B): B \u003d\n    if (isEmpty) ifEmpty else f(this.get)\n\n  /** Returns the result of applying $f to this $option\u0027s value if\n   * this $option is nonempty.\n   * Returns $none if this $option is empty.\n   * Slightly different from `map` in that $f is expected to\n   * return an $option (which could be $none).\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e None\n   * }\n   * }}}\n   *  @param  f   the function to apply\n   *  @see map\n   *  @see foreach\n   */\n  @inline final def flatMap[B](f: A \u003d\u003e Option[B]): Option[B] \u003d\n    if (isEmpty) None else f(this.get)\n\n  /** Returns the nested $option value if it is nonempty.  Otherwise,\n   * return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(Some(b)) \u003d\u003e Some(b)\n   *   case _             \u003d\u003e None\n   * }\n   * }}}\n   * @example {{{\n   * Some(Some(\"something\")).flatten\n   * }}}\n   *\n   * @param ev an implicit conversion that asserts that the value is\n   *           also an $option.\n   * @see flatMap\n   */\n  def flatten[B](implicit ev: A \u003c:\u003c Option[B]): Option[B] \u003d\n    if (isEmpty) None else ev(this.get)\n\n  /** Returns this $option if it is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 applying the predicate $p to\n   * this $option\u0027s value returns true. Otherwise, return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) if p(x) \u003d\u003e Some(x)\n   *   case _               \u003d\u003e None\n   * }\n   * }}}\n   *  @param  p   the predicate used for testing.\n   */\n  @inline final def filter(p: A \u003d\u003e Boolean): Option[A] \u003d\n    if (isEmpty || p(this.get)) this else None\n\n  /** Returns this $option if it is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 applying the predicate $p to\n   * this $option\u0027s value returns false. Otherwise, return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) if !p(x) \u003d\u003e Some(x)\n   *   case _                \u003d\u003e None\n   * }\n   * }}}\n   *  @param  p   the predicate used for testing.\n   */\n  @inline final def filterNot(p: A \u003d\u003e Boolean): Option[A] \u003d\n    if (isEmpty || !p(this.get)) this else None\n\n  /** Returns false if the option is $none, true otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e true\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @note   Implemented here to avoid the implicit conversion to Iterable.\n   */\n  final def nonEmpty: Boolean \u003d isDefined\n\n  /** Necessary to keep $option from being implicitly converted to\n   *  [[scala.collection.Iterable]] in `for` comprehensions.\n   */\n  @inline final def withFilter(p: A \u003d\u003e Boolean): WithFilter \u003d new WithFilter(p)\n\n  /** We need a whole WithFilter class to honor the \"doesn\u0027t create a new\n   *  collection\" contract even though it seems unlikely to matter much in a\n   *  collection with max size 1.\n   */\n  class WithFilter(p: A \u003d\u003e Boolean) {\n    def map[B](f: A \u003d\u003e B): Option[B] \u003d self filter p map f\n    def flatMap[B](f: A \u003d\u003e Option[B]): Option[B] \u003d self filter p flatMap f\n    def foreach[U](f: A \u003d\u003e U): Unit \u003d self filter p foreach f\n    def withFilter(q: A \u003d\u003e Boolean): WithFilter \u003d new WithFilter(x \u003d\u003e p(x) \u0026\u0026 q(x))\n  }\n\n  /** Tests whether the option contains a given value as an element.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x \u003d\u003d elem\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @example {{{\n   *  // Returns true because Some instance contains string \"something\" which equals \"something\".\n   *  Some(\"something\") contains \"something\"\n   *\n   *  // Returns false because \"something\" !\u003d \"anything\".\n   *  Some(\"something\") contains \"anything\"\n   *\n   *  // Returns false when method called on None.\n   *  None contains \"anything\"\n   *  }}}\n   *\n   *  @param elem the element to test.\n   *  @return `true` if the option has an element that is equal (as\n   *  determined by `\u003d\u003d`) to `elem`, `false` otherwise.\n   */\n  final def contains[A1 \u003e: A](elem: A1): Boolean \u003d\n    !isEmpty \u0026\u0026 this.get \u003d\u003d elem\n\n  /** Returns true if this option is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 the predicate\n   * $p returns true when applied to this $option\u0027s value.\n   * Otherwise, returns false.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e p(x)\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @param  p   the predicate to test\n   */\n  @inline final def exists(p: A \u003d\u003e Boolean): Boolean \u003d\n    !isEmpty \u0026\u0026 p(this.get)\n\n  /** Returns true if this option is empty \u0027\u0027\u0027or\u0027\u0027\u0027 the predicate\n   * $p returns true when applied to this $option\u0027s value.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e p(x)\n   *   case None    \u003d\u003e true\n   * }\n   * }}}\n   *  @param  p   the predicate to test\n   */\n  @inline final def forall(p: A \u003d\u003e Boolean): Boolean \u003d isEmpty || p(this.get)\n\n  /** Apply the given procedure $f to the option\u0027s value,\n   *  if it is nonempty. Otherwise, do nothing.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e ()\n   * }\n   * }}}\n   *  @param  f   the procedure to apply.\n   *  @see map\n   *  @see flatMap\n   */\n  @inline final def foreach[U](f: A \u003d\u003e U): Unit \u003d {\n    if (!isEmpty) f(this.get)\n  }\n\n  /** Returns a $some containing the result of\n   * applying `pf` to this $option\u0027s contained\n   * value, \u0027\u0027\u0027if\u0027\u0027\u0027 this option is\n   * nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 `pf` is defined for that value.\n   * Returns $none otherwise.\n   *\n   *  @example {{{\n   *  // Returns Some(HTTP) because the partial function covers the case.\n   *  Some(\"http\") collect {case \"http\" \u003d\u003e \"HTTP\"}\n   *\n   *  // Returns None because the partial function doesn\u0027t cover the case.\n   *  Some(\"ftp\") collect {case \"http\" \u003d\u003e \"HTTP\"}\n   *\n   *  // Returns None because the option is empty. There is no value to pass to the partial function.\n   *  None collect {case value \u003d\u003e value}\n   *  }}}\n   *\n   *  @param  pf   the partial function.\n   *  @return the result of applying `pf` to this $option\u0027s\n   *  value (if possible), or $none.\n   */\n  @inline final def collect[B](pf: PartialFunction[A, B]): Option[B] \u003d\n    if (!isEmpty) pf.lift(this.get) else None\n\n  /** Returns this $option if it is nonempty,\n   *  otherwise return the result of evaluating `alternative`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Some(x)\n   *   case None    \u003d\u003e alternative\n   * }\n   * }}}\n   *  @param alternative the alternative expression.\n   */\n  @inline final def orElse[B \u003e: A](alternative: \u003d\u003e Option[B]): Option[B] \u003d\n    if (isEmpty) alternative else this\n\n  /** Returns a $some formed from this option and another option\n   *  by combining the corresponding elements in a pair.\n   *  If either of the two options is empty, $none is returned.\n   *\n   *  This is equivalent to:\n   *  {{{\n   *  (option1, option2) match {\n   *    case (Some(x), Some(y)) \u003d\u003e Some((x, y))\n   *    case _                  \u003d\u003e None\n   *  }\n   *  }}}\n   *  @example {{{\n   *  // Returns Some((\"foo\", \"bar\")) because both options are nonempty.\n   *  Some(\"foo\") zip Some(\"bar\")\n   *\n   *  // Returns None because `that` option is empty.\n   *  Some(\"foo\") zip None\n   *\n   *  // Returns None because `this` option is empty.\n   *  None zip Some(\"bar\")\n   *  }}}\n   *\n   *  @param  that   the options which is going to be zipped\n   */\n  final def zip[A1 \u003e: A, B](that: Option[B]): Option[(A1, B)] \u003d\n    if (isEmpty || that.isEmpty) None else Some((this.get, that.get))\n\n  /** Converts an Option of a pair into an Option of the first element and an Option of the second element.\n    *\n    *  This is equivalent to:\n    *  {{{\n    *  option match {\n    *    case Some((x, y)) \u003d\u003e (Some(x), Some(y))\n    *    case _            \u003d\u003e (None,    None)\n    *  }\n    *  }}}\n    *  @tparam A1    the type of the first half of the element pair\n    *  @tparam A2    the type of the second half of the element pair\n    *  @param asPair an implicit conversion which asserts that the element type\n    *                of this Option is a pair.\n    *  @return       a pair of Options, containing, respectively, the first and second half\n    *                of the element pair of this Option.\n    */\n  final def unzip[A1, A2](implicit asPair: A \u003c:\u003c (A1, A2)): (Option[A1], Option[A2]) \u003d {\n    if (isEmpty)\n      (None, None)\n    else {\n      val e \u003d asPair(this.get)\n      (Some(e._1), Some(e._2))\n    }\n  }\n\n  /** Converts an Option of a triple into three Options, one containing the element from each position of the triple.\n    *\n    *  This is equivalent to:\n    *  {{{\n    *  option match {\n    *    case Some((x, y, z)) \u003d\u003e (Some(x), Some(y), Some(z))\n    *    case _               \u003d\u003e (None,    None,    None)\n    *  }\n    *  }}}\n    *  @tparam A1      the type of the first of three elements in the triple\n    *  @tparam A2      the type of the second of three elements in the triple\n    *  @tparam A3      the type of the third of three elements in the triple\n    *  @param asTriple an implicit conversion which asserts that the element type\n    *                  of this Option is a triple.\n    *  @return         a triple of Options, containing, respectively, the first, second, and third\n    *                  elements from the element triple of this Option.\n    */\n  final def unzip3[A1, A2, A3](implicit asTriple: A \u003c:\u003c (A1, A2, A3)): (Option[A1], Option[A2], Option[A3]) \u003d {\n    if (isEmpty)\n      (None, None, None)\n    else {\n      val e \u003d asTriple(this.get)\n      (Some(e._1), Some(e._2), Some(e._3))\n    }\n  }\n\n  /** Returns a singleton iterator returning the $option\u0027s value\n   * if it is nonempty, or an empty iterator if the option is empty.\n   */\n  def iterator: Iterator[A] \u003d\n    if (isEmpty) collection.Iterator.empty else collection.Iterator.single(this.get)\n\n  /** Returns a singleton list containing the $option\u0027s value\n   * if it is nonempty, or the empty list if the $option is empty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e List(x)\n   *   case None    \u003d\u003e Nil\n   * }\n   * }}}\n   */\n  def toList: List[A] \u003d\n    if (isEmpty) List() else new ::(this.get, Nil)\n\n  /** Returns a [[scala.util.Left]] containing the given\n   * argument `left` if this $option is empty, or\n   * a [[scala.util.Right]] containing this $option\u0027s value if\n   * this is nonempty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Right(x)\n   *   case None    \u003d\u003e Left(left)\n   * }\n   * }}}\n   * @param left the expression to evaluate and return if this is empty\n   * @see toLeft\n   */\n  @inline final def toRight[X](left: \u003d\u003e X): Either[X, A] \u003d\n    if (isEmpty) Left(left) else Right(this.get)\n\n  /** Returns a [[scala.util.Right]] containing the given\n   * argument `right` if this is empty, or\n   * a [[scala.util.Left]] containing this $option\u0027s value\n   * if this $option is nonempty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Left(x)\n   *   case None    \u003d\u003e Right(right)\n   * }\n   * }}}\n   * @param right the expression to evaluate and return if this is empty\n   * @see toRight\n   */\n  @inline final def toLeft[X](right: \u003d\u003e X): Either[A, X] \u003d\n    if (isEmpty) Right(right) else Left(this.get)\n}\n\n/** Class `Some[A]` represents existing values of type\n *  `A`.\n */\n@SerialVersionUID(1234815782226070388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nfinal case class Some[+A](value: A) extends Option[A] {\n  def get: A \u003d value\n}\n\n\n/** This case object represents non-existent values.\n */\n@SerialVersionUID(5066590221178148012L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\ncase object None extends Option[Nothing] {\n  def get: Nothing \u003d throw new NoSuchElementException(\"None.get\")\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 2:51:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Option.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:51:02 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 2:51:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Option.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nobject Option {\n\n  import scala.language.implicitConversions\n\n  /** An implicit conversion that converts an option to an iterable value */\n  implicit def option2Iterable[A](xo: Option[A]): Iterable[A] \u003d\n    if (xo.isEmpty) Iterable.empty else Iterable.single(xo.get)\n\n  /** An Option factory which creates Some(x) if the argument is not null,\n   *  and None if it is null.\n   *\n   *  @param  x the value\n   *  @return   Some(value) if value !\u003d null, None if value \u003d\u003d null\n   */\n  def apply[A](x: A): Option[A] \u003d if (x \u003d\u003d null) None else Some(x)\n\n  /** An Option factory which returns `None` in a manner consistent with\n   *  the collections hierarchy.\n   */\n  def empty[A] : Option[A] \u003d None\n\n  /** When a given condition is true, evaluates the `a` argument and returns\n   *  Some(a). When the condition is false, `a` is not evaluated and None is\n   *  returned.\n   */\n  def when[A](cond: Boolean)(a: \u003d\u003e A): Option[A] \u003d\n    if (cond) Some(a) else None\n\n  /** Unless a given condition is true, this will evaluate the `a` argument and\n   *  return Some(a). Otherwise, `a` is not evaluated and None is returned.\n   */\n  @inline def unless[A](cond: Boolean)(a: \u003d\u003e A): Option[A] \u003d\n    when(!cond)(a)\n}\n\n/** Represents optional values. Instances of `Option`\n *  are either an instance of $some or the object $none.\n *\n *  The most idiomatic way to use an $option instance is to treat it\n *  as a collection or monad and use `map`,`flatMap`, `filter`, or\n *  `foreach`:\n *\n *  {{{\n *  val name: Option[String] \u003d request getParameter \"name\"\n *  val upper \u003d name map { _.trim } filter { _.length !\u003d 0 } map { _.toUpperCase }\n *  println(upper getOrElse \"\")\n *  }}}\n *\n *  Note that this is equivalent to {{{\n *  val upper \u003d for {\n *    name \u003c- request getParameter \"name\"\n *    trimmed \u003c- Some(name.trim)\n *    upper \u003c- Some(trimmed.toUpperCase) if trimmed.length !\u003d 0\n *  } yield upper\n *  println(upper getOrElse \"\")\n *  }}}\n *\n *  Because of how for comprehension works, if $none is returned\n *  from `request.getParameter`, the entire expression results in\n *  $none\n *\n *  This allows for sophisticated chaining of $option values without\n *  having to check for the existence of a value.\n *\n * These are useful methods that exist for both $some and $none.\n *  - [[isDefined]] — True if not empty\n *  - [[isEmpty]] — True if empty\n *  - [[nonEmpty]] — True if not empty\n *  - [[orElse]] — Evaluate and return alternate optional value if empty\n *  - [[getOrElse]] — Evaluate and return alternate value if empty\n *  - [[get]] — Return value, throw exception if empty\n *  - [[fold]] —  Apply function on optional value, return default if empty\n *  - [[map]] — Apply a function on the optional value\n *  - [[flatMap]] — Same as map but function must return an optional value\n *  - [[foreach]] — Apply a procedure on option value\n *  - [[collect]] — Apply partial pattern match on optional value\n *  - [[filter]] — An optional value satisfies predicate\n *  - [[filterNot]] — An optional value doesn\u0027t satisfy predicate\n *  - [[exists]] — Apply predicate on optional value, or false if empty\n *  - [[forall]] — Apply predicate on optional value, or true if empty\n *  - [[contains]] — Checks if value equals optional value, or false if empty\n *  - [[zip]] — Combine two optional values to make a paired optional value\n *  - [[unzip]] — Split an optional pair to two optional values\n *  - [[unzip3]] — Split an optional triple to three optional values\n *  - [[toList]] — Unary list of optional value, otherwise the empty list\n *\n *  A less-idiomatic way to use $option values is via pattern matching: {{{\n *  val nameMaybe \u003d request getParameter \"name\"\n *  nameMaybe match {\n *    case Some(name) \u003d\u003e\n *      println(name.trim.toUppercase)\n *    case None \u003d\u003e\n *      println(\"No name value\")\n *  }\n *  }}}\n *\n * Interacting with code that can occasionally return null can be\n * safely wrapped in $option to become $none and $some otherwise. {{{\n * val abc \u003d new java.util.HashMap[Int, String]\n * abc.put(1, \"A\")\n * bMaybe \u003d Option(abc.get(2))\n * bMaybe match {\n *   case Some(b) \u003d\u003e\n *     println(s\"Found \\$b\")\n *   case None \u003d\u003e\n *     println(\"Not found\")\n * }\n * }}}\n *\n *  @note Many of the methods in here are duplicative with those\n *  in the Iterable hierarchy, but they are duplicated for a reason:\n *  the implicit conversion tends to leave one with an Iterable in\n *  situations where one could have retained an Option.\n *\n *  @define none `None`\n *  @define some [[scala.Some]]\n *  @define option [[scala.Option]]\n *  @define p `p`\n *  @define f `f`\n *  @define coll option\n *  @define Coll `Option`\n *  @define orderDependent\n *  @define orderDependentFold\n *  @define mayNotTerminateInf\n *  @define willNotTerminateInf\n *  @define collectExample\n *  @define undefinedorder\n */\n@SerialVersionUID(-114498752079829388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nsealed abstract class Option[+A] extends IterableOnce[A] with Product with Serializable {\n  self \u003d\u003e\n\n  /** Returns true if the option is $none, false otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e false\n   *   case None    \u003d\u003e true\n   * }\n   * }}}\n   */\n  final def isEmpty: Boolean \u003d this eq None\n\n  /** Returns true if the option is an instance of $some, false otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e true\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   */\n  final def isDefined: Boolean \u003d !isEmpty\n\n  override final def knownSize: Int \u003d if (isEmpty) 0 else 1\n\n  /** Returns the option\u0027s value.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e throw new Exception\n   * }\n   * }}}\n   *  @note The option must be nonempty.\n   *  @throws NoSuchElementException if the option is empty.\n   */\n  def get: A\n\n  /** Returns the option\u0027s value if the option is nonempty, otherwise\n   * return the result of evaluating `default`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e default\n   * }\n   * }}}\n   *\n   *  @param default  the default expression.\n   */\n  @inline final def getOrElse[B \u003e: A](default: \u003d\u003e B): B \u003d\n    if (isEmpty) default else this.get\n\n  /** Returns the option\u0027s value if it is nonempty,\n   * or `null` if it is empty.\n   *\n   * Although the use of null is discouraged, code written to use\n   * $option must often interface with code that expects and returns nulls.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x\n   *   case None    \u003d\u003e null\n   * }\n   * }}}\n   * @example {{{\n   * val initialText: Option[String] \u003d getInitialText\n   * val textField \u003d new JComponent(initialText.orNull,20)\n   * }}}\n   */\n  @inline final def orNull[A1 \u003e: A](implicit ev: Null \u003c:\u003c A1): A1 \u003d this getOrElse ev(null)\n\n  /** Returns a $some containing the result of applying $f to this $option\u0027s\n   * value if this $option is nonempty.\n   * Otherwise return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Some(f(x))\n   *   case None    \u003d\u003e None\n   * }\n   * }}}\n   *  @note This is similar to `flatMap` except here,\n   *  $f does not need to wrap its result in an $option.\n   *\n   *  @param  f   the function to apply\n   *  @see flatMap\n   *  @see foreach\n   */\n  @inline final def map[B](f: A \u003d\u003e B): Option[B] \u003d\n    if (isEmpty) None else Some(f(this.get))\n\n  /** Returns the result of applying $f to this $option\u0027s\n   *  value if the $option is nonempty.  Otherwise, evaluates\n   *  expression `ifEmpty`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e ifEmpty\n   * }\n   * }}}\n   * This is also equivalent to:\n   * {{{\n   * option map f getOrElse ifEmpty\n   * }}}\n   *  @param  ifEmpty the expression to evaluate if empty.\n   *  @param  f       the function to apply if nonempty.\n   */\n  @inline final def fold[B](ifEmpty: \u003d\u003e B)(f: A \u003d\u003e B): B \u003d\n    if (isEmpty) ifEmpty else f(this.get)\n\n  /** Returns the result of applying $f to this $option\u0027s value if\n   * this $option is nonempty.\n   * Returns $none if this $option is empty.\n   * Slightly different from `map` in that $f is expected to\n   * return an $option (which could be $none).\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e None\n   * }\n   * }}}\n   *  @param  f   the function to apply\n   *  @see map\n   *  @see foreach\n   */\n  @inline final def flatMap[B](f: A \u003d\u003e Option[B]): Option[B] \u003d\n    if (isEmpty) None else f(this.get)\n\n  /** Returns the nested $option value if it is nonempty.  Otherwise,\n   * return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(Some(b)) \u003d\u003e Some(b)\n   *   case _             \u003d\u003e None\n   * }\n   * }}}\n   * @example {{{\n   * Some(Some(\"something\")).flatten\n   * }}}\n   *\n   * @param ev an implicit conversion that asserts that the value is\n   *           also an $option.\n   * @see flatMap\n   */\n  def flatten[B](implicit ev: A \u003c:\u003c Option[B]): Option[B] \u003d\n    if (isEmpty) None else ev(this.get)\n\n  /** Returns this $option if it is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 applying the predicate $p to\n   * this $option\u0027s value returns true. Otherwise, return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) if p(x) \u003d\u003e Some(x)\n   *   case _               \u003d\u003e None\n   * }\n   * }}}\n   *  @param  p   the predicate used for testing.\n   */\n  @inline final def filter(p: A \u003d\u003e Boolean): Option[A] \u003d\n    if (isEmpty || p(this.get)) this else None\n\n  /** Returns this $option if it is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 applying the predicate $p to\n   * this $option\u0027s value returns false. Otherwise, return $none.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) if !p(x) \u003d\u003e Some(x)\n   *   case _                \u003d\u003e None\n   * }\n   * }}}\n   *  @param  p   the predicate used for testing.\n   */\n  @inline final def filterNot(p: A \u003d\u003e Boolean): Option[A] \u003d\n    if (isEmpty || !p(this.get)) this else None\n\n  /** Returns false if the option is $none, true otherwise.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(_) \u003d\u003e true\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @note   Implemented here to avoid the implicit conversion to Iterable.\n   */\n  final def nonEmpty: Boolean \u003d isDefined\n\n  /** Necessary to keep $option from being implicitly converted to\n   *  [[scala.collection.Iterable]] in `for` comprehensions.\n   */\n  @inline final def withFilter(p: A \u003d\u003e Boolean): WithFilter \u003d new WithFilter(p)\n\n  /** We need a whole WithFilter class to honor the \"doesn\u0027t create a new\n   *  collection\" contract even though it seems unlikely to matter much in a\n   *  collection with max size 1.\n   */\n  class WithFilter(p: A \u003d\u003e Boolean) {\n    def map[B](f: A \u003d\u003e B): Option[B] \u003d self filter p map f\n    def flatMap[B](f: A \u003d\u003e Option[B]): Option[B] \u003d self filter p flatMap f\n    def foreach[U](f: A \u003d\u003e U): Unit \u003d self filter p foreach f\n    def withFilter(q: A \u003d\u003e Boolean): WithFilter \u003d new WithFilter(x \u003d\u003e p(x) \u0026\u0026 q(x))\n  }\n\n  /** Tests whether the option contains a given value as an element.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e x \u003d\u003d elem\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @example {{{\n   *  // Returns true because Some instance contains string \"something\" which equals \"something\".\n   *  Some(\"something\") contains \"something\"\n   *\n   *  // Returns false because \"something\" !\u003d \"anything\".\n   *  Some(\"something\") contains \"anything\"\n   *\n   *  // Returns false when method called on None.\n   *  None contains \"anything\"\n   *  }}}\n   *\n   *  @param elem the element to test.\n   *  @return `true` if the option has an element that is equal (as\n   *  determined by `\u003d\u003d`) to `elem`, `false` otherwise.\n   */\n  final def contains[A1 \u003e: A](elem: A1): Boolean \u003d\n    !isEmpty \u0026\u0026 this.get \u003d\u003d elem\n\n  /** Returns true if this option is nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 the predicate\n   * $p returns true when applied to this $option\u0027s value.\n   * Otherwise, returns false.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e p(x)\n   *   case None    \u003d\u003e false\n   * }\n   * }}}\n   *  @param  p   the predicate to test\n   */\n  @inline final def exists(p: A \u003d\u003e Boolean): Boolean \u003d\n    !isEmpty \u0026\u0026 p(this.get)\n\n  /** Returns true if this option is empty \u0027\u0027\u0027or\u0027\u0027\u0027 the predicate\n   * $p returns true when applied to this $option\u0027s value.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e p(x)\n   *   case None    \u003d\u003e true\n   * }\n   * }}}\n   *  @param  p   the predicate to test\n   */\n  @inline final def forall(p: A \u003d\u003e Boolean): Boolean \u003d isEmpty || p(this.get)\n\n  /** Apply the given procedure $f to the option\u0027s value,\n   *  if it is nonempty. Otherwise, do nothing.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e f(x)\n   *   case None    \u003d\u003e ()\n   * }\n   * }}}\n   *  @param  f   the procedure to apply.\n   *  @see map\n   *  @see flatMap\n   */\n  @inline final def foreach[U](f: A \u003d\u003e U): Unit \u003d {\n    if (!isEmpty) f(this.get)\n  }\n\n  /** Returns a $some containing the result of\n   * applying `pf` to this $option\u0027s contained\n   * value, \u0027\u0027\u0027if\u0027\u0027\u0027 this option is\n   * nonempty \u0027\u0027\u0027and\u0027\u0027\u0027 `pf` is defined for that value.\n   * Returns $none otherwise.\n   *\n   *  @example {{{\n   *  // Returns Some(HTTP) because the partial function covers the case.\n   *  Some(\"http\") collect {case \"http\" \u003d\u003e \"HTTP\"}\n   *\n   *  // Returns None because the partial function doesn\u0027t cover the case.\n   *  Some(\"ftp\") collect {case \"http\" \u003d\u003e \"HTTP\"}\n   *\n   *  // Returns None because the option is empty. There is no value to pass to the partial function.\n   *  None collect {case value \u003d\u003e value}\n   *  }}}\n   *\n   *  @param  pf   the partial function.\n   *  @return the result of applying `pf` to this $option\u0027s\n   *  value (if possible), or $none.\n   */\n  @inline final def collect[B](pf: PartialFunction[A, B]): Option[B] \u003d\n    if (!isEmpty) pf.lift(this.get) else None\n\n  /** Returns this $option if it is nonempty,\n   *  otherwise return the result of evaluating `alternative`.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Some(x)\n   *   case None    \u003d\u003e alternative\n   * }\n   * }}}\n   *  @param alternative the alternative expression.\n   */\n  @inline final def orElse[B \u003e: A](alternative: \u003d\u003e Option[B]): Option[B] \u003d\n    if (isEmpty) alternative else this\n\n  /** Returns a $some formed from this option and another option\n   *  by combining the corresponding elements in a pair.\n   *  If either of the two options is empty, $none is returned.\n   *\n   *  This is equivalent to:\n   *  {{{\n   *  (option1, option2) match {\n   *    case (Some(x), Some(y)) \u003d\u003e Some((x, y))\n   *    case _                  \u003d\u003e None\n   *  }\n   *  }}}\n   *  @example {{{\n   *  // Returns Some((\"foo\", \"bar\")) because both options are nonempty.\n   *  Some(\"foo\") zip Some(\"bar\")\n   *\n   *  // Returns None because `that` option is empty.\n   *  Some(\"foo\") zip None\n   *\n   *  // Returns None because `this` option is empty.\n   *  None zip Some(\"bar\")\n   *  }}}\n   *\n   *  @param  that   the options which is going to be zipped\n   */\n  final def zip[A1 \u003e: A, B](that: Option[B]): Option[(A1, B)] \u003d\n    if (isEmpty || that.isEmpty) None else Some((this.get, that.get))\n\n  /** Converts an Option of a pair into an Option of the first element and an Option of the second element.\n    *\n    *  This is equivalent to:\n    *  {{{\n    *  option match {\n    *    case Some((x, y)) \u003d\u003e (Some(x), Some(y))\n    *    case _            \u003d\u003e (None,    None)\n    *  }\n    *  }}}\n    *  @tparam A1    the type of the first half of the element pair\n    *  @tparam A2    the type of the second half of the element pair\n    *  @param asPair an implicit conversion which asserts that the element type\n    *                of this Option is a pair.\n    *  @return       a pair of Options, containing, respectively, the first and second half\n    *                of the element pair of this Option.\n    */\n  final def unzip[A1, A2](implicit asPair: A \u003c:\u003c (A1, A2)): (Option[A1], Option[A2]) \u003d {\n    if (isEmpty)\n      (None, None)\n    else {\n      val e \u003d asPair(this.get)\n      (Some(e._1), Some(e._2))\n    }\n  }\n\n  /** Converts an Option of a triple into three Options, one containing the element from each position of the triple.\n    *\n    *  This is equivalent to:\n    *  {{{\n    *  option match {\n    *    case Some((x, y, z)) \u003d\u003e (Some(x), Some(y), Some(z))\n    *    case _               \u003d\u003e (None,    None,    None)\n    *  }\n    *  }}}\n    *  @tparam A1      the type of the first of three elements in the triple\n    *  @tparam A2      the type of the second of three elements in the triple\n    *  @tparam A3      the type of the third of three elements in the triple\n    *  @param asTriple an implicit conversion which asserts that the element type\n    *                  of this Option is a triple.\n    *  @return         a triple of Options, containing, respectively, the first, second, and third\n    *                  elements from the element triple of this Option.\n    */\n  final def unzip3[A1, A2, A3](implicit asTriple: A \u003c:\u003c (A1, A2, A3)): (Option[A1], Option[A2], Option[A3]) \u003d {\n    if (isEmpty)\n      (None, None, None)\n    else {\n      val e \u003d asTriple(this.get)\n      (Some(e._1), Some(e._2), Some(e._3))\n    }\n  }\n\n  /** Returns a singleton iterator returning the $option\u0027s value\n   * if it is nonempty, or an empty iterator if the option is empty.\n   */\n  def iterator: Iterator[A] \u003d\n    if (isEmpty) collection.Iterator.empty else collection.Iterator.single(this.get)\n\n  /** Returns a singleton list containing the $option\u0027s value\n   * if it is nonempty, or the empty list if the $option is empty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e List(x)\n   *   case None    \u003d\u003e Nil\n   * }\n   * }}}\n   */\n  def toList: List[A] \u003d\n    if (isEmpty) List() else new ::(this.get, Nil)\n\n  /** Returns a [[scala.util.Left]] containing the given\n   * argument `left` if this $option is empty, or\n   * a [[scala.util.Right]] containing this $option\u0027s value if\n   * this is nonempty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Right(x)\n   *   case None    \u003d\u003e Left(left)\n   * }\n   * }}}\n   * @param left the expression to evaluate and return if this is empty\n   * @see toLeft\n   */\n  @inline final def toRight[X](left: \u003d\u003e X): Either[X, A] \u003d\n    if (isEmpty) Left(left) else Right(this.get)\n\n  /** Returns a [[scala.util.Right]] containing the given\n   * argument `right` if this is empty, or\n   * a [[scala.util.Left]] containing this $option\u0027s value\n   * if this $option is nonempty.\n   *\n   * This is equivalent to:\n   * {{{\n   * option match {\n   *   case Some(x) \u003d\u003e Left(x)\n   *   case None    \u003d\u003e Right(right)\n   * }\n   * }}}\n   * @param right the expression to evaluate and return if this is empty\n   * @see toRight\n   */\n  @inline final def toLeft[X](right: \u003d\u003e X): Either[A, X] \u003d\n    if (isEmpty) Right(right) else Left(this.get)\n}\n\n/** Class `Some[A]` represents existing values of type\n *  `A`.\n */\n@SerialVersionUID(1234815782226070388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nfinal case class Some[+A](value: A) extends Option[A] {\n  def get: A \u003d value\n}\n\n\n/** This case object represents non-existent values.\n */\n@SerialVersionUID(5066590221178148012L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\ncase object None extends Option[Nothing] {\n  def get: Nothing \u003d throw new NoSuchElementException(\"None.get\")\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 2:52:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3895
2024.04.26 02:52:32 INFO  compiling root (1 scala source)
2024.04.26 02:52:32 INFO  time: compiled root in 0.12s
2024.04.26 02:52:49 INFO  compiling root (1 scala source)
2024.04.26 02:52:49 INFO  time: compiled root in 0.11s
2024.04.26 02:53:31 INFO  compiling root (1 scala source)
2024.04.26 02:53:31 INFO  time: compiled root in 98ms
2024.04.26 02:53:52 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 2:53:52 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// DO NOT EDIT, CHANGES WILL BE LOST\n// This auto-generated code can be modified in \"project/GenerateAnyVals.scala\".\n// Afterwards, running \"sbt generateSources\" regenerates this source file.\n\npackage scala\n\n/** `Int`, a 32-bit signed integer (equivalent to Java\u0027s `int` primitive type) is a\n *  subtype of [[scala.AnyVal]]. Instances of `Int` are not\n *  represented by an object in the underlying runtime system.\n *\n *  There is an implicit conversion from [[scala.Int]] \u003d\u003e [[scala.runtime.RichInt]]\n *  which provides useful non-primitive operations.\n */\nfinal abstract class Int private extends AnyVal {\n  def toByte: Byte\n  def toShort: Short\n  def toChar: Char\n  def toInt: Int\n  def toLong: Long\n  def toFloat: Float\n  def toDouble: Double\n\n  /**\n * Returns the bitwise negation of this value.\n * @example {{{\n * ~5 \u003d\u003d -6\n * // in binary: ~00000101 \u003d\u003d\n * //             11111010\n * }}}\n */\n  def unary_~ : Int\n  /** Returns this value, unmodified. */\n  def unary_+ : Int\n  /** Returns the negation of this value. */\n  def unary_- : Int\n\n  @deprecated(\"Adding a number and a String is deprecated. Use the string interpolation `s\\\"$num$str\\\"`\", \"2.13.0\")\n  def +(x: String): String\n\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  def \u003c\u003c(x: Int): Int\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003c\u003c(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e\u003e(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e(x: Long): Int\n\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Short): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Char): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Int): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Long): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Float): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Short): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Char): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Int): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Long): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Float): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Byte): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Short): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Char): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Int): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Long): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Float): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Double): Boolean\n\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Short): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Char): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Int): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Long): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Float): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Byte): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Short): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Char): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Int): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Long): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Float): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Short): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Char): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Int): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Long): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Float): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Double): Boolean\n\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Byte): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Short): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Char): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Int): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Long): Long\n\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Byte): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Short): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Char): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Int): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Long): Long\n\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Byte): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Short): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Char): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Int): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Long): Long\n\n  /** Returns the sum of this value and `x`. */\n  def +(x: Byte): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Short): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Char): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Int): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Long): Long\n  /** Returns the sum of this value and `x`. */\n  def +(x: Float): Float\n  /** Returns the sum of this value and `x`. */\n  def +(x: Double): Double\n\n  /** Returns the difference of this value and `x`. */\n  def -(x: Byte): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Short): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Char): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Int): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Long): Long\n  /** Returns the difference of this value and `x`. */\n  def -(x: Float): Float\n  /** Returns the difference of this value and `x`. */\n  def -(x: Double): Double\n\n  /** Returns the product of this value and `x`. */\n  def *(x: Byte): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Short): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Char): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Int): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Long): Long\n  /** Returns the product of this value and `x`. */\n  def *(x: Float): Float\n  /** Returns the product of this value and `x`. */\n  def *(x: Double): Double\n\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Byte): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Short): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Char): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Int): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Long): Long\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Float): Float\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Double): Double\n\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Byte): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Short): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Char): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Int): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Long): Long\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Float): Float\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Double): Double\n\n  // Provide a more specific return type for Scaladoc\n  override def getClass(): Class[Int] \u003d ???\n}\n\nobject Int extends AnyValCompanion {\n  /** The smallest value representable as an Int. */\n  final val MinValue \u003d java.lang.Integer.MIN_VALUE\n\n  /** The largest value representable as an Int. */\n  final val MaxValue \u003d java.lang.Integer.MAX_VALUE\n\n  /** Transform a value type into a boxed reference type.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.boxToInteger`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the Int to be boxed\n   *  @return     a java.lang.Integer offering `x` as its underlying value.\n   */\n  def box(x: Int): java.lang.Integer \u003d ???\n\n  /** Transform a boxed type into a value type.  Note that this\n   *  method is not typesafe: it accepts any Object, but will throw\n   *  an exception if the argument is not a java.lang.Integer.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.unboxToInt`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the java.lang.Integer to be unboxed.\n   *  @throws     ClassCastException  if the argument is not a java.lang.Integer\n   *  @return     the Int resulting from calling intValue() on `x`\n   */\n  def unbox(x: java.lang.Object): Int \u003d ???\n\n  /** The String representation of the scala.Int companion object. */\n  override def toString \u003d \"object scala.Int\"\n  /** Language mandated coercions from Int to \"wider\" types. */\n  import scala.language.implicitConversions\n  @deprecated(\"Implicit conversion from Int to Float is dangerous because it loses precision. Write `.toFloat` instead.\", \"2.13.1\")\n  implicit def int2float(x: Int): Float \u003d x.toFloat\n  implicit def int2long(x: Int): Long \u003d x.toLong\n  implicit def int2double(x: Int): Double \u003d x.toDouble\n}\n\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 2:53:52 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:53:52 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 2:53:52 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// DO NOT EDIT, CHANGES WILL BE LOST\n// This auto-generated code can be modified in \"project/GenerateAnyVals.scala\".\n// Afterwards, running \"sbt generateSources\" regenerates this source file.\n\npackage scala\n\n/** `Int`, a 32-bit signed integer (equivalent to Java\u0027s `int` primitive type) is a\n *  subtype of [[scala.AnyVal]]. Instances of `Int` are not\n *  represented by an object in the underlying runtime system.\n *\n *  There is an implicit conversion from [[scala.Int]] \u003d\u003e [[scala.runtime.RichInt]]\n *  which provides useful non-primitive operations.\n */\nfinal abstract class Int private extends AnyVal {\n  def toByte: Byte\n  def toShort: Short\n  def toChar: Char\n  def toInt: Int\n  def toLong: Long\n  def toFloat: Float\n  def toDouble: Double\n\n  /**\n * Returns the bitwise negation of this value.\n * @example {{{\n * ~5 \u003d\u003d -6\n * // in binary: ~00000101 \u003d\u003d\n * //             11111010\n * }}}\n */\n  def unary_~ : Int\n  /** Returns this value, unmodified. */\n  def unary_+ : Int\n  /** Returns the negation of this value. */\n  def unary_- : Int\n\n  @deprecated(\"Adding a number and a String is deprecated. Use the string interpolation `s\\\"$num$str\\\"`\", \"2.13.0\")\n  def +(x: String): String\n\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  def \u003c\u003c(x: Int): Int\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003c\u003c(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e\u003e(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e(x: Long): Int\n\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Short): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Char): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Int): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Long): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Float): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Short): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Char): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Int): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Long): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Float): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Byte): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Short): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Char): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Int): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Long): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Float): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Double): Boolean\n\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Short): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Char): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Int): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Long): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Float): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Byte): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Short): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Char): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Int): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Long): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Float): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Short): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Char): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Int): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Long): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Float): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Double): Boolean\n\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Byte): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Short): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Char): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Int): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Long): Long\n\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Byte): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Short): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Char): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Int): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Long): Long\n\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Byte): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Short): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Char): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Int): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Long): Long\n\n  /** Returns the sum of this value and `x`. */\n  def +(x: Byte): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Short): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Char): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Int): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Long): Long\n  /** Returns the sum of this value and `x`. */\n  def +(x: Float): Float\n  /** Returns the sum of this value and `x`. */\n  def +(x: Double): Double\n\n  /** Returns the difference of this value and `x`. */\n  def -(x: Byte): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Short): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Char): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Int): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Long): Long\n  /** Returns the difference of this value and `x`. */\n  def -(x: Float): Float\n  /** Returns the difference of this value and `x`. */\n  def -(x: Double): Double\n\n  /** Returns the product of this value and `x`. */\n  def *(x: Byte): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Short): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Char): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Int): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Long): Long\n  /** Returns the product of this value and `x`. */\n  def *(x: Float): Float\n  /** Returns the product of this value and `x`. */\n  def *(x: Double): Double\n\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Byte): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Short): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Char): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Int): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Long): Long\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Float): Float\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Double): Double\n\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Byte): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Short): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Char): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Int): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Long): Long\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Float): Float\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Double): Double\n\n  // Provide a more specific return type for Scaladoc\n  override def getClass(): Class[Int] \u003d ???\n}\n\nobject Int extends AnyValCompanion {\n  /** The smallest value representable as an Int. */\n  final val MinValue \u003d java.lang.Integer.MIN_VALUE\n\n  /** The largest value representable as an Int. */\n  final val MaxValue \u003d java.lang.Integer.MAX_VALUE\n\n  /** Transform a value type into a boxed reference type.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.boxToInteger`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the Int to be boxed\n   *  @return     a java.lang.Integer offering `x` as its underlying value.\n   */\n  def box(x: Int): java.lang.Integer \u003d ???\n\n  /** Transform a boxed type into a value type.  Note that this\n   *  method is not typesafe: it accepts any Object, but will throw\n   *  an exception if the argument is not a java.lang.Integer.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.unboxToInt`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the java.lang.Integer to be unboxed.\n   *  @throws     ClassCastException  if the argument is not a java.lang.Integer\n   *  @return     the Int resulting from calling intValue() on `x`\n   */\n  def unbox(x: java.lang.Object): Int \u003d ???\n\n  /** The String representation of the scala.Int companion object. */\n  override def toString \u003d \"object scala.Int\"\n  /** Language mandated coercions from Int to \"wider\" types. */\n  import scala.language.implicitConversions\n  @deprecated(\"Implicit conversion from Int to Float is dangerous because it loses precision. Write `.toFloat` instead.\", \"2.13.1\")\n  implicit def int2float(x: Int): Float \u003d x.toFloat\n  implicit def int2long(x: Int): Long \u003d x.toLong\n  implicit def int2double(x: Int): Double \u003d x.toDouble\n}\n\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:53:58 INFO  compiling root (1 scala source)
2024.04.26 02:53:58 INFO  time: compiled root in 0.32s
Apr. 26, 2024 2:54:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Option.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Option.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:54:35 WARN  Using indexes to guess the definition of space
2024.04.26 02:54:35 INFO  compiling root (1 scala source)
2024.04.26 02:54:35 INFO  time: compiled root in 96ms
2024.04.26 02:54:46 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 2:54:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\nimport scala.annotation.migration\n\n/**\n * Core Scala types. They are always available without an explicit import.\n * @contentDiagram hideNodes \"scala.Serializable\"\n */\npackage object scala {\n  type Cloneable    \u003d java.lang.Cloneable\n  type Serializable \u003d java.io.Serializable\n\n  type Throwable \u003d java.lang.Throwable\n  type Exception \u003d java.lang.Exception\n  type Error     \u003d java.lang.Error\n\n  type RuntimeException                \u003d java.lang.RuntimeException\n  type NullPointerException            \u003d java.lang.NullPointerException\n  type ClassCastException              \u003d java.lang.ClassCastException\n  type IndexOutOfBoundsException       \u003d java.lang.IndexOutOfBoundsException\n  type ArrayIndexOutOfBoundsException  \u003d java.lang.ArrayIndexOutOfBoundsException\n  type StringIndexOutOfBoundsException \u003d java.lang.StringIndexOutOfBoundsException\n  type UnsupportedOperationException   \u003d java.lang.UnsupportedOperationException\n  type IllegalArgumentException        \u003d java.lang.IllegalArgumentException\n  type NoSuchElementException          \u003d java.util.NoSuchElementException\n  type NumberFormatException           \u003d java.lang.NumberFormatException\n  type AbstractMethodError             \u003d java.lang.AbstractMethodError\n  type InterruptedException            \u003d java.lang.InterruptedException\n\n  // A dummy used by the specialization annotation.\n  val AnyRef \u003d new Specializable {\n    override def toString \u003d \"object AnyRef\"\n  }\n\n  @deprecated(\"Use IterableOnce instead of TraversableOnce\", \"2.13.0\")\n  type TraversableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  type IterableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  type Traversable[+A] \u003d scala.collection.Iterable[A]\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  val Traversable \u003d scala.collection.Iterable\n\n  type Iterable[+A] \u003d scala.collection.Iterable[A]\n  val Iterable \u003d scala.collection.Iterable\n\n  @migration(\"scala.Seq is now scala.collection.immutable.Seq instead of scala.collection.Seq\", \"2.13.0\")\n  type Seq[+A] \u003d scala.collection.immutable.Seq[A]\n  val Seq \u003d scala.collection.immutable.Seq\n\n  @migration(\"scala.IndexedSeq is now scala.collection.immutable.IndexedSeq instead of scala.collection.IndexedSeq\", \"2.13.0\")\n  type IndexedSeq[+A] \u003d scala.collection.immutable.IndexedSeq[A]\n  val IndexedSeq \u003d scala.collection.immutable.IndexedSeq\n\n  type Iterator[+A] \u003d scala.collection.Iterator[A]\n  val Iterator \u003d scala.collection.Iterator\n\n  @deprecated(\"Use scala.collection.BufferedIterator instead of scala.BufferedIterator\", \"2.13.0\")\n  type BufferedIterator[+A] \u003d scala.collection.BufferedIterator[A]\n\n  type List[+A] \u003d scala.collection.immutable.List[A]\n  val List \u003d scala.collection.immutable.List\n\n  val Nil \u003d scala.collection.immutable.Nil\n\n  type ::[+A] \u003d scala.collection.immutable.::[A]\n  val :: \u003d scala.collection.immutable.::\n\n  val +: \u003d scala.collection.+:\n  val :+ \u003d scala.collection.:+\n\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  type Stream[+A] \u003d scala.collection.immutable.Stream[A]\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  val Stream \u003d scala.collection.immutable.Stream\n\n  type LazyList[+A] \u003d scala.collection.immutable.LazyList[A]\n  val LazyList \u003d scala.collection.immutable.LazyList\n  // This should be an alias to LazyList.#:: but we need to support Stream, too\n  //val #:: \u003d scala.collection.immutable.LazyList.#::\n  object #:: {\n    def unapply[A](s: LazyList[A]): Option[(A, LazyList[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n    @deprecated(\"Prefer LazyList instead\", since \u003d \"2.13.0\")\n    def unapply[A](s: Stream[A]): Option[(A, Stream[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n  }\n\n  type Vector[+A] \u003d scala.collection.immutable.Vector[A]\n  val Vector \u003d scala.collection.immutable.Vector\n\n  type StringBuilder \u003d scala.collection.mutable.StringBuilder\n  val StringBuilder \u003d scala.collection.mutable.StringBuilder\n\n  type Range \u003d scala.collection.immutable.Range\n  val Range \u003d scala.collection.immutable.Range\n\n  // Numeric types which were moved into scala.math.*\n\n  type BigDecimal \u003d scala.math.BigDecimal\n  val BigDecimal \u003d scala.math.BigDecimal\n\n  type BigInt \u003d scala.math.BigInt\n  val BigInt \u003d scala.math.BigInt\n\n  type Equiv[T] \u003d scala.math.Equiv[T]\n  val Equiv \u003d scala.math.Equiv\n\n  type Fractional[T] \u003d scala.math.Fractional[T]\n  val Fractional \u003d scala.math.Fractional\n\n  type Integral[T] \u003d scala.math.Integral[T]\n  val Integral \u003d scala.math.Integral\n\n  type Numeric[T] \u003d scala.math.Numeric[T]\n  val Numeric \u003d scala.math.Numeric\n\n  type Ordered[T] \u003d scala.math.Ordered[T]\n  val Ordered \u003d scala.math.Ordered\n\n  type Ordering[T] \u003d scala.math.Ordering[T]\n  val Ordering \u003d scala.math.Ordering\n\n  type PartialOrdering[T] \u003d scala.math.PartialOrdering[T]\n  type PartiallyOrdered[T] \u003d scala.math.PartiallyOrdered[T]\n\n  type Either[+A, +B] \u003d scala.util.Either[A, B]\n  val Either \u003d scala.util.Either\n\n  type Left[+A, +B] \u003d scala.util.Left[A, B]\n  val Left \u003d scala.util.Left\n\n  type Right[+A, +B] \u003d scala.util.Right[A, B]\n  val Right \u003d scala.util.Right\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 2:54:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:54:46 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 2:54:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\nimport scala.annotation.migration\n\n/**\n * Core Scala types. They are always available without an explicit import.\n * @contentDiagram hideNodes \"scala.Serializable\"\n */\npackage object scala {\n  type Cloneable    \u003d java.lang.Cloneable\n  type Serializable \u003d java.io.Serializable\n\n  type Throwable \u003d java.lang.Throwable\n  type Exception \u003d java.lang.Exception\n  type Error     \u003d java.lang.Error\n\n  type RuntimeException                \u003d java.lang.RuntimeException\n  type NullPointerException            \u003d java.lang.NullPointerException\n  type ClassCastException              \u003d java.lang.ClassCastException\n  type IndexOutOfBoundsException       \u003d java.lang.IndexOutOfBoundsException\n  type ArrayIndexOutOfBoundsException  \u003d java.lang.ArrayIndexOutOfBoundsException\n  type StringIndexOutOfBoundsException \u003d java.lang.StringIndexOutOfBoundsException\n  type UnsupportedOperationException   \u003d java.lang.UnsupportedOperationException\n  type IllegalArgumentException        \u003d java.lang.IllegalArgumentException\n  type NoSuchElementException          \u003d java.util.NoSuchElementException\n  type NumberFormatException           \u003d java.lang.NumberFormatException\n  type AbstractMethodError             \u003d java.lang.AbstractMethodError\n  type InterruptedException            \u003d java.lang.InterruptedException\n\n  // A dummy used by the specialization annotation.\n  val AnyRef \u003d new Specializable {\n    override def toString \u003d \"object AnyRef\"\n  }\n\n  @deprecated(\"Use IterableOnce instead of TraversableOnce\", \"2.13.0\")\n  type TraversableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  type IterableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  type Traversable[+A] \u003d scala.collection.Iterable[A]\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  val Traversable \u003d scala.collection.Iterable\n\n  type Iterable[+A] \u003d scala.collection.Iterable[A]\n  val Iterable \u003d scala.collection.Iterable\n\n  @migration(\"scala.Seq is now scala.collection.immutable.Seq instead of scala.collection.Seq\", \"2.13.0\")\n  type Seq[+A] \u003d scala.collection.immutable.Seq[A]\n  val Seq \u003d scala.collection.immutable.Seq\n\n  @migration(\"scala.IndexedSeq is now scala.collection.immutable.IndexedSeq instead of scala.collection.IndexedSeq\", \"2.13.0\")\n  type IndexedSeq[+A] \u003d scala.collection.immutable.IndexedSeq[A]\n  val IndexedSeq \u003d scala.collection.immutable.IndexedSeq\n\n  type Iterator[+A] \u003d scala.collection.Iterator[A]\n  val Iterator \u003d scala.collection.Iterator\n\n  @deprecated(\"Use scala.collection.BufferedIterator instead of scala.BufferedIterator\", \"2.13.0\")\n  type BufferedIterator[+A] \u003d scala.collection.BufferedIterator[A]\n\n  type List[+A] \u003d scala.collection.immutable.List[A]\n  val List \u003d scala.collection.immutable.List\n\n  val Nil \u003d scala.collection.immutable.Nil\n\n  type ::[+A] \u003d scala.collection.immutable.::[A]\n  val :: \u003d scala.collection.immutable.::\n\n  val +: \u003d scala.collection.+:\n  val :+ \u003d scala.collection.:+\n\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  type Stream[+A] \u003d scala.collection.immutable.Stream[A]\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  val Stream \u003d scala.collection.immutable.Stream\n\n  type LazyList[+A] \u003d scala.collection.immutable.LazyList[A]\n  val LazyList \u003d scala.collection.immutable.LazyList\n  // This should be an alias to LazyList.#:: but we need to support Stream, too\n  //val #:: \u003d scala.collection.immutable.LazyList.#::\n  object #:: {\n    def unapply[A](s: LazyList[A]): Option[(A, LazyList[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n    @deprecated(\"Prefer LazyList instead\", since \u003d \"2.13.0\")\n    def unapply[A](s: Stream[A]): Option[(A, Stream[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n  }\n\n  type Vector[+A] \u003d scala.collection.immutable.Vector[A]\n  val Vector \u003d scala.collection.immutable.Vector\n\n  type StringBuilder \u003d scala.collection.mutable.StringBuilder\n  val StringBuilder \u003d scala.collection.mutable.StringBuilder\n\n  type Range \u003d scala.collection.immutable.Range\n  val Range \u003d scala.collection.immutable.Range\n\n  // Numeric types which were moved into scala.math.*\n\n  type BigDecimal \u003d scala.math.BigDecimal\n  val BigDecimal \u003d scala.math.BigDecimal\n\n  type BigInt \u003d scala.math.BigInt\n  val BigInt \u003d scala.math.BigInt\n\n  type Equiv[T] \u003d scala.math.Equiv[T]\n  val Equiv \u003d scala.math.Equiv\n\n  type Fractional[T] \u003d scala.math.Fractional[T]\n  val Fractional \u003d scala.math.Fractional\n\n  type Integral[T] \u003d scala.math.Integral[T]\n  val Integral \u003d scala.math.Integral\n\n  type Numeric[T] \u003d scala.math.Numeric[T]\n  val Numeric \u003d scala.math.Numeric\n\n  type Ordered[T] \u003d scala.math.Ordered[T]\n  val Ordered \u003d scala.math.Ordered\n\n  type Ordering[T] \u003d scala.math.Ordering[T]\n  val Ordering \u003d scala.math.Ordering\n\n  type PartialOrdering[T] \u003d scala.math.PartialOrdering[T]\n  type PartiallyOrdered[T] \u003d scala.math.PartiallyOrdered[T]\n\n  type Either[+A, +B] \u003d scala.util.Either[A, B]\n  val Either \u003d scala.util.Either\n\n  type Left[+A, +B] \u003d scala.util.Left[A, B]\n  val Left \u003d scala.util.Left\n\n  type Right[+A, +B] \u003d scala.util.Right[A, B]\n  val Right \u003d scala.util.Right\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:54:46 INFO  compiling root (1 scala source)
2024.04.26 02:54:46 INFO  time: compiled root in 0.28s
2024.04.26 02:55:51 INFO  compiling root-test (3 scala sources)
2024.04.26 02:55:51 INFO  time: compiled root-test in 0.18s
2024.04.26 02:55:51 INFO  compiling root-test (3 scala sources)
2024.04.26 02:55:52 INFO  time: compiled root-test in 0.24s
Apr. 26, 2024 2:56:52 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 2:57:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 2:58:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4800
2024.04.26 02:58:08 INFO  compiling root (1 scala source)
2024.04.26 02:58:08 INFO  time: compiled root in 0.22s
2024.04.26 02:58:18 INFO  compiling root (1 scala source)
2024.04.26 02:58:18 INFO  time: compiled root in 0.2s
2024.04.26 02:59:18 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
scala.meta.tokenizers.TokenizeException: <input>:22: error: Invalid literal number, followed by identifier character
        val row2 = number2.toInt - 1if(b.movePieces(readCoordinates())){
                                    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:834)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInteger$1(LegacyScanner.scala:857)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:875)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:342)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 02:59:22 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 2:59:22 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2022, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.Preconditions;\nimport jdk.internal.vm.annotation.ForceInline;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.US_ASCII;\nimport sun.nio.cs.UTF_8;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2, 3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence,\n               Constable, ConstantDesc {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /**\n     * Cache if the hash has been calculated as actually being zero, enabling\n     * us to avoid recalculating this.\n     */\n    private boolean hashIsZero; // Default to false;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    @java.io.Serial\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @IntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n        this.hashIsZero \u003d original.hashIsZero;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char[] value) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char[] value, int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        this(bytes, offset, length, lookupCharset(charsetName));\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    @SuppressWarnings(\"removal\")\n    public String(byte[] bytes, int offset, int length, Charset charset) {\n        Objects.requireNonNull(charset);\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n        } else if (charset \u003d\u003d UTF_8.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                int dp \u003d StringCoding.countPositives(bytes, offset, length);\n                if (dp \u003d\u003d length) {\n                    this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                int sl \u003d offset + length;\n                byte[] dst \u003d new byte[length];\n                if (dp \u003e 0) {\n                    System.arraycopy(bytes, offset, dst, 0, dp);\n                    offset +\u003d dp;\n                }\n                while (offset \u003c sl) {\n                    int b1 \u003d bytes[offset++];\n                    if (b1 \u003e\u003d 0) {\n                        dst[dp++] \u003d (byte)b1;\n                        continue;\n                    }\n                    if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                        int b2 \u003d bytes[offset];\n                        if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                            dst[dp++] \u003d (byte)decode2(b1, b2);\n                            offset++;\n                            continue;\n                        }\n                    }\n                    // anything not a latin1, including the REPL\n                    // we have to go with the utf16\n                    offset--;\n                    break;\n                }\n                if (offset \u003d\u003d sl) {\n                    if (dp !\u003d dst.length) {\n                        dst \u003d Arrays.copyOf(dst, dp);\n                    }\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n                dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            } else { // !COMPACT_STRINGS\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d US_ASCII.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d 0;\n                while (dp \u003c length) {\n                    int b \u003d bytes[offset++];\n                    StringUTF16.putChar(dst, dp++, (b \u003e\u003d 0) ? (char) b : REPL);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else {\n            // (1)We never cache the \"external\" cs, the only benefit of creating\n            // an additional StringDe/Encoder object to wrap it is to share the\n            // de/encode() method. These SD/E objects are short-lived, the young-gen\n            // gc should be able to take care of them well. But the best approach\n            // is still not to generate them if not really necessary.\n            // (2)The defensive copy of the input byte/char[] has a big performance\n            // impact, as well as the outgoing result byte/char[]. Need to do the\n            // optimization check of (sm\u003d\u003dnull \u0026\u0026 classLoader0\u003d\u003dnull) for both.\n            CharsetDecoder cd \u003d charset.newDecoder();\n            // ArrayDecoder fastpaths\n            if (cd instanceof ArrayDecoder ad) {\n                // ascii\n                if (ad.isASCIICompatible() \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                    if (COMPACT_STRINGS) {\n                        this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                    this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                    this.coder \u003d UTF16;\n                    return;\n                }\n\n                // fastpath for always Latin1 decodable single byte\n                if (COMPACT_STRINGS \u0026\u0026 ad.isLatin1Decodable()) {\n                    byte[] dst \u003d new byte[length];\n                    ad.decodeToLatin1(bytes, offset, length, dst);\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n\n                int en \u003d scale(length, cd.maxCharsPerByte());\n                cd.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                char[] ca \u003d new char[en];\n                int clen \u003d ad.decode(bytes, offset, length, ca);\n                if (COMPACT_STRINGS) {\n                    byte[] bs \u003d StringUTF16.compress(ca, 0, clen);\n                    if (bs !\u003d null) {\n                        value \u003d bs;\n                        coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                coder \u003d UTF16;\n                value \u003d StringUTF16.toBytes(ca, 0, clen);\n                return;\n            }\n\n            // decode using CharsetDecoder\n            int en \u003d scale(length, cd.maxCharsPerByte());\n            cd.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            char[] ca \u003d new char[en];\n            if (charset.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                    System.getSecurityManager() !\u003d null) {\n                bytes \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                offset \u003d 0;\n            }\n\n            int caLen;\n            try {\n                caLen \u003d decodeWithDecoder(cd, ca, bytes, offset, length);\n            } catch (CharacterCodingException x) {\n                // Substitution is enabled, so this shouldn\u0027t happen\n                throw new Error(x);\n            }\n            if (COMPACT_STRINGS) {\n                byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n                if (bs !\u003d null) {\n                    value \u003d bs;\n                    coder \u003d LATIN1;\n                    return;\n                }\n            }\n            coder \u003d UTF16;\n            value \u003d StringUTF16.toBytes(ca, 0, caLen);\n        }\n    }\n\n    /*\n     * Throws iae, instead of replacing, if malformed or unmappable.\n     */\n    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        int dp;\n        byte[] dst;\n        if (COMPACT_STRINGS) {\n            dp \u003d StringCoding.countPositives(bytes, offset, length);\n            int sl \u003d offset + length;\n            if (dp \u003d\u003d length) {\n                return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n            }\n            dst \u003d new byte[length];\n            System.arraycopy(bytes, offset, dst, 0, dp);\n            offset +\u003d dp;\n            while (offset \u003c sl) {\n                int b1 \u003d bytes[offset++];\n                if (b1 \u003e\u003d 0) {\n                    dst[dp++] \u003d (byte)b1;\n                    continue;\n                }\n                if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                    int b2 \u003d bytes[offset];\n                    if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                        dst[dp++] \u003d (byte)decode2(b1, b2);\n                        offset++;\n                        continue;\n                    }\n                }\n                // anything not a latin1, including the REPL\n                // we have to go with the utf16\n                offset--;\n                break;\n            }\n            if (offset \u003d\u003d sl) {\n                if (dp !\u003d dst.length) {\n                    dst \u003d Arrays.copyOf(dst, dp);\n                }\n                return new String(dst, LATIN1);\n            }\n            if (dp \u003d\u003d 0) {\n                dst \u003d new byte[length \u003c\u003c 1];\n            } else {\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n            }\n            dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n        } else { // !COMPACT_STRINGS\n            dst \u003d new byte[length \u003c\u003c 1];\n            dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n        }\n        if (dp !\u003d length) {\n            dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n        }\n        return new String(dst, UTF16);\n    }\n\n    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n        try {\n            return newStringNoRepl1(src, cs);\n        } catch (IllegalArgumentException e) {\n            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof MalformedInputException mie) {\n                throw mie;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static String newStringNoRepl1(byte[] src, Charset cs) {\n        int len \u003d src.length;\n        if (len \u003d\u003d 0) {\n            return \"\";\n        }\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return newStringUTF8NoRepl(src, 0, src.length);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n                if (COMPACT_STRINGS)\n                    return new String(src, LATIN1);\n                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n            } else {\n                throwMalformed(src);\n            }\n        }\n\n        CharsetDecoder cd \u003d cs.newDecoder();\n        // ascii fastpath\n        if (cd instanceof ArrayDecoder ad \u0026\u0026\n                ad.isASCIICompatible() \u0026\u0026\n                !StringCoding.hasNegatives(src, 0, src.length)) {\n            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n        }\n        int en \u003d scale(len, cd.maxCharsPerByte());\n        char[] ca \u003d new char[en];\n        if (cs.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                System.getSecurityManager() !\u003d null) {\n            src \u003d Arrays.copyOf(src, len);\n        }\n        int caLen;\n        try {\n            caLen \u003d decodeWithDecoder(cd, ca, src, 0, src.length);\n        } catch (CharacterCodingException x) {\n            // throw via IAE\n            throw new IllegalArgumentException(x);\n        }\n        if (COMPACT_STRINGS) {\n            byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n            if (bs !\u003d null) {\n                return new String(bs, LATIN1);\n            }\n        }\n        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n    }\n\n    private static final char REPL \u003d \u0027\\ufffd\u0027;\n\n    // Trim the given byte array to the given length\n    @SuppressWarnings(\"removal\")\n    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n        if (len \u003d\u003d ba.length \u0026\u0026 (isTrusted || System.getSecurityManager() \u003d\u003d null)) {\n            return ba;\n        } else {\n            return Arrays.copyOf(ba, len);\n        }\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n        Objects.requireNonNull(csn);\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n            throw new UnsupportedEncodingException(csn);\n        }\n    }\n\n    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return encodeUTF8(coder, val, true);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            return encode8859_1(coder, val);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            return encodeASCII(coder, val);\n        }\n        return encodeWithEncoder(cs, coder, val, true);\n    }\n\n    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n        CharsetEncoder ce \u003d cs.newEncoder();\n        int len \u003d val.length \u003e\u003e coder;  // assume LATIN1\u003d0/UTF16\u003d1;\n        int en \u003d scale(len, ce.maxBytesPerChar());\n        // fastpath with ArrayEncoder implies `doReplace`.\n        if (doReplace \u0026\u0026 ce instanceof ArrayEncoder ae) {\n            // fastpath for ascii compatible\n            if (coder \u003d\u003d LATIN1 \u0026\u0026\n                    ae.isASCIICompatible() \u0026\u0026\n                    !StringCoding.hasNegatives(val, 0, val.length)) {\n                return Arrays.copyOf(val, val.length);\n            }\n            byte[] ba \u003d new byte[en];\n            if (len \u003d\u003d 0) {\n                return ba;\n            }\n\n            int blen \u003d (coder \u003d\u003d LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n                    : ae.encodeFromUTF16(val, 0, len, ba);\n            if (blen !\u003d -1) {\n                return safeTrim(ba, blen, true);\n            }\n        }\n\n        byte[] ba \u003d new byte[en];\n        if (len \u003d\u003d 0) {\n            return ba;\n        }\n        if (doReplace) {\n            ce.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        char[] ca \u003d (coder \u003d\u003d LATIN1 ) ? StringLatin1.toChars(val)\n                : StringUTF16.toChars(val);\n        ByteBuffer bb \u003d ByteBuffer.wrap(ba);\n        CharBuffer cb \u003d CharBuffer.wrap(ca, 0, len);\n        try {\n            CoderResult cr \u003d ce.encode(cb, bb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d ce.flush(bb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            if (!doReplace) {\n                throw new IllegalArgumentException(x);\n            } else {\n                throw new Error(x);\n            }\n        }\n        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() \u003d\u003d null);\n    }\n\n    /*\n     * Throws iae, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesUTF8NoRepl(String s) {\n        return encodeUTF8(s.coder(), s.value(), false);\n    }\n\n    private static boolean isASCII(byte[] src) {\n        return !StringCoding.hasNegatives(src, 0, src.length);\n    }\n\n    /*\n     * Throws CCE, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n        try {\n            return getBytesNoRepl1(s, cs);\n        } catch (IllegalArgumentException e) {\n            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof UnmappableCharacterException) {\n                throw (UnmappableCharacterException)cause;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n        byte[] val \u003d s.value();\n        byte coder \u003d s.coder();\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            if (coder \u003d\u003d LATIN1 \u0026\u0026 isASCII(val)) {\n                return val;\n            }\n            return encodeUTF8(coder, val, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                return val;\n            }\n            return encode8859_1(coder, val, false);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                if (isASCII(val)) {\n                    return val;\n                } else {\n                    throwUnmappable(val);\n                }\n            }\n        }\n        return encodeWithEncoder(cs, coder, val, false);\n    }\n\n    private static byte[] encodeASCII(byte coder, byte[] val) {\n        if (coder \u003d\u003d LATIN1) {\n            byte[] dst \u003d Arrays.copyOf(val, val.length);\n            for (int i \u003d 0; i \u003c dst.length; i++) {\n                if (dst[i] \u003c 0) {\n                    dst[i] \u003d \u0027?\u0027;\n                }\n            }\n            return dst;\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        for (int i \u003d 0; i \u003c len; i++) {\n            char c \u003d StringUTF16.getChar(val, i);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n                continue;\n            }\n            if (Character.isHighSurrogate(c) \u0026\u0026 i + 1 \u003c len \u0026\u0026\n                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n                i++;\n            }\n            dst[dp++] \u003d \u0027?\u0027;\n        }\n        if (len \u003d\u003d dp) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val) {\n        return encode8859_1(coder, val, true);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d LATIN1) {\n            return Arrays.copyOf(val, val.length);\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d len;\n        while (sp \u003c sl) {\n            int ret \u003d StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n            sp \u003d sp + ret;\n            dp \u003d dp + ret;\n            if (ret !\u003d len) {\n                if (!doReplace) {\n                    throwUnmappable(sp);\n                }\n                char c \u003d StringUTF16.getChar(val, sp++);\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n                    sp++;\n                }\n                dst[dp++] \u003d \u0027?\u0027;\n                len \u003d sl - sp;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    //////////////////////////////// utf8 ////////////////////////////////////\n\n    /**\n     * Decodes ASCII from the source byte array into the destination\n     * char array. Used via JavaLangAccess from UTF_8 and other charset\n     * decoders.\n     *\n     * @return the number of bytes successfully decoded, at most len\n     */\n    /* package-private */\n    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n        int count \u003d StringCoding.countPositives(sa, sp, len);\n        while (count \u003c len) {\n            if (sa[sp + count] \u003c 0) {\n                break;\n            }\n            count++;\n        }\n        StringLatin1.inflate(sa, sp, da, dp, count);\n        return count;\n    }\n\n    private static boolean isNotContinuation(int b) {\n        return (b \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3(int b1, int b2, int b3) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3_2(int b1, int b2) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4(int b2, int b3, int b4) {\n        return (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80 ||\n                (b4 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_2(int b1, int b2) {\n        return (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_3(int b3) {\n        return (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static char decode2(int b1, int b2) {\n        return (char)(((b1 \u003c\u003c 6) ^ b2) ^\n                (((byte) 0xC0 \u003c\u003c 6) ^\n                        ((byte) 0x80 \u003c\u003c 0)));\n    }\n\n    private static char decode3(int b1, int b2, int b3) {\n        return (char)((b1 \u003c\u003c 12) ^\n                (b2 \u003c\u003c  6) ^\n                (b3 ^\n                        (((byte) 0xE0 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decode4(int b1, int b2, int b3, int b4) {\n        return ((b1 \u003c\u003c 18) ^\n                (b2 \u003c\u003c 12) ^\n                (b3 \u003c\u003c  6) ^\n                (b4 ^\n                        (((byte) 0xF0 \u003c\u003c 18) ^\n                                ((byte) 0x80 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n        while (sp \u003c sl) {\n            int b1 \u003d src[sp++];\n            if (b1 \u003e\u003d 0) {\n                StringUTF16.putChar(dst, dp++, (char) b1);\n            } else if ((b1 \u003e\u003e 5) \u003d\u003d -2 \u0026\u0026 (b1 \u0026 0x1e) !\u003d 0) {\n                if (sp \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    if (isNotContinuation(b2)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 1, 1);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp--;\n                    } else {\n                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n                    }\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);  // underflow()\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 4) \u003d\u003d -2) {\n                if (sp + 1 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    if (isMalformed3(b1, b2, b3)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 3, 3);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 3;\n                        sp +\u003d malformed3(src, sp);\n                    } else {\n                        char c \u003d decode3(b1, b2, b3);\n                        if (Character.isSurrogate(c)) {\n                            if (!doReplace) {\n                                throwMalformed(sp - 3, 3);\n                            }\n                            StringUTF16.putChar(dst, dp++, REPL);\n                        } else {\n                            StringUTF16.putChar(dst, dp++, c);\n                        }\n                    }\n                    continue;\n                }\n                if (sp \u003c sl \u0026\u0026 isMalformed3_2(b1, src[sp])) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 2);\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 3) \u003d\u003d -2) {\n                if (sp + 2 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    int b4 \u003d src[sp++];\n                    int uc \u003d decode4(b1, b2, b3, b4);\n                    if (isMalformed4(b2, b3, b4) ||\n                            !Character.isSupplementaryCodePoint(uc)) { // shortest form check\n                        if (!doReplace) {\n                            throwMalformed(sp - 4, 4);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 4;\n                        sp +\u003d malformed4(src, sp);\n                    } else {\n                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n                    }\n                    continue;\n                }\n                b1 \u0026\u003d 0xff;\n                if (b1 \u003e 0xf4 || sp \u003c sl \u0026\u0026 isMalformed4_2(b1, src[sp] \u0026 0xff)) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 1);  // or 2\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                sp++;\n                StringUTF16.putChar(dst, dp++, REPL);\n                if (sp \u003c sl \u0026\u0026 isMalformed4_3(src[sp])) {\n                    continue;\n                }\n                break;\n            } else {\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n            }\n        }\n        return dp;\n    }\n\n    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n                                            throws CharacterCodingException {\n        ByteBuffer bb \u003d ByteBuffer.wrap(src, offset, length);\n        CharBuffer cb \u003d CharBuffer.wrap(dst, 0, dst.length);\n        CoderResult cr \u003d cd.decode(bb, cb, true);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        cr \u003d cd.flush(cb);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        return cb.position();\n    }\n\n    private static int malformed3(byte[] src, int sp) {\n        int b1 \u003d src[sp++];\n        int b2 \u003d src[sp];    // no need to lookup b3\n        return ((b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                isNotContinuation(b2)) ? 1 : 2;\n    }\n\n    private static int malformed4(byte[] src, int sp) {\n        // we don\u0027t care the speed here\n        int b1 \u003d src[sp++] \u0026 0xff;\n        int b2 \u003d src[sp++] \u0026 0xff;\n        if (b1 \u003e 0xf4 ||\n                (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                isNotContinuation(b2))\n            return 1;\n        if (isNotContinuation(src[sp]))\n            return 2;\n        return 3;\n    }\n\n    private static void throwMalformed(int off, int nb) {\n        String msg \u003d \"malformed input off : \" + off + \", length : \" + nb;\n        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n    }\n\n    private static void throwMalformed(byte[] val) {\n        int dp \u003d 0;\n        while (dp \u003c val.length \u0026\u0026 val[dp] \u003e\u003d0) { dp++; }\n        throwMalformed(dp, 1);\n    }\n\n    private static void throwUnmappable(int off) {\n        String msg \u003d \"malformed input off : \" + off + \", length : 1\";\n        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n    }\n\n    private static void throwUnmappable(byte[] val) {\n        int dp \u003d 0;\n        while (dp \u003c val.length \u0026\u0026 val[dp] \u003e\u003d0) { dp++; }\n        throwUnmappable(dp);\n    }\n\n    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d UTF16)\n            return encodeUTF8_UTF16(val, doReplace);\n\n        if (!StringCoding.hasNegatives(val, 0, val.length))\n            return Arrays.copyOf(val, val.length);\n\n        int dp \u003d 0;\n        byte[] dst \u003d new byte[val.length \u003c\u003c 1];\n        for (byte c : val) {\n            if (c \u003c 0) {\n                dst[dp++] \u003d (byte) (0xc0 | ((c \u0026 0xff) \u003e\u003e 6));\n                dst[dp++] \u003d (byte) (0x80 | (c \u0026 0x3f));\n            } else {\n                dst[dp++] \u003d c;\n            }\n        }\n        if (dp \u003d\u003d dst.length)\n            return dst;\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[sl * 3];\n        while (sp \u003c sl) {\n            // ascii fast loop;\n            char c \u003d StringUTF16.getChar(val, sp);\n            if (c \u003e\u003d \u0027\\u0080\u0027) {\n                break;\n            }\n            dst[dp++] \u003d (byte)c;\n            sp++;\n        }\n        while (sp \u003c sl) {\n            char c \u003d StringUTF16.getChar(val, sp++);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n            } else if (c \u003c 0x800) {\n                dst[dp++] \u003d (byte)(0xc0 | (c \u003e\u003e 6));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            } else if (Character.isSurrogate(c)) {\n                int uc \u003d -1;\n                char c2;\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(c2 \u003d StringUTF16.getChar(val, sp))) {\n                    uc \u003d Character.toCodePoint(c, c2);\n                }\n                if (uc \u003c 0) {\n                    if (doReplace) {\n                        dst[dp++] \u003d \u0027?\u0027;\n                    } else {\n                        throwUnmappable(sp - 1);\n                    }\n                } else {\n                    dst[dp++] \u003d (byte)(0xf0 | ((uc \u003e\u003e 18)));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e 12) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e  6) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | (uc \u0026 0x3f));\n                    sp++;  // 2 chars\n                }\n            } else {\n                // 3 bytes, 16 bits\n                dst[dp++] \u003d (byte)(0xe0 | ((c \u003e\u003e 12)));\n                dst[dp++] \u003d (byte)(0x80 | ((c \u003e\u003e  6) \u0026 0x3f));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, String charsetName)\n            throws UnsupportedEncodingException {\n        this(bytes, 0, bytes.length, charsetName);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, Charset charset) {\n        this(bytes, 0, bytes.length, charset);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the {@link Charset#defaultCharset() default charset}.\n     * The length of the new {@code String} is a function of the charset,\n     * and hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length) {\n        this(bytes, offset, length, Charset.defaultCharset());\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the {@link Charset#defaultCharset() default charset}. The length\n     * of the new {@code String} is a function of the charset, and hence may not\n     * be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    @Override\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        checkIndex(i, length());\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        Objects.checkFromToIndex(beginIndex, endIndex, length());\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger then the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        if (index \u003c 0 || index \u003e length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @throws    IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the {@link Charset#defaultCharset()\n     * default charset}.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        return encode(lookupCharset(charsetName), coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * {@link Charset#defaultCharset() default charset}, storing the result\n     * into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return encode(Charset.defaultCharset(), coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        return (anObject instanceof String aString)\n                \u0026\u0026 (!COMPACT_STRINGS || this.coder \u003d\u003d aString.coder)\n                \u0026\u0026 StringLatin1.equals(value, aString.value);\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte v1[] \u003d value;\n        byte v2[] \u003d sb.getValue();\n        byte coder \u003d coder();\n        if (coder \u003d\u003d sb.getCoder()) {\n            int n \u003d v1.length;\n            for (int i \u003d 0; i \u003c n; i++) {\n                if (v1[i] !\u003d v2[i]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder !\u003d LATIN1) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n        return true;\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding Unicode code points in the two\n     * strings are equal ignoring case.\n     *\n     * \u003cp\u003e Two Unicode code points are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two Unicode code points are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(int))}\n     *        on each Unicode code point produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     * @see  #codePoints()\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte v1[] \u003d value;\n        byte v2[] \u003d anotherString.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d anotherString.coder()) {\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareTo(v1, v2)\n                                   : StringUTF16.compareTo(v1, v2);\n        }\n        return coder \u003d\u003d LATIN1 ? StringLatin1.compareToUTF16(v1, v2)\n                               : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@link #compareToIgnoreCase(String) compareToIgnoreCase}.\n     * This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n\n    /**\n     * CaseInsensitiveComparator for Strings.\n     */\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        @java.io.Serial\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte v1[] \u003d s1.value;\n            byte v2[] \u003d s2.value;\n            byte coder \u003d s1.coder();\n            if (coder \u003d\u003d s2.coder()) {\n                return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI(v1, v2)\n                                       : StringUTF16.compareToCI(v1, v2);\n            }\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                   : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        @java.io.Serial\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with case folded versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(int))} on\n     * each Unicode code point.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @see     #codePoints()\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        byte tv[] \u003d value;\n        byte ov[] \u003d other.value;\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            if (!isLatin1() \u0026\u0026 (len \u003e 0)) {\n                toffset \u003d toffset \u003c\u003c 1;\n                ooffset \u003d ooffset \u003c\u003c 1;\n                len \u003d len \u003c\u003c 1;\n            }\n            while (len-- \u003e 0) {\n                if (tv[toffset++] !\u003d ov[ooffset++]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent Unicode code point sequences that are the same,\n     * ignoring case if and only if {@code ignoreCase} is true.\n     * The sequences {@code tsequence} and {@code osequence} are compared,\n     * where {@code tsequence} is the sequence produced as if by calling\n     * {@code this.substring(toffset, toffset + len).codePoints()} and\n     * {@code osequence} is the sequence produced as if by calling\n     * {@code other.substring(ooffset, ooffset + len).codePoints()}.\n     * The result is {@code true} if and only if all of the following\n     * are true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is non-negative.\n     * \u003cli\u003e{@code ooffset} is non-negative.\n     * \u003cli\u003e{@code toffset+len} is less than or equal to the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is less than or equal to the length of the other\n     * argument.\n     * \u003cli\u003eif {@code ignoreCase} is {@code false}, all pairs of corresponding Unicode\n     * code points are equal integer values; or if {@code ignoreCase} is {@code true},\n     * {@link Character#toLowerCase(int) Character.toLowerCase(}\n     * {@link Character#toUpperCase(int)}{@code )} on all pairs of Unicode code points\n     * results in equal integer values.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters (Unicode code units -\n     *                       16bit {@code char} value) to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     * @see     #codePoints()\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte tv[] \u003d value;\n        byte ov[] \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte ta[] \u003d value;\n        byte pa[] \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d prefix.coder()) {\n            int to \u003d (coder \u003d\u003d LATIN1) ? toffset : toffset \u003c\u003c 1;\n            while (po \u003c pc) {\n                if (ta[to++] !\u003d pa[po++]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder \u003d\u003d LATIN1) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        // The hash or hashIsZero fields are subject to a benign data race,\n        // making it crucial to ensure that any observable result of the\n        // calculation in this method stays correct under any possible read of\n        // these fields. Necessary restrictions to allow this to be correct\n        // without explicit memory fences or similar concurrency primitives is\n        // that we can ever only write to one of these two fields for a given\n        // String instance, and that the computation is idempotent and derived\n        // from immutable state\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 !hashIsZero) {\n            h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                           : StringUTF16.hashCode(value);\n            if (h \u003d\u003d 0) {\n                hashIsZero \u003d true;\n            } else {\n                hash \u003d h;\n            }\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex)\n                          : StringUTF16.indexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        byte coder \u003d coder();\n        if (coder \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  length of the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        byte[] tgt    \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount  \u003d tgtStr.length();\n\n        if (fromIndex \u003e\u003d srcCount) {\n            return (tgtCount \u003d\u003d 0 ? srcCount : -1);\n        }\n        if (fromIndex \u003c 0) {\n            fromIndex \u003d 0;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (tgtCount \u003e srcCount) {\n            return -1;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        return substring(beginIndex, length());\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        int subLen \u003d endIndex - beginIndex;\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        return StringConcatHelper.simpleConcat(this, str);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll(String) replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String trgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int thisLen \u003d length();\n        int trgtLen \u003d trgtStr.length();\n        int replLen \u003d replStr.length();\n\n        if (trgtLen \u003e 0) {\n            if (trgtLen \u003d\u003d 1 \u0026\u0026 replLen \u003d\u003d 1) {\n                return replace(trgtStr.charAt(0), replStr.charAt(0));\n            }\n\n            boolean thisIsLatin1 \u003d this.isLatin1();\n            boolean trgtIsLatin1 \u003d trgtStr.isLatin1();\n            boolean replIsLatin1 \u003d replStr.isLatin1();\n            String ret \u003d (thisIsLatin1 \u0026\u0026 trgtIsLatin1 \u0026\u0026 replIsLatin1)\n                    ? StringLatin1.replace(value, thisLen,\n                                           trgtStr.value, trgtLen,\n                                           replStr.value, replLen)\n                    : StringUTF16.replace(value, thisLen, thisIsLatin1,\n                                          trgtStr.value, trgtLen, trgtIsLatin1,\n                                          replStr.value, replLen, replIsLatin1);\n            if (ret !\u003d null) {\n                return ret;\n            }\n            return this;\n\n        } else { // trgtLen \u003d\u003d 0\n            int resultLen;\n            try {\n                resultLen \u003d Math.addExact(thisLen, Math.multiplyExact(\n                        Math.addExact(thisLen, 1), replLen));\n            } catch (ArithmeticException ignored) {\n                throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n            }\n\n            StringBuilder sb \u003d new StringBuilder(resultLen);\n            sb.append(replStr);\n            for (int i \u003d 0; i \u003c thisLen; ++i) {\n                sb.append(charAt(i)).append(replStr);\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex, int limit) {\n        /* fastpath if the regex is a\n         * (1) one-char String and this character is not one of the\n         *     RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         * (2) two-char String and the first char is the backslash and\n         *     the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n             \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n             (regex.length() \u003d\u003d 2 \u0026\u0026\n              regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n              (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n              ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n              ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n            (ch \u003c Character.MIN_HIGH_SURROGATE ||\n             ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            int off \u003d 0;\n            int next \u003d 0;\n            boolean limited \u003d limit \u003e 0;\n            ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n            while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n                if (!limited || list.size() \u003c limit - 1) {\n                    list.add(substring(off, next));\n                    off \u003d next + 1;\n                } else {    // last one\n                    //assert (list.size() \u003d\u003d limit - 1);\n                    int last \u003d length();\n                    list.add(substring(off, last));\n                    off \u003d last;\n                    break;\n                }\n            }\n            // If no match was found, return this\n            if (off \u003d\u003d 0)\n                return new String[]{this};\n\n            // Add remaining segment\n            if (!limited || list.size() \u003c limit)\n                list.add(substring(off, length()));\n\n            // Construct result\n            int resultSize \u003d list.size();\n            if (limit \u003d\u003d 0) {\n                while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                    resultSize--;\n                }\n            }\n            String[] result \u003d new String[resultSize];\n            return list.subList(0, resultSize).toArray(result);\n        }\n        return Pattern.compile(regex).split(this, limit);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex) {\n        return split(regex, 0);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[elements.length];\n        for (int i \u003d 0; i \u003c elements.length; i++) {\n            elems[i] \u003d String.valueOf(elements[i]);\n        }\n        return join(\"\", \"\", delim, elems, elems.length);\n    }\n\n    /**\n     * Designated join routine.\n     *\n     * @param prefix the non-null prefix\n     * @param suffix the non-null suffix\n     * @param delimiter the non-null delimiter\n     * @param elements the non-null array of non-null elements\n     * @param size the number of elements in the array (\u003c\u003d elements.length)\n     * @return the joined string\n     */\n    @ForceInline\n    static String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n        int icoder \u003d prefix.coder() | suffix.coder();\n        long len \u003d (long) prefix.length() + suffix.length();\n        if (size \u003e 1) { // when there are more than one element, size - 1 delimiters will be emitted\n            len +\u003d (long) (size - 1) * delimiter.length();\n            icoder |\u003d delimiter.coder();\n        }\n        // assert len \u003e 0L; // max: (long) Integer.MAX_VALUE \u003c\u003c 32\n        // following loop will add max: (long) Integer.MAX_VALUE * Integer.MAX_VALUE to len\n        // so len can overflow at most once\n        for (int i \u003d 0; i \u003c size; i++) {\n            var el \u003d elements[i];\n            len +\u003d el.length();\n            icoder |\u003d el.coder();\n        }\n        byte coder \u003d (byte) icoder;\n        // long len overflow check, char -\u003e byte length, int len overflow check\n        if (len \u003c 0L || (len \u003c\u003c\u003d coder) !\u003d (int) len) {\n            throw new OutOfMemoryError(\"Requested string length exceeds VM limit\");\n        }\n        byte[] value \u003d StringConcatHelper.newArray(len);\n\n        int off \u003d 0;\n        prefix.getBytes(value, off, coder); off +\u003d prefix.length();\n        if (size \u003e 0) {\n            var el \u003d elements[0];\n            el.getBytes(value, off, coder); off +\u003d el.length();\n            for (int i \u003d 1; i \u003c size; i++) {\n                delimiter.getBytes(value, off, coder); off +\u003d delimiter.length();\n                el \u003d elements[i];\n                el.getBytes(value, off, coder); off +\u003d el.length();\n            }\n        }\n        suffix.getBytes(value, off, coder);\n        // assert off + suffix.length() \u003d\u003d value.length \u003e\u003e coder;\n\n        return new String(value, coder);\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     // message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     // message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[8];\n        int size \u003d 0;\n        for (CharSequence cs: elements) {\n            if (size \u003e\u003d elems.length) {\n                elems \u003d Arrays.copyOf(elems, elems.length \u003c\u003c 1);\n            }\n            elems[size++] \u003d String.valueOf(cs);\n        }\n        return join(\"\", \"\", delim, elems, size);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of lowercase mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toLowerCase(Locale.getDefault())}.\n     * \u003cp\u003e\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     * \u003cp\u003e\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@linkplain Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);\n    }\n\n    /**\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * \u003cp\u003e\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * \u003cp\u003e\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * \u003cp\u003e\n     * If {@code n \u003c 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * \u003cp\u003e\n     * If {@code n \u003d\u003d 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     */\n    public String indent(int n) {\n        if (isEmpty()) {\n            return \"\";\n        }\n        Stream\u003cString\u003e stream \u003d lines();\n        if (n \u003e 0) {\n            final String spaces \u003d \" \".repeat(n);\n            stream \u003d stream.map(s -\u003e spaces + s);\n        } else if (n \u003d\u003d Integer.MIN_VALUE) {\n            stream \u003d stream.map(s -\u003e s.stripLeading());\n        } else if (n \u003c 0) {\n            stream \u003d stream.map(s -\u003e s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n        }\n        return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n    }\n\n    private int indexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)\n                          : StringUTF16.indexOfNonWhitespace(value);\n    }\n\n    private int lastIndexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)\n                          : StringUTF16.lastIndexOfNonWhitespace(value);\n    }\n\n    /**\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * \u003cp\u003e\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * String html \u003d \"\"\"\n     * ..............\u0026lt;html\u0026gt;\n     * ..............    \u0026lt;body\u0026gt;\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * ..............    \u0026lt;/body\u0026gt;\n     * ..............\u0026lt;/html\u0026gt;\n     * ..............\"\"\";\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * |\u0026lt;html\u0026gt;\n     * |    \u0026lt;body\u0026gt;\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * |    \u0026lt;/body\u0026gt;\n     * |\u0026lt;/html\u0026gt;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * \u003cp\u003e\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\n     * \u003cul\u003e\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.\u003c/p\u003e\n     *   \u003c/li\u003e\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\n     *   \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\n     * \u003cp\u003e\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * \u003cp\u003e\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method\u0027s primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     */\n    public String stripIndent() {\n        int length \u003d length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        char lastChar \u003d charAt(length - 1);\n        boolean optOut \u003d lastChar \u003d\u003d \u0027\\n\u0027 || lastChar \u003d\u003d \u0027\\r\u0027;\n        List\u003cString\u003e lines \u003d lines().toList();\n        final int outdent \u003d optOut ? 0 : outdent(lines);\n        return lines.stream()\n            .map(line -\u003e {\n                int firstNonWhitespace \u003d line.indexOfNonWhitespace();\n                int lastNonWhitespace \u003d line.lastIndexOfNonWhitespace();\n                int incidentalWhitespace \u003d Math.min(outdent, firstNonWhitespace);\n                return firstNonWhitespace \u003e lastNonWhitespace\n                    ? \"\" : line.substring(incidentalWhitespace, lastNonWhitespace);\n            })\n            .collect(Collectors.joining(\"\\n\", \"\", optOut ? \"\\n\" : \"\"));\n    }\n\n    private static int outdent(List\u003cString\u003e lines) {\n        // Note: outdent is guaranteed to be zero or positive number.\n        // If there isn\u0027t a non-blank line then the last must be blank\n        int outdent \u003d Integer.MAX_VALUE;\n        for (String line : lines) {\n            int leadingWhitespace \u003d line.indexOfNonWhitespace();\n            if (leadingWhitespace !\u003d line.length()) {\n                outdent \u003d Integer.min(outdent, leadingWhitespace);\n            }\n        }\n        String lastLine \u003d lines.get(lines.size() - 1);\n        if (lastLine.isBlank()) {\n            outdent \u003d Integer.min(outdent, lastLine.length());\n        }\n        return outdent;\n    }\n\n    /**\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * \u003cp\u003e\n     * Escape sequences are translated as follows;\n     * \u003ctable class\u003d\"striped\"\u003e\n     *   \u003ccaption style\u003d\"display:none\"\u003eTranslation\u003c/caption\u003e\n     *   \u003cthead\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eEscape\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eName\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eTranslation\u003c/th\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/thead\u003e\n     *   \u003ctbody\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cb}\u003c/th\u003e\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Ct}\u003c/th\u003e\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cn}\u003c/th\u003e\n     *     \u003ctd\u003eline feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cf}\u003c/th\u003e\n     *     \u003ctd\u003eform feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cr}\u003c/th\u003e\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cs}\u003c/th\u003e\n     *     \u003ctd\u003espace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\"}\u003c/th\u003e\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u0027}\u003c/th\u003e\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\\u005C}\u003c/th\u003e\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C0 - \\u005C377}\u003c/th\u003e\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u003cline-terminator\u003e}\u003c/th\u003e\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\n     *     \u003ctd\u003ediscard\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @implNote\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     */\n    public String translateEscapes() {\n        if (isEmpty()) {\n            return \"\";\n        }\n        char[] chars \u003d toCharArray();\n        int length \u003d chars.length;\n        int from \u003d 0;\n        int to \u003d 0;\n        while (from \u003c length) {\n            char ch \u003d chars[from++];\n            if (ch \u003d\u003d \u0027\\\\\u0027) {\n                ch \u003d from \u003c length ? chars[from++] : \u0027\\0\u0027;\n                switch (ch) {\n                case \u0027b\u0027:\n                    ch \u003d \u0027\\b\u0027;\n                    break;\n                case \u0027f\u0027:\n                    ch \u003d \u0027\\f\u0027;\n                    break;\n                case \u0027n\u0027:\n                    ch \u003d \u0027\\n\u0027;\n                    break;\n                case \u0027r\u0027:\n                    ch \u003d \u0027\\r\u0027;\n                    break;\n                case \u0027s\u0027:\n                    ch \u003d \u0027 \u0027;\n                    break;\n                case \u0027t\u0027:\n                    ch \u003d \u0027\\t\u0027;\n                    break;\n                case \u0027\\\u0027\u0027:\n                case \u0027\\\"\u0027:\n                case \u0027\\\\\u0027:\n                    // as is\n                    break;\n                case \u00270\u0027: case \u00271\u0027: case \u00272\u0027: case \u00273\u0027:\n                case \u00274\u0027: case \u00275\u0027: case \u00276\u0027: case \u00277\u0027:\n                    int limit \u003d Integer.min(from + (ch \u003c\u003d \u00273\u0027 ? 2 : 1), length);\n                    int code \u003d ch - \u00270\u0027;\n                    while (from \u003c limit) {\n                        ch \u003d chars[from];\n                        if (ch \u003c \u00270\u0027 || \u00277\u0027 \u003c ch) {\n                            break;\n                        }\n                        from++;\n                        code \u003d (code \u003c\u003c 3) | (ch - \u00270\u0027);\n                    }\n                    ch \u003d (char)code;\n                    break;\n                case \u0027\\n\u0027:\n                    continue;\n                case \u0027\\r\u0027:\n                    if (from \u003c length \u0026\u0026 chars[from] \u003d\u003d \u0027\\n\u0027) {\n                        from++;\n                    }\n                    continue;\n                default: {\n                    String msg \u003d String.format(\n                        \"Invalid escape sequence: \\\\%c \\\\\\\\u%04X\",\n                        ch, (int)ch);\n                    throw new IllegalArgumentException(msg);\n                }\n                }\n            }\n\n            chars[to++] \u003d ch;\n        }\n\n        return new String(chars, 0, to);\n    }\n\n    /**\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * \u003cp\u003e\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param \u003cR\u003e  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     */\n    public \u003cR\u003e R transform(Function\u003c? super String, ? extends R\u003e f) {\n        return f.apply(this);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a \u003ca\n     * href\u003d\"{@docRoot}/java.base/java/lang/Character.html#unicode\"\u003esurrogate code\n     * point\u003c/a\u003e is passed through uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     */\n    public String formatted(Object... args) {\n        return new Formatter().format(this, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section {@jls 3.10.5} of the\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        int copied \u003d len;\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            System.arraycopy(multiple, 0, multiple, copied, copied);\n        }\n        System.arraycopy(multiple, 0, multiple, copied, limit - copied);\n        return new String(multiple, coder);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte[] dst, int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param srcPos    the char index, not offset of byte[]\n     * @param dstBegin  the char index to start from\n     * @param coder     the coder of dst[]\n     * @param length    the amount of copied chars\n     */\n    void getBytes(byte[] dst, int srcPos, int dstBegin, byte coder, int length) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, srcPos \u003c\u003c coder, dst, dstBegin \u003c\u003c coder, length \u003c\u003c coder);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, srcPos, dst, dstBegin, length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            // only try to compress val if some characters were deleted.\n            if (COMPACT_STRINGS \u0026\u0026 asb.maybeLatin1) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        Preconditions.checkIndex(index, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        Preconditions.checkFromToIndex(offset, length, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static void checkBoundsOffCount(int offset, int count, int length) {\n        Preconditions.checkFromIndexSize(offset, count, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        Preconditions.checkFromToIndex(begin, end, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cString\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public String resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 2:59:22 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:59:22 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

2024.04.26 02:59:23 INFO  compiling root (1 scala source)
Apr. 26, 2024 2:59:23 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4982
Apr. 26, 2024 2:59:23 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 4983
Apr. 26, 2024 2:59:23 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2022, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.Preconditions;\nimport jdk.internal.vm.annotation.ForceInline;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.US_ASCII;\nimport sun.nio.cs.UTF_8;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2, 3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence,\n               Constable, ConstantDesc {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /**\n     * Cache if the hash has been calculated as actually being zero, enabling\n     * us to avoid recalculating this.\n     */\n    private boolean hashIsZero; // Default to false;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    @java.io.Serial\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @IntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n        this.hashIsZero \u003d original.hashIsZero;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char[] value) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char[] value, int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        this(bytes, offset, length, lookupCharset(charsetName));\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    @SuppressWarnings(\"removal\")\n    public String(byte[] bytes, int offset, int length, Charset charset) {\n        Objects.requireNonNull(charset);\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n        } else if (charset \u003d\u003d UTF_8.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                int dp \u003d StringCoding.countPositives(bytes, offset, length);\n                if (dp \u003d\u003d length) {\n                    this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                int sl \u003d offset + length;\n                byte[] dst \u003d new byte[length];\n                if (dp \u003e 0) {\n                    System.arraycopy(bytes, offset, dst, 0, dp);\n                    offset +\u003d dp;\n                }\n                while (offset \u003c sl) {\n                    int b1 \u003d bytes[offset++];\n                    if (b1 \u003e\u003d 0) {\n                        dst[dp++] \u003d (byte)b1;\n                        continue;\n                    }\n                    if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                        int b2 \u003d bytes[offset];\n                        if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                            dst[dp++] \u003d (byte)decode2(b1, b2);\n                            offset++;\n                            continue;\n                        }\n                    }\n                    // anything not a latin1, including the REPL\n                    // we have to go with the utf16\n                    offset--;\n                    break;\n                }\n                if (offset \u003d\u003d sl) {\n                    if (dp !\u003d dst.length) {\n                        dst \u003d Arrays.copyOf(dst, dp);\n                    }\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n                dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            } else { // !COMPACT_STRINGS\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d US_ASCII.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d 0;\n                while (dp \u003c length) {\n                    int b \u003d bytes[offset++];\n                    StringUTF16.putChar(dst, dp++, (b \u003e\u003d 0) ? (char) b : REPL);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else {\n            // (1)We never cache the \"external\" cs, the only benefit of creating\n            // an additional StringDe/Encoder object to wrap it is to share the\n            // de/encode() method. These SD/E objects are short-lived, the young-gen\n            // gc should be able to take care of them well. But the best approach\n            // is still not to generate them if not really necessary.\n            // (2)The defensive copy of the input byte/char[] has a big performance\n            // impact, as well as the outgoing result byte/char[]. Need to do the\n            // optimization check of (sm\u003d\u003dnull \u0026\u0026 classLoader0\u003d\u003dnull) for both.\n            CharsetDecoder cd \u003d charset.newDecoder();\n            // ArrayDecoder fastpaths\n            if (cd instanceof ArrayDecoder ad) {\n                // ascii\n                if (ad.isASCIICompatible() \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                    if (COMPACT_STRINGS) {\n                        this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                    this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                    this.coder \u003d UTF16;\n                    return;\n                }\n\n                // fastpath for always Latin1 decodable single byte\n                if (COMPACT_STRINGS \u0026\u0026 ad.isLatin1Decodable()) {\n                    byte[] dst \u003d new byte[length];\n                    ad.decodeToLatin1(bytes, offset, length, dst);\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n\n                int en \u003d scale(length, cd.maxCharsPerByte());\n                cd.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                char[] ca \u003d new char[en];\n                int clen \u003d ad.decode(bytes, offset, length, ca);\n                if (COMPACT_STRINGS) {\n                    byte[] bs \u003d StringUTF16.compress(ca, 0, clen);\n                    if (bs !\u003d null) {\n                        value \u003d bs;\n                        coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                coder \u003d UTF16;\n                value \u003d StringUTF16.toBytes(ca, 0, clen);\n                return;\n            }\n\n            // decode using CharsetDecoder\n            int en \u003d scale(length, cd.maxCharsPerByte());\n            cd.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            char[] ca \u003d new char[en];\n            if (charset.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                    System.getSecurityManager() !\u003d null) {\n                bytes \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                offset \u003d 0;\n            }\n\n            int caLen;\n            try {\n                caLen \u003d decodeWithDecoder(cd, ca, bytes, offset, length);\n            } catch (CharacterCodingException x) {\n                // Substitution is enabled, so this shouldn\u0027t happen\n                throw new Error(x);\n            }\n            if (COMPACT_STRINGS) {\n                byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n                if (bs !\u003d null) {\n                    value \u003d bs;\n                    coder \u003d LATIN1;\n                    return;\n                }\n            }\n            coder \u003d UTF16;\n            value \u003d StringUTF16.toBytes(ca, 0, caLen);\n        }\n    }\n\n    /*\n     * Throws iae, instead of replacing, if malformed or unmappable.\n     */\n    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        int dp;\n        byte[] dst;\n        if (COMPACT_STRINGS) {\n            dp \u003d StringCoding.countPositives(bytes, offset, length);\n            int sl \u003d offset + length;\n            if (dp \u003d\u003d length) {\n                return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n            }\n            dst \u003d new byte[length];\n            System.arraycopy(bytes, offset, dst, 0, dp);\n            offset +\u003d dp;\n            while (offset \u003c sl) {\n                int b1 \u003d bytes[offset++];\n                if (b1 \u003e\u003d 0) {\n                    dst[dp++] \u003d (byte)b1;\n                    continue;\n                }\n                if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                    int b2 \u003d bytes[offset];\n                    if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                        dst[dp++] \u003d (byte)decode2(b1, b2);\n                        offset++;\n                        continue;\n                    }\n                }\n                // anything not a latin1, including the REPL\n                // we have to go with the utf16\n                offset--;\n                break;\n            }\n            if (offset \u003d\u003d sl) {\n                if (dp !\u003d dst.length) {\n                    dst \u003d Arrays.copyOf(dst, dp);\n                }\n                return new String(dst, LATIN1);\n            }\n            if (dp \u003d\u003d 0) {\n                dst \u003d new byte[length \u003c\u003c 1];\n            } else {\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n            }\n            dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n        } else { // !COMPACT_STRINGS\n            dst \u003d new byte[length \u003c\u003c 1];\n            dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n        }\n        if (dp !\u003d length) {\n            dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n        }\n        return new String(dst, UTF16);\n    }\n\n    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n        try {\n            return newStringNoRepl1(src, cs);\n        } catch (IllegalArgumentException e) {\n            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof MalformedInputException mie) {\n                throw mie;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static String newStringNoRepl1(byte[] src, Charset cs) {\n        int len \u003d src.length;\n        if (len \u003d\u003d 0) {\n            return \"\";\n        }\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return newStringUTF8NoRepl(src, 0, src.length);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n                if (COMPACT_STRINGS)\n                    return new String(src, LATIN1);\n                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n            } else {\n                throwMalformed(src);\n            }\n        }\n\n        CharsetDecoder cd \u003d cs.newDecoder();\n        // ascii fastpath\n        if (cd instanceof ArrayDecoder ad \u0026\u0026\n                ad.isASCIICompatible() \u0026\u0026\n                !StringCoding.hasNegatives(src, 0, src.length)) {\n            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n        }\n        int en \u003d scale(len, cd.maxCharsPerByte());\n        char[] ca \u003d new char[en];\n        if (cs.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                System.getSecurityManager() !\u003d null) {\n            src \u003d Arrays.copyOf(src, len);\n        }\n        int caLen;\n        try {\n            caLen \u003d decodeWithDecoder(cd, ca, src, 0, src.length);\n        } catch (CharacterCodingException x) {\n            // throw via IAE\n            throw new IllegalArgumentException(x);\n        }\n        if (COMPACT_STRINGS) {\n            byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n            if (bs !\u003d null) {\n                return new String(bs, LATIN1);\n            }\n        }\n        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n    }\n\n    private static final char REPL \u003d \u0027\\ufffd\u0027;\n\n    // Trim the given byte array to the given length\n    @SuppressWarnings(\"removal\")\n    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n        if (len \u003d\u003d ba.length \u0026\u0026 (isTrusted || System.getSecurityManager() \u003d\u003d null)) {\n            return ba;\n        } else {\n            return Arrays.copyOf(ba, len);\n        }\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n        Objects.requireNonNull(csn);\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n            throw new UnsupportedEncodingException(csn);\n        }\n    }\n\n    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return encodeUTF8(coder, val, true);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            return encode8859_1(coder, val);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            return encodeASCII(coder, val);\n        }\n        return encodeWithEncoder(cs, coder, val, true);\n    }\n\n    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n        CharsetEncoder ce \u003d cs.newEncoder();\n        int len \u003d val.length \u003e\u003e coder;  // assume LATIN1\u003d0/UTF16\u003d1;\n        int en \u003d scale(len, ce.maxBytesPerChar());\n        // fastpath with ArrayEncoder implies `doReplace`.\n        if (doReplace \u0026\u0026 ce instanceof ArrayEncoder ae) {\n            // fastpath for ascii compatible\n            if (coder \u003d\u003d LATIN1 \u0026\u0026\n                    ae.isASCIICompatible() \u0026\u0026\n                    !StringCoding.hasNegatives(val, 0, val.length)) {\n                return Arrays.copyOf(val, val.length);\n            }\n            byte[] ba \u003d new byte[en];\n            if (len \u003d\u003d 0) {\n                return ba;\n            }\n\n            int blen \u003d (coder \u003d\u003d LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n                    : ae.encodeFromUTF16(val, 0, len, ba);\n            if (blen !\u003d -1) {\n                return safeTrim(ba, blen, true);\n            }\n        }\n\n        byte[] ba \u003d new byte[en];\n        if (len \u003d\u003d 0) {\n            return ba;\n        }\n        if (doReplace) {\n            ce.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        char[] ca \u003d (coder \u003d\u003d LATIN1 ) ? StringLatin1.toChars(val)\n                : StringUTF16.toChars(val);\n        ByteBuffer bb \u003d ByteBuffer.wrap(ba);\n        CharBuffer cb \u003d CharBuffer.wrap(ca, 0, len);\n        try {\n            CoderResult cr \u003d ce.encode(cb, bb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d ce.flush(bb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            if (!doReplace) {\n                throw new IllegalArgumentException(x);\n            } else {\n                throw new Error(x);\n            }\n        }\n        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() \u003d\u003d null);\n    }\n\n    /*\n     * Throws iae, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesUTF8NoRepl(String s) {\n        return encodeUTF8(s.coder(), s.value(), false);\n    }\n\n    private static boolean isASCII(byte[] src) {\n        return !StringCoding.hasNegatives(src, 0, src.length);\n    }\n\n    /*\n     * Throws CCE, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n        try {\n            return getBytesNoRepl1(s, cs);\n        } catch (IllegalArgumentException e) {\n            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof UnmappableCharacterException) {\n                throw (UnmappableCharacterException)cause;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n        byte[] val \u003d s.value();\n        byte coder \u003d s.coder();\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            if (coder \u003d\u003d LATIN1 \u0026\u0026 isASCII(val)) {\n                return val;\n            }\n            return encodeUTF8(coder, val, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                return val;\n            }\n            return encode8859_1(coder, val, false);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                if (isASCII(val)) {\n                    return val;\n                } else {\n                    throwUnmappable(val);\n                }\n            }\n        }\n        return encodeWithEncoder(cs, coder, val, false);\n    }\n\n    private static byte[] encodeASCII(byte coder, byte[] val) {\n        if (coder \u003d\u003d LATIN1) {\n            byte[] dst \u003d Arrays.copyOf(val, val.length);\n            for (int i \u003d 0; i \u003c dst.length; i++) {\n                if (dst[i] \u003c 0) {\n                    dst[i] \u003d \u0027?\u0027;\n                }\n            }\n            return dst;\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        for (int i \u003d 0; i \u003c len; i++) {\n            char c \u003d StringUTF16.getChar(val, i);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n                continue;\n            }\n            if (Character.isHighSurrogate(c) \u0026\u0026 i + 1 \u003c len \u0026\u0026\n                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n                i++;\n            }\n            dst[dp++] \u003d \u0027?\u0027;\n        }\n        if (len \u003d\u003d dp) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val) {\n        return encode8859_1(coder, val, true);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d LATIN1) {\n            return Arrays.copyOf(val, val.length);\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d len;\n        while (sp \u003c sl) {\n            int ret \u003d StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n            sp \u003d sp + ret;\n            dp \u003d dp + ret;\n            if (ret !\u003d len) {\n                if (!doReplace) {\n                    throwUnmappable(sp);\n                }\n                char c \u003d StringUTF16.getChar(val, sp++);\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n                    sp++;\n                }\n                dst[dp++] \u003d \u0027?\u0027;\n                len \u003d sl - sp;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    //////////////////////////////// utf8 ////////////////////////////////////\n\n    /**\n     * Decodes ASCII from the source byte array into the destination\n     * char array. Used via JavaLangAccess from UTF_8 and other charset\n     * decoders.\n     *\n     * @return the number of bytes successfully decoded, at most len\n     */\n    /* package-private */\n    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n        int count \u003d StringCoding.countPositives(sa, sp, len);\n        while (count \u003c len) {\n            if (sa[sp + count] \u003c 0) {\n                break;\n            }\n            count++;\n        }\n        StringLatin1.inflate(sa, sp, da, dp, count);\n        return count;\n    }\n\n    private static boolean isNotContinuation(int b) {\n        return (b \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3(int b1, int b2, int b3) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3_2(int b1, int b2) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4(int b2, int b3, int b4) {\n        return (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80 ||\n                (b4 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_2(int b1, int b2) {\n        return (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_3(int b3) {\n        return (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static char decode2(int b1, int b2) {\n        return (char)(((b1 \u003c\u003c 6) ^ b2) ^\n                (((byte) 0xC0 \u003c\u003c 6) ^\n                        ((byte) 0x80 \u003c\u003c 0)));\n    }\n\n    private static char decode3(int b1, int b2, int b3) {\n        return (char)((b1 \u003c\u003c 12) ^\n                (b2 \u003c\u003c  6) ^\n                (b3 ^\n                        (((byte) 0xE0 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decode4(int b1, int b2, int b3, int b4) {\n        return ((b1 \u003c\u003c 18) ^\n                (b2 \u003c\u003c 12) ^\n                (b3 \u003c\u003c  6) ^\n                (b4 ^\n                        (((byte) 0xF0 \u003c\u003c 18) ^\n                                ((byte) 0x80 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n        while (sp \u003c sl) {\n            int b1 \u003d src[sp++];\n            if (b1 \u003e\u003d 0) {\n                StringUTF16.putChar(dst, dp++, (char) b1);\n            } else if ((b1 \u003e\u003e 5) \u003d\u003d -2 \u0026\u0026 (b1 \u0026 0x1e) !\u003d 0) {\n                if (sp \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    if (isNotContinuation(b2)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 1, 1);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp--;\n                    } else {\n                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n                    }\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);  // underflow()\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 4) \u003d\u003d -2) {\n                if (sp + 1 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    if (isMalformed3(b1, b2, b3)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 3, 3);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 3;\n                        sp +\u003d malformed3(src, sp);\n                    } else {\n                        char c \u003d decode3(b1, b2, b3);\n                        if (Character.isSurrogate(c)) {\n                            if (!doReplace) {\n                                throwMalformed(sp - 3, 3);\n                            }\n                            StringUTF16.putChar(dst, dp++, REPL);\n                        } else {\n                            StringUTF16.putChar(dst, dp++, c);\n                        }\n                    }\n                    continue;\n                }\n                if (sp \u003c sl \u0026\u0026 isMalformed3_2(b1, src[sp])) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 2);\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 3) \u003d\u003d -2) {\n                if (sp + 2 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    int b4 \u003d src[sp++];\n                    int uc \u003d decode4(b1, b2, b3, b4);\n                    if (isMalformed4(b2, b3, b4) ||\n                            !Character.isSupplementaryCodePoint(uc)) { // shortest form check\n                        if (!doReplace) {\n                            throwMalformed(sp - 4, 4);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 4;\n                        sp +\u003d malformed4(src, sp);\n                    } else {\n                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n                    }\n                    continue;\n                }\n                b1 \u0026\u003d 0xff;\n                if (b1 \u003e 0xf4 || sp \u003c sl \u0026\u0026 isMalformed4_2(b1, src[sp] \u0026 0xff)) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 1);  // or 2\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                sp++;\n                StringUTF16.putChar(dst, dp++, REPL);\n                if (sp \u003c sl \u0026\u0026 isMalformed4_3(src[sp])) {\n                    continue;\n                }\n                break;\n            } else {\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n            }\n        }\n        return dp;\n    }\n\n    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n                                            throws CharacterCodingException {\n        ByteBuffer bb \u003d ByteBuffer.wrap(src, offset, length);\n        CharBuffer cb \u003d CharBuffer.wrap(dst, 0, dst.length);\n        CoderResult cr \u003d cd.decode(bb, cb, true);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        cr \u003d cd.flush(cb);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        return cb.position();\n    }\n\n    private static int malformed3(byte[] src, int sp) {\n        int b1 \u003d src[sp++];\n        int b2 \u003d src[sp];    // no need to lookup b3\n        return ((b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                isNotContinuation(b2)) ? 1 : 2;\n    }\n\n    private static int malformed4(byte[] src, int sp) {\n        // we don\u0027t care the speed here\n        int b1 \u003d src[sp++] \u0026 0xff;\n        int b2 \u003d src[sp++] \u0026 0xff;\n        if (b1 \u003e 0xf4 ||\n                (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                isNotContinuation(b2))\n            return 1;\n        if (isNotContinuation(src[sp]))\n            return 2;\n        return 3;\n    }\n\n    private static void throwMalformed(int off, int nb) {\n        String msg \u003d \"malformed input off : \" + off + \", length : \" + nb;\n        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n    }\n\n    private static void throwMalformed(byte[] val) {\n        int dp \u003d 0;\n        while (dp \u003c val.length \u0026\u0026 val[dp] \u003e\u003d0) { dp++; }\n        throwMalformed(dp, 1);\n    }\n\n    private static void throwUnmappable(int off) {\n        String msg \u003d \"malformed input off : \" + off + \", length : 1\";\n        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n    }\n\n    private static void throwUnmappable(byte[] val) {\n        int dp \u003d 0;\n        while (dp \u003c val.length \u0026\u0026 val[dp] \u003e\u003d0) { dp++; }\n        throwUnmappable(dp);\n    }\n\n    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d UTF16)\n            return encodeUTF8_UTF16(val, doReplace);\n\n        if (!StringCoding.hasNegatives(val, 0, val.length))\n            return Arrays.copyOf(val, val.length);\n\n        int dp \u003d 0;\n        byte[] dst \u003d new byte[val.length \u003c\u003c 1];\n        for (byte c : val) {\n            if (c \u003c 0) {\n                dst[dp++] \u003d (byte) (0xc0 | ((c \u0026 0xff) \u003e\u003e 6));\n                dst[dp++] \u003d (byte) (0x80 | (c \u0026 0x3f));\n            } else {\n                dst[dp++] \u003d c;\n            }\n        }\n        if (dp \u003d\u003d dst.length)\n            return dst;\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[sl * 3];\n        while (sp \u003c sl) {\n            // ascii fast loop;\n            char c \u003d StringUTF16.getChar(val, sp);\n            if (c \u003e\u003d \u0027\\u0080\u0027) {\n                break;\n            }\n            dst[dp++] \u003d (byte)c;\n            sp++;\n        }\n        while (sp \u003c sl) {\n            char c \u003d StringUTF16.getChar(val, sp++);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n            } else if (c \u003c 0x800) {\n                dst[dp++] \u003d (byte)(0xc0 | (c \u003e\u003e 6));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            } else if (Character.isSurrogate(c)) {\n                int uc \u003d -1;\n                char c2;\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(c2 \u003d StringUTF16.getChar(val, sp))) {\n                    uc \u003d Character.toCodePoint(c, c2);\n                }\n                if (uc \u003c 0) {\n                    if (doReplace) {\n                        dst[dp++] \u003d \u0027?\u0027;\n                    } else {\n                        throwUnmappable(sp - 1);\n                    }\n                } else {\n                    dst[dp++] \u003d (byte)(0xf0 | ((uc \u003e\u003e 18)));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e 12) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e  6) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | (uc \u0026 0x3f));\n                    sp++;  // 2 chars\n                }\n            } else {\n                // 3 bytes, 16 bits\n                dst[dp++] \u003d (byte)(0xe0 | ((c \u003e\u003e 12)));\n                dst[dp++] \u003d (byte)(0x80 | ((c \u003e\u003e  6) \u0026 0x3f));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, String charsetName)\n            throws UnsupportedEncodingException {\n        this(bytes, 0, bytes.length, charsetName);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, Charset charset) {\n        this(bytes, 0, bytes.length, charset);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the {@link Charset#defaultCharset() default charset}.\n     * The length of the new {@code String} is a function of the charset,\n     * and hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length) {\n        this(bytes, offset, length, Charset.defaultCharset());\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the {@link Charset#defaultCharset() default charset}. The length\n     * of the new {@code String} is a function of the charset, and hence may not\n     * be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    @Override\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        checkIndex(i, length());\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        Objects.checkFromToIndex(beginIndex, endIndex, length());\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger then the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        if (index \u003c 0 || index \u003e length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @throws    IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the {@link Charset#defaultCharset()\n     * default charset}.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        return encode(lookupCharset(charsetName), coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * {@link Charset#defaultCharset() default charset}, storing the result\n     * into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return encode(Charset.defaultCharset(), coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        return (anObject instanceof String aString)\n                \u0026\u0026 (!COMPACT_STRINGS || this.coder \u003d\u003d aString.coder)\n                \u0026\u0026 StringLatin1.equals(value, aString.value);\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte v1[] \u003d value;\n        byte v2[] \u003d sb.getValue();\n        byte coder \u003d coder();\n        if (coder \u003d\u003d sb.getCoder()) {\n            int n \u003d v1.length;\n            for (int i \u003d 0; i \u003c n; i++) {\n                if (v1[i] !\u003d v2[i]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder !\u003d LATIN1) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n        return true;\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding Unicode code points in the two\n     * strings are equal ignoring case.\n     *\n     * \u003cp\u003e Two Unicode code points are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two Unicode code points are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(int))}\n     *        on each Unicode code point produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     * @see  #codePoints()\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte v1[] \u003d value;\n        byte v2[] \u003d anotherString.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d anotherString.coder()) {\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareTo(v1, v2)\n                                   : StringUTF16.compareTo(v1, v2);\n        }\n        return coder \u003d\u003d LATIN1 ? StringLatin1.compareToUTF16(v1, v2)\n                               : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@link #compareToIgnoreCase(String) compareToIgnoreCase}.\n     * This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n\n    /**\n     * CaseInsensitiveComparator for Strings.\n     */\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        @java.io.Serial\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte v1[] \u003d s1.value;\n            byte v2[] \u003d s2.value;\n            byte coder \u003d s1.coder();\n            if (coder \u003d\u003d s2.coder()) {\n                return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI(v1, v2)\n                                       : StringUTF16.compareToCI(v1, v2);\n            }\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                   : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        @java.io.Serial\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with case folded versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(int))} on\n     * each Unicode code point.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @see     #codePoints()\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        byte tv[] \u003d value;\n        byte ov[] \u003d other.value;\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            if (!isLatin1() \u0026\u0026 (len \u003e 0)) {\n                toffset \u003d toffset \u003c\u003c 1;\n                ooffset \u003d ooffset \u003c\u003c 1;\n                len \u003d len \u003c\u003c 1;\n            }\n            while (len-- \u003e 0) {\n                if (tv[toffset++] !\u003d ov[ooffset++]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent Unicode code point sequences that are the same,\n     * ignoring case if and only if {@code ignoreCase} is true.\n     * The sequences {@code tsequence} and {@code osequence} are compared,\n     * where {@code tsequence} is the sequence produced as if by calling\n     * {@code this.substring(toffset, toffset + len).codePoints()} and\n     * {@code osequence} is the sequence produced as if by calling\n     * {@code other.substring(ooffset, ooffset + len).codePoints()}.\n     * The result is {@code true} if and only if all of the following\n     * are true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is non-negative.\n     * \u003cli\u003e{@code ooffset} is non-negative.\n     * \u003cli\u003e{@code toffset+len} is less than or equal to the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is less than or equal to the length of the other\n     * argument.\n     * \u003cli\u003eif {@code ignoreCase} is {@code false}, all pairs of corresponding Unicode\n     * code points are equal integer values; or if {@code ignoreCase} is {@code true},\n     * {@link Character#toLowerCase(int) Character.toLowerCase(}\n     * {@link Character#toUpperCase(int)}{@code )} on all pairs of Unicode code points\n     * results in equal integer values.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters (Unicode code units -\n     *                       16bit {@code char} value) to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     * @see     #codePoints()\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte tv[] \u003d value;\n        byte ov[] \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte ta[] \u003d value;\n        byte pa[] \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d prefix.coder()) {\n            int to \u003d (coder \u003d\u003d LATIN1) ? toffset : toffset \u003c\u003c 1;\n            while (po \u003c pc) {\n                if (ta[to++] !\u003d pa[po++]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder \u003d\u003d LATIN1) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        // The hash or hashIsZero fields are subject to a benign data race,\n        // making it crucial to ensure that any observable result of the\n        // calculation in this method stays correct under any possible read of\n        // these fields. Necessary restrictions to allow this to be correct\n        // without explicit memory fences or similar concurrency primitives is\n        // that we can ever only write to one of these two fields for a given\n        // String instance, and that the computation is idempotent and derived\n        // from immutable state\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 !hashIsZero) {\n            h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                           : StringUTF16.hashCode(value);\n            if (h \u003d\u003d 0) {\n                hashIsZero \u003d true;\n            } else {\n                hash \u003d h;\n            }\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex)\n                          : StringUTF16.indexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        byte coder \u003d coder();\n        if (coder \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  length of the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        byte[] tgt    \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount  \u003d tgtStr.length();\n\n        if (fromIndex \u003e\u003d srcCount) {\n            return (tgtCount \u003d\u003d 0 ? srcCount : -1);\n        }\n        if (fromIndex \u003c 0) {\n            fromIndex \u003d 0;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (tgtCount \u003e srcCount) {\n            return -1;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        return substring(beginIndex, length());\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        int subLen \u003d endIndex - beginIndex;\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        return StringConcatHelper.simpleConcat(this, str);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll(String) replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String trgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int thisLen \u003d length();\n        int trgtLen \u003d trgtStr.length();\n        int replLen \u003d replStr.length();\n\n        if (trgtLen \u003e 0) {\n            if (trgtLen \u003d\u003d 1 \u0026\u0026 replLen \u003d\u003d 1) {\n                return replace(trgtStr.charAt(0), replStr.charAt(0));\n            }\n\n            boolean thisIsLatin1 \u003d this.isLatin1();\n            boolean trgtIsLatin1 \u003d trgtStr.isLatin1();\n            boolean replIsLatin1 \u003d replStr.isLatin1();\n            String ret \u003d (thisIsLatin1 \u0026\u0026 trgtIsLatin1 \u0026\u0026 replIsLatin1)\n                    ? StringLatin1.replace(value, thisLen,\n                                           trgtStr.value, trgtLen,\n                                           replStr.value, replLen)\n                    : StringUTF16.replace(value, thisLen, thisIsLatin1,\n                                          trgtStr.value, trgtLen, trgtIsLatin1,\n                                          replStr.value, replLen, replIsLatin1);\n            if (ret !\u003d null) {\n                return ret;\n            }\n            return this;\n\n        } else { // trgtLen \u003d\u003d 0\n            int resultLen;\n            try {\n                resultLen \u003d Math.addExact(thisLen, Math.multiplyExact(\n                        Math.addExact(thisLen, 1), replLen));\n            } catch (ArithmeticException ignored) {\n                throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n            }\n\n            StringBuilder sb \u003d new StringBuilder(resultLen);\n            sb.append(replStr);\n            for (int i \u003d 0; i \u003c thisLen; ++i) {\n                sb.append(charAt(i)).append(replStr);\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex, int limit) {\n        /* fastpath if the regex is a\n         * (1) one-char String and this character is not one of the\n         *     RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         * (2) two-char String and the first char is the backslash and\n         *     the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n             \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n             (regex.length() \u003d\u003d 2 \u0026\u0026\n              regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n              (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n              ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n              ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n            (ch \u003c Character.MIN_HIGH_SURROGATE ||\n             ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            int off \u003d 0;\n            int next \u003d 0;\n            boolean limited \u003d limit \u003e 0;\n            ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n            while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n                if (!limited || list.size() \u003c limit - 1) {\n                    list.add(substring(off, next));\n                    off \u003d next + 1;\n                } else {    // last one\n                    //assert (list.size() \u003d\u003d limit - 1);\n                    int last \u003d length();\n                    list.add(substring(off, last));\n                    off \u003d last;\n                    break;\n                }\n            }\n            // If no match was found, return this\n            if (off \u003d\u003d 0)\n                return new String[]{this};\n\n            // Add remaining segment\n            if (!limited || list.size() \u003c limit)\n                list.add(substring(off, length()));\n\n            // Construct result\n            int resultSize \u003d list.size();\n            if (limit \u003d\u003d 0) {\n                while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                    resultSize--;\n                }\n            }\n            String[] result \u003d new String[resultSize];\n            return list.subList(0, resultSize).toArray(result);\n        }\n        return Pattern.compile(regex).split(this, limit);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex) {\n        return split(regex, 0);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[elements.length];\n        for (int i \u003d 0; i \u003c elements.length; i++) {\n            elems[i] \u003d String.valueOf(elements[i]);\n        }\n        return join(\"\", \"\", delim, elems, elems.length);\n    }\n\n    /**\n     * Designated join routine.\n     *\n     * @param prefix the non-null prefix\n     * @param suffix the non-null suffix\n     * @param delimiter the non-null delimiter\n     * @param elements the non-null array of non-null elements\n     * @param size the number of elements in the array (\u003c\u003d elements.length)\n     * @return the joined string\n     */\n    @ForceInline\n    static String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n        int icoder \u003d prefix.coder() | suffix.coder();\n        long len \u003d (long) prefix.length() + suffix.length();\n        if (size \u003e 1) { // when there are more than one element, size - 1 delimiters will be emitted\n            len +\u003d (long) (size - 1) * delimiter.length();\n            icoder |\u003d delimiter.coder();\n        }\n        // assert len \u003e 0L; // max: (long) Integer.MAX_VALUE \u003c\u003c 32\n        // following loop will add max: (long) Integer.MAX_VALUE * Integer.MAX_VALUE to len\n        // so len can overflow at most once\n        for (int i \u003d 0; i \u003c size; i++) {\n            var el \u003d elements[i];\n            len +\u003d el.length();\n            icoder |\u003d el.coder();\n        }\n        byte coder \u003d (byte) icoder;\n        // long len overflow check, char -\u003e byte length, int len overflow check\n        if (len \u003c 0L || (len \u003c\u003c\u003d coder) !\u003d (int) len) {\n            throw new OutOfMemoryError(\"Requested string length exceeds VM limit\");\n        }\n        byte[] value \u003d StringConcatHelper.newArray(len);\n\n        int off \u003d 0;\n        prefix.getBytes(value, off, coder); off +\u003d prefix.length();\n        if (size \u003e 0) {\n            var el \u003d elements[0];\n            el.getBytes(value, off, coder); off +\u003d el.length();\n            for (int i \u003d 1; i \u003c size; i++) {\n                delimiter.getBytes(value, off, coder); off +\u003d delimiter.length();\n                el \u003d elements[i];\n                el.getBytes(value, off, coder); off +\u003d el.length();\n            }\n        }\n        suffix.getBytes(value, off, coder);\n        // assert off + suffix.length() \u003d\u003d value.length \u003e\u003e coder;\n\n        return new String(value, coder);\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     // message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     // message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[8];\n        int size \u003d 0;\n        for (CharSequence cs: elements) {\n            if (size \u003e\u003d elems.length) {\n                elems \u003d Arrays.copyOf(elems, elems.length \u003c\u003c 1);\n            }\n            elems[size++] \u003d String.valueOf(cs);\n        }\n        return join(\"\", \"\", delim, elems, size);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of lowercase mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toLowerCase(Locale.getDefault())}.\n     * \u003cp\u003e\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     * \u003cp\u003e\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@linkplain Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);\n    }\n\n    /**\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * \u003cp\u003e\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * \u003cp\u003e\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * \u003cp\u003e\n     * If {@code n \u003c 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * \u003cp\u003e\n     * If {@code n \u003d\u003d 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     */\n    public String indent(int n) {\n        if (isEmpty()) {\n            return \"\";\n        }\n        Stream\u003cString\u003e stream \u003d lines();\n        if (n \u003e 0) {\n            final String spaces \u003d \" \".repeat(n);\n            stream \u003d stream.map(s -\u003e spaces + s);\n        } else if (n \u003d\u003d Integer.MIN_VALUE) {\n            stream \u003d stream.map(s -\u003e s.stripLeading());\n        } else if (n \u003c 0) {\n            stream \u003d stream.map(s -\u003e s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n        }\n        return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n    }\n\n    private int indexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)\n                          : StringUTF16.indexOfNonWhitespace(value);\n    }\n\n    private int lastIndexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)\n                          : StringUTF16.lastIndexOfNonWhitespace(value);\n    }\n\n    /**\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * \u003cp\u003e\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * String html \u003d \"\"\"\n     * ..............\u0026lt;html\u0026gt;\n     * ..............    \u0026lt;body\u0026gt;\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * ..............    \u0026lt;/body\u0026gt;\n     * ..............\u0026lt;/html\u0026gt;\n     * ..............\"\"\";\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * |\u0026lt;html\u0026gt;\n     * |    \u0026lt;body\u0026gt;\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * |    \u0026lt;/body\u0026gt;\n     * |\u0026lt;/html\u0026gt;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * \u003cp\u003e\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\n     * \u003cul\u003e\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.\u003c/p\u003e\n     *   \u003c/li\u003e\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\n     *   \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\n     * \u003cp\u003e\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * \u003cp\u003e\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method\u0027s primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     */\n    public String stripIndent() {\n        int length \u003d length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        char lastChar \u003d charAt(length - 1);\n        boolean optOut \u003d lastChar \u003d\u003d \u0027\\n\u0027 || lastChar \u003d\u003d \u0027\\r\u0027;\n        List\u003cString\u003e lines \u003d lines().toList();\n        final int outdent \u003d optOut ? 0 : outdent(lines);\n        return lines.stream()\n            .map(line -\u003e {\n                int firstNonWhitespace \u003d line.indexOfNonWhitespace();\n                int lastNonWhitespace \u003d line.lastIndexOfNonWhitespace();\n                int incidentalWhitespace \u003d Math.min(outdent, firstNonWhitespace);\n                return firstNonWhitespace \u003e lastNonWhitespace\n                    ? \"\" : line.substring(incidentalWhitespace, lastNonWhitespace);\n            })\n            .collect(Collectors.joining(\"\\n\", \"\", optOut ? \"\\n\" : \"\"));\n    }\n\n    private static int outdent(List\u003cString\u003e lines) {\n        // Note: outdent is guaranteed to be zero or positive number.\n        // If there isn\u0027t a non-blank line then the last must be blank\n        int outdent \u003d Integer.MAX_VALUE;\n        for (String line : lines) {\n            int leadingWhitespace \u003d line.indexOfNonWhitespace();\n            if (leadingWhitespace !\u003d line.length()) {\n                outdent \u003d Integer.min(outdent, leadingWhitespace);\n            }\n        }\n        String lastLine \u003d lines.get(lines.size() - 1);\n        if (lastLine.isBlank()) {\n            outdent \u003d Integer.min(outdent, lastLine.length());\n        }\n        return outdent;\n    }\n\n    /**\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * \u003cp\u003e\n     * Escape sequences are translated as follows;\n     * \u003ctable class\u003d\"striped\"\u003e\n     *   \u003ccaption style\u003d\"display:none\"\u003eTranslation\u003c/caption\u003e\n     *   \u003cthead\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eEscape\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eName\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eTranslation\u003c/th\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/thead\u003e\n     *   \u003ctbody\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cb}\u003c/th\u003e\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Ct}\u003c/th\u003e\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cn}\u003c/th\u003e\n     *     \u003ctd\u003eline feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cf}\u003c/th\u003e\n     *     \u003ctd\u003eform feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cr}\u003c/th\u003e\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cs}\u003c/th\u003e\n     *     \u003ctd\u003espace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\"}\u003c/th\u003e\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u0027}\u003c/th\u003e\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\\u005C}\u003c/th\u003e\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C0 - \\u005C377}\u003c/th\u003e\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u003cline-terminator\u003e}\u003c/th\u003e\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\n     *     \u003ctd\u003ediscard\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @implNote\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     */\n    public String translateEscapes() {\n        if (isEmpty()) {\n            return \"\";\n        }\n        char[] chars \u003d toCharArray();\n        int length \u003d chars.length;\n        int from \u003d 0;\n        int to \u003d 0;\n        while (from \u003c length) {\n            char ch \u003d chars[from++];\n            if (ch \u003d\u003d \u0027\\\\\u0027) {\n                ch \u003d from \u003c length ? chars[from++] : \u0027\\0\u0027;\n                switch (ch) {\n                case \u0027b\u0027:\n                    ch \u003d \u0027\\b\u0027;\n                    break;\n                case \u0027f\u0027:\n                    ch \u003d \u0027\\f\u0027;\n                    break;\n                case \u0027n\u0027:\n                    ch \u003d \u0027\\n\u0027;\n                    break;\n                case \u0027r\u0027:\n                    ch \u003d \u0027\\r\u0027;\n                    break;\n                case \u0027s\u0027:\n                    ch \u003d \u0027 \u0027;\n                    break;\n                case \u0027t\u0027:\n                    ch \u003d \u0027\\t\u0027;\n                    break;\n                case \u0027\\\u0027\u0027:\n                case \u0027\\\"\u0027:\n                case \u0027\\\\\u0027:\n                    // as is\n                    break;\n                case \u00270\u0027: case \u00271\u0027: case \u00272\u0027: case \u00273\u0027:\n                case \u00274\u0027: case \u00275\u0027: case \u00276\u0027: case \u00277\u0027:\n                    int limit \u003d Integer.min(from + (ch \u003c\u003d \u00273\u0027 ? 2 : 1), length);\n                    int code \u003d ch - \u00270\u0027;\n                    while (from \u003c limit) {\n                        ch \u003d chars[from];\n                        if (ch \u003c \u00270\u0027 || \u00277\u0027 \u003c ch) {\n                            break;\n                        }\n                        from++;\n                        code \u003d (code \u003c\u003c 3) | (ch - \u00270\u0027);\n                    }\n                    ch \u003d (char)code;\n                    break;\n                case \u0027\\n\u0027:\n                    continue;\n                case \u0027\\r\u0027:\n                    if (from \u003c length \u0026\u0026 chars[from] \u003d\u003d \u0027\\n\u0027) {\n                        from++;\n                    }\n                    continue;\n                default: {\n                    String msg \u003d String.format(\n                        \"Invalid escape sequence: \\\\%c \\\\\\\\u%04X\",\n                        ch, (int)ch);\n                    throw new IllegalArgumentException(msg);\n                }\n                }\n            }\n\n            chars[to++] \u003d ch;\n        }\n\n        return new String(chars, 0, to);\n    }\n\n    /**\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * \u003cp\u003e\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param \u003cR\u003e  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     */\n    public \u003cR\u003e R transform(Function\u003c? super String, ? extends R\u003e f) {\n        return f.apply(this);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a \u003ca\n     * href\u003d\"{@docRoot}/java.base/java/lang/Character.html#unicode\"\u003esurrogate code\n     * point\u003c/a\u003e is passed through uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     */\n    public String formatted(Object... args) {\n        return new Formatter().format(this, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section {@jls 3.10.5} of the\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        int copied \u003d len;\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            System.arraycopy(multiple, 0, multiple, copied, copied);\n        }\n        System.arraycopy(multiple, 0, multiple, copied, limit - copied);\n        return new String(multiple, coder);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte[] dst, int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param srcPos    the char index, not offset of byte[]\n     * @param dstBegin  the char index to start from\n     * @param coder     the coder of dst[]\n     * @param length    the amount of copied chars\n     */\n    void getBytes(byte[] dst, int srcPos, int dstBegin, byte coder, int length) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, srcPos \u003c\u003c coder, dst, dstBegin \u003c\u003c coder, length \u003c\u003c coder);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, srcPos, dst, dstBegin, length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            // only try to compress val if some characters were deleted.\n            if (COMPACT_STRINGS \u0026\u0026 asb.maybeLatin1) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        Preconditions.checkIndex(index, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        Preconditions.checkFromToIndex(offset, length, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static void checkBoundsOffCount(int offset, int count, int length) {\n        Preconditions.checkFromIndexSize(offset, count, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        Preconditions.checkFromToIndex(begin, end, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cString\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public String resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 02:59:23 INFO  time: compiled root in 0.28s
Apr. 26, 2024 2:59:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5065
Apr. 26, 2024 2:59:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5066
Apr. 26, 2024 2:59:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5068
Apr. 26, 2024 2:59:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 5081
2024.04.26 02:59:43 INFO  compiling root (1 scala source)
2024.04.26 02:59:43 INFO  compiling root (1 scala source)
2024.04.26 02:59:43 INFO  time: compiled root in 0.18s
2024.04.26 02:59:43 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.0' (since 39m 42.458s)
2024.04.26 02:59:43 INFO  compiling root (1 scala source)
2024.04.26 02:59:43 INFO  time: compiled root in 69ms
2024.04.26 03:00:28 INFO  compiling root (1 scala source)
2024.04.26 03:00:28 INFO  time: compiled root in 0.2s
Apr. 26, 2024 3:02:23 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:03:09 INFO  compiling root (1 scala source)
2024.04.26 03:03:09 INFO  time: compiled root in 0.17s
2024.04.26 03:04:03 INFO  compiling root (1 scala source)
2024.04.26 03:04:03 INFO  time: compiled root in 0.19s
2024.04.26 03:04:21 INFO  compiling root (1 scala source)
2024.04.26 03:04:21 INFO  time: compiled root in 0.17s
2024.04.26 03:05:33 INFO  compiling root-test (3 scala sources)
2024.04.26 03:05:33 INFO  time: compiled root-test in 0.22s
2024.04.26 03:05:33 INFO  compiling root-test (3 scala sources)
2024.04.26 03:05:33 INFO  time: compiled root-test in 0.19s
2024.04.26 03:05:40 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:05:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Predef.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nimport scala.language.implicitConversions\n\nimport scala.collection.{mutable, immutable, ArrayOps, StringOps}, immutable.WrappedString\nimport scala.annotation.{elidable, implicitNotFound}, elidable.ASSERTION\nimport scala.annotation.meta.{ companionClass, companionMethod }\n\n/** The `Predef` object provides definitions that are accessible in all Scala\n *  compilation units without explicit qualification.\n *\n *  \u003d\u003d\u003d Commonly Used Types \u003d\u003d\u003d\n *  Predef provides type aliases for types which are commonly used, such as\n *  the immutable collection types [[scala.collection.immutable.Map]] and\n *  [[scala.collection.immutable.Set]].\n *\n *  \u003d\u003d\u003d Console Output \u003d\u003d\u003d\n *  For basic console output, `Predef` provides convenience methods [[print(x:Any* print]] and [[println(x:Any* println]],\n *  which are aliases of the methods in the object [[scala.Console]].\n *\n *  \u003d\u003d\u003d Assertions \u003d\u003d\u003d\n *  A set of `assert` functions are provided for use as a way to document\n *  and dynamically check invariants in code. Invocations of `assert` can be elided\n *  at compile time by providing the command line option `-Xdisable-assertions`,\n *  which raises `-Xelide-below` above `elidable.ASSERTION`, to the `scalac` command.\n *\n *  Variants of `assert` intended for use with static analysis tools are also\n *  provided: `assume`, `require` and `ensuring`. `require` and `ensuring` are\n *  intended for use as a means of design-by-contract style specification\n *  of pre- and post-conditions on functions, with the intention that these\n *  specifications could be consumed by a static analysis tool. For instance,\n *\n *  {{{\n *  def addNaturals(nats: List[Int]): Int \u003d {\n *    require(nats forall (_ \u003e\u003d 0), \"List contains negative numbers\")\n *    nats.foldLeft(0)(_ + _)\n *  } ensuring(_ \u003e\u003d 0)\n *  }}}\n *\n *  The declaration of `addNaturals` states that the list of integers passed should\n *  only contain natural numbers (i.e. non-negative), and that the result returned\n *  will also be natural. `require` is distinct from `assert` in that if the\n *  condition fails, then the caller of the function is to blame rather than a\n *  logical error having been made within `addNaturals` itself. `ensuring` is a\n *  form of `assert` that declares the guarantee the function is providing with\n *  regards to its return value.\n *\n *  \u003d\u003d\u003d Implicit Conversions \u003d\u003d\u003d\n *  A number of commonly applied implicit conversions are also defined here, and\n *  in the parent type [[scala.LowPriorityImplicits]]. Implicit conversions\n *  are provided for the \"widening\" of numeric values, for instance, converting a\n *  Short value to a Long value as required, and to add additional higher-order\n *  functions to Array values. These are described in more detail in the documentation of [[scala.Array]].\n *\n * @groupname utilities Utility Methods\n * @groupprio utilities 10\n *\n * @groupname assertions Assertions\n * @groupprio assertions 20\n * @groupdesc assertions These methods support program verification and runtime correctness.\n *\n * @groupname console-output Console Output\n * @groupprio console-output 30\n * @groupdesc console-output These methods provide output via the console.\n *\n * @groupname aliases Aliases\n * @groupprio aliases 50\n * @groupdesc aliases These aliases bring selected immutable types into scope without any imports.\n *\n * @groupname conversions-string String Conversions\n * @groupprio conversions-string 60\n * @groupdesc conversions-string Conversions from String to StringOps or WrappedString.\n *\n * @groupname implicit-classes-any Implicit Classes\n * @groupprio implicit-classes-any 70\n * @groupdesc implicit-classes-any These implicit classes add useful extension methods to every type.\n *\n * @groupname char-sequence-wrappers CharSequence Wrappers\n * @groupprio char-sequence-wrappers 80\n * @groupdesc char-sequence-wrappers Wrappers that implements CharSequence and were implicit classes.\n *\n * @groupname conversions-java-to-anyval Java to Scala\n * @groupprio conversions-java-to-anyval 90\n * @groupdesc conversions-java-to-anyval Implicit conversion from Java primitive wrapper types to Scala equivalents.\n *\n * @groupname conversions-anyval-to-java Scala to Java\n * @groupprio conversions-anyval-to-java 100\n * @groupdesc conversions-anyval-to-java Implicit conversion from Scala AnyVals to Java primitive wrapper types equivalents.\n *\n * @groupname conversions-array-to-wrapped-array Array to ArraySeq\n * @groupprio conversions-array-to-wrapped-array 110\n * @groupdesc conversions-array-to-wrapped-array Conversions from Arrays to ArraySeqs.\n */\nobject Predef extends LowPriorityImplicits {\n  /**\n   * Retrieve the runtime representation of a class type. `classOf[T]` is equivalent to\n   * the class literal `T.class` in Java.\n   *\n   * @example {{{\n   * val listClass \u003d classOf[List[_]]\n   * // listClass is java.lang.Class[List[_]] \u003d class scala.collection.immutable.List\n   *\n   * val mapIntString \u003d classOf[Map[Int,String]]\n   * // mapIntString is java.lang.Class[Map[Int,String]] \u003d interface scala.collection.immutable.Map\n   * }}}\n   *\n   * @return The runtime [[Class]] representation of type `T`.\n   * @group utilities\n   */\n  def classOf[T]: Class[T] \u003d null // This is a stub method. The actual implementation is filled in by the compiler.\n\n  /**\n   * Retrieve the single value of a type with a unique inhabitant.\n   *\n   * @example {{{\n   * object Foo\n   * val foo \u003d valueOf[Foo.type]\n   * // foo is Foo.type \u003d Foo\n   *\n   * val bar \u003d valueOf[23]\n   * // bar is 23.type \u003d 23\n   * }}}\n   * @group utilities\n   */\n  @inline def valueOf[T](implicit vt: ValueOf[T]): T \u003d vt.value\n\n  /** The `String` type in Scala has all the methods of the underlying\n   *  [[java.lang.String]], of which it is just an alias.\n   *\n   *  In addition, extension methods in [[scala.collection.StringOps]]\n   *  are added implicitly through the conversion [[augmentString]].\n   *  @group aliases\n   */\n  type String        \u003d java.lang.String\n  /**  @group aliases */\n  type Class[T]      \u003d java.lang.Class[T]\n\n  // miscellaneous -----------------------------------------------------\n  scala.`package`                         // to force scala package object to be seen.\n  scala.collection.immutable.List         // to force Nil, :: to be seen.\n\n  /**  @group aliases */\n  type Function[-A, +B] \u003d Function1[A, B]\n\n  /**  @group aliases */\n  type Map[K, +V] \u003d immutable.Map[K, V]\n  /**  @group aliases */\n  type Set[A]     \u003d immutable.Set[A]\n  /**  @group aliases */\n  val Map         \u003d immutable.Map\n  /**  @group aliases */\n  val Set         \u003d immutable.Set\n\n  /**\n   * Allows destructuring tuples with the same syntax as constructing them.\n   *\n   * @example {{{\n   * val tup \u003d \"foobar\" -\u003e 3\n   *\n   * val c \u003d tup match {\n   *   case str -\u003e i \u003d\u003e str.charAt(i)\n   * }\n   * }}}\n   * @group aliases\n   */\n  val -\u003e        \u003d Tuple2\n\n  // Manifest types, companions, and incantations for summoning\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  type OptManifest[T]   \u003d scala.reflect.OptManifest[T]\n  @implicitNotFound(msg \u003d \"No Manifest available for ${T}.\")\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  type Manifest[T]      \u003d scala.reflect.Manifest[T]\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  val Manifest          \u003d scala.reflect.Manifest\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  val NoManifest        \u003d scala.reflect.NoManifest\n\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use scala.reflect.classTag[T] and scala.reflect.runtime.universe.typeTag[T] instead\", \"2.10.0\")\n  def manifest[T](implicit m: Manifest[T]): Manifest[T]          \u003d m\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  def optManifest[T](implicit m: OptManifest[T]): OptManifest[T] \u003d m\n\n  // Minor variations on identity functions\n\n  /**\n   * A method that returns its input value.\n   * @tparam A type of the input value x.\n   * @param x the value of type `A` to be returned.\n   * @return the value `x`.\n   * @group utilities */\n  @inline def identity[A](x: A): A \u003d x // see `$conforms` for the implicit version\n\n  /** Summon an implicit value of type `T`. Usually, the argument is not passed explicitly.\n   *\n   *  @tparam T the type of the value to be summoned\n   *  @return the implicit value of type `T`\n   *  @group utilities\n   */\n  @inline def implicitly[T](implicit e: T): T \u003d e // TODO: when dependent method types are on by default, give this result type `e.type`, so that inliner has better chance of knowing which method to inline in calls like `implicitly[MatchingStrategy[Option]].zero`\n\n  /** Used to mark code blocks as being expressions, instead of being taken as part of anonymous classes and the like.\n   *  This is just a different name for [[identity]].\n   *\n   *  @example Separating code blocks from `new`:\n   *           {{{\n   *             val x \u003d new AnyRef\n   *             {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // the { ... } block is seen as the body of an anonymous class\n   *\n   *             val x \u003d new AnyRef\n   *\n   *             {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // an empty line is a brittle \"fix\"\n   *\n   *             val x \u003d new AnyRef\n   *             locally {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // locally guards the block and helps communicate intent\n   *           }}}\n   *  @group utilities\n   */\n  @inline def locally[T](@deprecatedName(\"x\") x: T): T \u003d x\n\n  // assertions ---------------------------------------------------------\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assert(assertion: Boolean): Unit \u003d {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @param message     a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assert(assertion: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assume(assumption: Boolean): Unit \u003d {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @param message      a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assume(assumption: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @group assertions\n   */\n  def require(requirement: Boolean): Unit \u003d {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed\")\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @param message       a String to include in the failure message\n   *  @group assertions\n   */\n  @inline final def require(requirement: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed: \"+ message)\n  }\n\n  /** `???` can be used for marking methods that remain to be implemented.\n   *  @throws NotImplementedError when `???` is invoked.\n   *  @group utilities\n   */\n  def ??? : Nothing \u003d throw new NotImplementedError\n\n  // implicit classes -----------------------------------------------------\n\n  /** @group implicit-classes-any */\n  implicit final class ArrowAssoc[A](private val self: A) extends AnyVal {\n    @inline def -\u003e [B](y: B): (A, B) \u003d (self, y)\n    @deprecated(\"Use `-\u003e` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.\", \"2.13.0\")\n    def →[B](y: B): (A, B) \u003d -\u003e(y)\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class Ensuring[A](private val self: A) extends AnyVal {\n    def ensuring(cond: Boolean): A \u003d { assert(cond); self }\n    def ensuring(cond: Boolean, msg: \u003d\u003e Any): A \u003d { assert(cond, msg); self }\n    def ensuring(cond: A \u003d\u003e Boolean): A \u003d { assert(cond(self)); self }\n    def ensuring(cond: A \u003d\u003e Boolean, msg: \u003d\u003e Any): A \u003d { assert(cond(self), msg); self }\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class StringFormat[A](private val self: A) extends AnyVal {\n    /** Returns string formatted according to given `format` string.\n     *  Format strings are as for `String.format`\n     *  (@see java.lang.String.format).\n     */\n    @deprecated(\"Use `formatString.format(value)` instead of `value.formatted(formatString)`,\\nor use the `f\\\"\\\"` string interpolator. In Java 15 and later, `formatted` resolves to the new method in String which has reversed parameters.\", \"2.12.16\")\n    @inline def formatted(fmtstr: String): String \u003d fmtstr format self\n  }\n\n  /** Injects String concatenation operator `+` to any classes. \n   * @group implicit-classes-any\n   */\n  @(deprecated @companionMethod)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\")\n  @(deprecated @companionClass)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\") // for Scaladoc\n  // scala/bug#8229 retaining the pre 2.11 name for source compatibility in shadowing this implicit\n  implicit final class any2stringadd[A](private val self: A) extends AnyVal {\n    def +(other: String): String \u003d String.valueOf(self) + other\n  }\n\n  /** @group char-sequence-wrappers */\n  final class SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]) extends CharSequence {\n    def length: Int                                     \u003d sequenceOfChars.length\n    def charAt(index: Int): Char                        \u003d sequenceOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence \u003d new SeqCharSequence(sequenceOfChars.slice(start, end))\n    override def toString                               \u003d sequenceOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]): SeqCharSequence \u003d new SeqCharSequence(sequenceOfChars)\n\n  /** @group char-sequence-wrappers */\n  final class ArrayCharSequence(arrayOfChars: Array[Char]) extends CharSequence {\n    def length: Int                                     \u003d arrayOfChars.length\n    def charAt(index: Int): Char                        \u003d arrayOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence \u003d new runtime.ArrayCharSequence(arrayOfChars, start, end)\n    override def toString                               \u003d arrayOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def ArrayCharSequence(arrayOfChars: Array[Char]): ArrayCharSequence \u003d new ArrayCharSequence(arrayOfChars)\n\n  /** @group conversions-string */\n  @inline implicit def augmentString(x: String): StringOps \u003d new StringOps(x)\n\n  // printing -----------------------------------------------------------\n\n  /** Prints an object to `out` using its `toString` method.\n   *\n   *  @param x the object to print; may be null.\n   *  @group console-output\n   */\n  def print(x: Any): Unit \u003d Console.print(x)\n\n  /** Prints a newline character on the default output.\n   *  @group console-output\n   */\n  def println(): Unit \u003d Console.println()\n\n  /** Prints out an object to the default output, followed by a newline character.\n   *\n   *  @param x the object to print.\n   *  @group console-output\n   */\n  def println(x: Any): Unit \u003d Console.println(x)\n\n  /** Prints its arguments as a formatted string to the default output,\n   *  based on a string pattern (in a fashion similar to printf in C).\n   *\n   *  The interpretation of the formatting patterns is described in\n   *  [[java.util.Formatter]].\n   *\n   *  Consider using the [[scala.StringContext.f f interpolator]] as more type safe and idiomatic.\n   *\n   *  @param text the pattern for formatting the arguments.\n   *  @param xs   the arguments used to instantiate the pattern.\n   *  @throws java.lang.IllegalArgumentException if there was a problem with the format string or arguments\n   *\n   *  @see [[scala.StringContext.f StringContext.f]]\n   *  @group console-output\n   */\n  def printf(text: String, xs: Any*): Unit \u003d Console.print(text.format(xs: _*))\n\n  // views --------------------------------------------------------------\n\n  // these two are morally deprecated but the @deprecated annotation has been moved to the extension method themselves,\n  // in order to provide a more specific deprecation method.\n  implicit def tuple2ToZippedOps[T1, T2](x: (T1, T2)): runtime.Tuple2Zipped.Ops[T1, T2]             \u003d new runtime.Tuple2Zipped.Ops(x)\n  implicit def tuple3ToZippedOps[T1, T2, T3](x: (T1, T2, T3)): runtime.Tuple3Zipped.Ops[T1, T2, T3] \u003d new runtime.Tuple3Zipped.Ops(x)\n\n  // Not specialized anymore since 2.13 but we still need separate methods\n  // to avoid https://github.com/scala/bug/issues/10746\n  // TODO: should not need @inline. add heuristic to inline factories for value classes.\n  @inline implicit def genericArrayOps[T](xs: Array[T]): ArrayOps[T]          \u003d new ArrayOps(xs)\n  @inline implicit def booleanArrayOps(xs: Array[Boolean]): ArrayOps[Boolean] \u003d new ArrayOps(xs)\n  @inline implicit def byteArrayOps(xs: Array[Byte]): ArrayOps[Byte]          \u003d new ArrayOps(xs)\n  @inline implicit def charArrayOps(xs: Array[Char]): ArrayOps[Char]          \u003d new ArrayOps(xs)\n  @inline implicit def doubleArrayOps(xs: Array[Double]): ArrayOps[Double]    \u003d new ArrayOps(xs)\n  @inline implicit def floatArrayOps(xs: Array[Float]): ArrayOps[Float]       \u003d new ArrayOps(xs)\n  @inline implicit def intArrayOps(xs: Array[Int]): ArrayOps[Int]             \u003d new ArrayOps(xs)\n  @inline implicit def longArrayOps(xs: Array[Long]): ArrayOps[Long]          \u003d new ArrayOps(xs)\n  @inline implicit def refArrayOps[T \u003c: AnyRef](xs: Array[T]): ArrayOps[T]    \u003d new ArrayOps(xs)\n  @inline implicit def shortArrayOps(xs: Array[Short]): ArrayOps[Short]       \u003d new ArrayOps(xs)\n  @inline implicit def unitArrayOps(xs: Array[Unit]): ArrayOps[Unit]          \u003d new ArrayOps(xs)\n\n  // \"Autoboxing\" and \"Autounboxing\" ---------------------------------------------------\n\n  /** @group conversions-anyval-to-java */\n  implicit def byte2Byte(x: Byte): java.lang.Byte             \u003d x.asInstanceOf[java.lang.Byte]\n  /** @group conversions-anyval-to-java */\n  implicit def short2Short(x: Short): java.lang.Short         \u003d x.asInstanceOf[java.lang.Short]\n  /** @group conversions-anyval-to-java */\n  implicit def char2Character(x: Char): java.lang.Character   \u003d x.asInstanceOf[java.lang.Character]\n  /** @group conversions-anyval-to-java */\n  implicit def int2Integer(x: Int): java.lang.Integer         \u003d x.asInstanceOf[java.lang.Integer]\n  /** @group conversions-anyval-to-java */\n  implicit def long2Long(x: Long): java.lang.Long             \u003d x.asInstanceOf[java.lang.Long]\n  /** @group conversions-anyval-to-java */\n  implicit def float2Float(x: Float): java.lang.Float         \u003d x.asInstanceOf[java.lang.Float]\n  /** @group conversions-anyval-to-java */\n  implicit def double2Double(x: Double): java.lang.Double     \u003d x.asInstanceOf[java.lang.Double]\n  /** @group conversions-anyval-to-java */\n  implicit def boolean2Boolean(x: Boolean): java.lang.Boolean \u003d x.asInstanceOf[java.lang.Boolean]\n\n  /** @group conversions-java-to-anyval */\n  implicit def Byte2byte(x: java.lang.Byte): Byte             \u003d x.asInstanceOf[Byte]\n  /** @group conversions-java-to-anyval */\n  implicit def Short2short(x: java.lang.Short): Short         \u003d x.asInstanceOf[Short]\n  /** @group conversions-java-to-anyval */\n  implicit def Character2char(x: java.lang.Character): Char   \u003d x.asInstanceOf[Char]\n  /** @group conversions-java-to-anyval */\n  implicit def Integer2int(x: java.lang.Integer): Int         \u003d x.asInstanceOf[Int]\n  /** @group conversions-java-to-anyval */\n  implicit def Long2long(x: java.lang.Long): Long             \u003d x.asInstanceOf[Long]\n  /** @group conversions-java-to-anyval */\n  implicit def Float2float(x: java.lang.Float): Float         \u003d x.asInstanceOf[Float]\n  /** @group conversions-java-to-anyval */\n  implicit def Double2double(x: java.lang.Double): Double     \u003d x.asInstanceOf[Double]\n  /** @group conversions-java-to-anyval */\n  implicit def Boolean2boolean(x: java.lang.Boolean): Boolean \u003d x.asInstanceOf[Boolean]\n\n  /** An implicit of type `A \u003d\u003e A` is available for all `A` because it can always\n   *  be implemented using the identity function. This also means that an\n   *  implicit of type `A \u003d\u003e B` is always available when `A \u003c: B`, because\n   *  `(A \u003d\u003e A) \u003c: (A \u003d\u003e B)`.\n   */\n  // $ to avoid accidental shadowing (e.g. scala/bug#7788)\n  implicit def $conforms[A]: A \u003d\u003e A \u003d \u003c:\u003c.refl\n}\n\n/** The `LowPriorityImplicits` class provides implicit values that\n*  are valid in all Scala compilation units without explicit qualification,\n*  but that are partially overridden by higher-priority conversions in object\n*  `Predef`.\n*/\n// scala/bug#7335 Parents of Predef are defined in the same compilation unit to avoid\n// cyclic reference errors compiling the standard library *without* a previously\n// compiled copy on the classpath.\nprivate[scala] abstract class LowPriorityImplicits extends LowPriorityImplicits2 {\n  import mutable.ArraySeq\n\n  /** We prefer the java.lang.* boxed types to these wrappers in\n   *  any potential conflicts.  Conflicts do exist because the wrappers\n   *  need to implement ScalaNumber in order to have a symmetric equals\n   *  method, but that implies implementing java.lang.Number as well.\n   *\n   *  Note - these are inlined because they are value classes, but\n   *  the call to xxxWrapper is not eliminated even though it does nothing.\n   *  Even inlined, every call site does a no-op retrieval of Predef\u0027s MODULE$\n   *  because maybe loading Predef has side effects!\n   */\n  @inline implicit def byteWrapper(x: Byte): runtime.RichByte          \u003d new runtime.RichByte(x)\n  @inline implicit def shortWrapper(x: Short): runtime.RichShort       \u003d new runtime.RichShort(x)\n  @inline implicit def intWrapper(x: Int): runtime.RichInt             \u003d new runtime.RichInt(x)\n  @inline implicit def charWrapper(c: Char): runtime.RichChar          \u003d new runtime.RichChar(c)\n  @inline implicit def longWrapper(x: Long): runtime.RichLong          \u003d new runtime.RichLong(x)\n  @inline implicit def floatWrapper(x: Float): runtime.RichFloat       \u003d new runtime.RichFloat(x)\n  @inline implicit def doubleWrapper(x: Double): runtime.RichDouble    \u003d new runtime.RichDouble(x)\n  @inline implicit def booleanWrapper(x: Boolean): runtime.RichBoolean \u003d new runtime.RichBoolean(x)\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def genericWrapArray[T](xs: Array[T]): ArraySeq[T] \u003d\n    if (xs eq null) null\n    else ArraySeq.make(xs)\n\n  // Since the JVM thinks arrays are covariant, one 0-length Array[AnyRef]\n  // is as good as another for all T \u003c: AnyRef.  Instead of creating 100,000,000\n  // unique ones by way of this implicit, let\u0027s share one.\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapRefArray[T \u003c: AnyRef](xs: Array[T]): ArraySeq.ofRef[T] \u003d {\n    if (xs eq null) null\n    else if (xs.length \u003d\u003d 0) ArraySeq.empty[AnyRef].asInstanceOf[ArraySeq.ofRef[T]]\n    else new ArraySeq.ofRef[T](xs)\n  }\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapIntArray(xs: Array[Int]): ArraySeq.ofInt \u003d if (xs ne null) new ArraySeq.ofInt(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapDoubleArray(xs: Array[Double]): ArraySeq.ofDouble \u003d if (xs ne null) new ArraySeq.ofDouble(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapLongArray(xs: Array[Long]): ArraySeq.ofLong \u003d if (xs ne null) new ArraySeq.ofLong(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapFloatArray(xs: Array[Float]): ArraySeq.ofFloat \u003d if (xs ne null) new ArraySeq.ofFloat(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapCharArray(xs: Array[Char]): ArraySeq.ofChar \u003d if (xs ne null) new ArraySeq.ofChar(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapByteArray(xs: Array[Byte]): ArraySeq.ofByte \u003d if (xs ne null) new ArraySeq.ofByte(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapShortArray(xs: Array[Short]): ArraySeq.ofShort \u003d if (xs ne null) new ArraySeq.ofShort(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapBooleanArray(xs: Array[Boolean]): ArraySeq.ofBoolean \u003d if (xs ne null) new ArraySeq.ofBoolean(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapUnitArray(xs: Array[Unit]): ArraySeq.ofUnit \u003d if (xs ne null) new ArraySeq.ofUnit(xs) else null\n\n  /** @group conversions-string */\n  implicit def wrapString(s: String): WrappedString \u003d if (s ne null) new WrappedString(s) else null\n}\n\nprivate[scala] abstract class LowPriorityImplicits2 {\n  @deprecated(\"implicit conversions from Array to immutable.IndexedSeq are implemented by copying; use `toIndexedSeq` explicitly if you want to copy, or use the more efficient non-copying ArraySeq.unsafeWrapArray\", since\u003d\"2.13.0\")\n  implicit def copyArrayToImmutableIndexedSeq[T](xs: Array[T]): IndexedSeq[T] \u003d\n    if (xs eq null) null\n    else new ArrayOps(xs).toIndexedSeq\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:05:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Predef.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:05:40 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:05:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Predef.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nimport scala.language.implicitConversions\n\nimport scala.collection.{mutable, immutable, ArrayOps, StringOps}, immutable.WrappedString\nimport scala.annotation.{elidable, implicitNotFound}, elidable.ASSERTION\nimport scala.annotation.meta.{ companionClass, companionMethod }\n\n/** The `Predef` object provides definitions that are accessible in all Scala\n *  compilation units without explicit qualification.\n *\n *  \u003d\u003d\u003d Commonly Used Types \u003d\u003d\u003d\n *  Predef provides type aliases for types which are commonly used, such as\n *  the immutable collection types [[scala.collection.immutable.Map]] and\n *  [[scala.collection.immutable.Set]].\n *\n *  \u003d\u003d\u003d Console Output \u003d\u003d\u003d\n *  For basic console output, `Predef` provides convenience methods [[print(x:Any* print]] and [[println(x:Any* println]],\n *  which are aliases of the methods in the object [[scala.Console]].\n *\n *  \u003d\u003d\u003d Assertions \u003d\u003d\u003d\n *  A set of `assert` functions are provided for use as a way to document\n *  and dynamically check invariants in code. Invocations of `assert` can be elided\n *  at compile time by providing the command line option `-Xdisable-assertions`,\n *  which raises `-Xelide-below` above `elidable.ASSERTION`, to the `scalac` command.\n *\n *  Variants of `assert` intended for use with static analysis tools are also\n *  provided: `assume`, `require` and `ensuring`. `require` and `ensuring` are\n *  intended for use as a means of design-by-contract style specification\n *  of pre- and post-conditions on functions, with the intention that these\n *  specifications could be consumed by a static analysis tool. For instance,\n *\n *  {{{\n *  def addNaturals(nats: List[Int]): Int \u003d {\n *    require(nats forall (_ \u003e\u003d 0), \"List contains negative numbers\")\n *    nats.foldLeft(0)(_ + _)\n *  } ensuring(_ \u003e\u003d 0)\n *  }}}\n *\n *  The declaration of `addNaturals` states that the list of integers passed should\n *  only contain natural numbers (i.e. non-negative), and that the result returned\n *  will also be natural. `require` is distinct from `assert` in that if the\n *  condition fails, then the caller of the function is to blame rather than a\n *  logical error having been made within `addNaturals` itself. `ensuring` is a\n *  form of `assert` that declares the guarantee the function is providing with\n *  regards to its return value.\n *\n *  \u003d\u003d\u003d Implicit Conversions \u003d\u003d\u003d\n *  A number of commonly applied implicit conversions are also defined here, and\n *  in the parent type [[scala.LowPriorityImplicits]]. Implicit conversions\n *  are provided for the \"widening\" of numeric values, for instance, converting a\n *  Short value to a Long value as required, and to add additional higher-order\n *  functions to Array values. These are described in more detail in the documentation of [[scala.Array]].\n *\n * @groupname utilities Utility Methods\n * @groupprio utilities 10\n *\n * @groupname assertions Assertions\n * @groupprio assertions 20\n * @groupdesc assertions These methods support program verification and runtime correctness.\n *\n * @groupname console-output Console Output\n * @groupprio console-output 30\n * @groupdesc console-output These methods provide output via the console.\n *\n * @groupname aliases Aliases\n * @groupprio aliases 50\n * @groupdesc aliases These aliases bring selected immutable types into scope without any imports.\n *\n * @groupname conversions-string String Conversions\n * @groupprio conversions-string 60\n * @groupdesc conversions-string Conversions from String to StringOps or WrappedString.\n *\n * @groupname implicit-classes-any Implicit Classes\n * @groupprio implicit-classes-any 70\n * @groupdesc implicit-classes-any These implicit classes add useful extension methods to every type.\n *\n * @groupname char-sequence-wrappers CharSequence Wrappers\n * @groupprio char-sequence-wrappers 80\n * @groupdesc char-sequence-wrappers Wrappers that implements CharSequence and were implicit classes.\n *\n * @groupname conversions-java-to-anyval Java to Scala\n * @groupprio conversions-java-to-anyval 90\n * @groupdesc conversions-java-to-anyval Implicit conversion from Java primitive wrapper types to Scala equivalents.\n *\n * @groupname conversions-anyval-to-java Scala to Java\n * @groupprio conversions-anyval-to-java 100\n * @groupdesc conversions-anyval-to-java Implicit conversion from Scala AnyVals to Java primitive wrapper types equivalents.\n *\n * @groupname conversions-array-to-wrapped-array Array to ArraySeq\n * @groupprio conversions-array-to-wrapped-array 110\n * @groupdesc conversions-array-to-wrapped-array Conversions from Arrays to ArraySeqs.\n */\nobject Predef extends LowPriorityImplicits {\n  /**\n   * Retrieve the runtime representation of a class type. `classOf[T]` is equivalent to\n   * the class literal `T.class` in Java.\n   *\n   * @example {{{\n   * val listClass \u003d classOf[List[_]]\n   * // listClass is java.lang.Class[List[_]] \u003d class scala.collection.immutable.List\n   *\n   * val mapIntString \u003d classOf[Map[Int,String]]\n   * // mapIntString is java.lang.Class[Map[Int,String]] \u003d interface scala.collection.immutable.Map\n   * }}}\n   *\n   * @return The runtime [[Class]] representation of type `T`.\n   * @group utilities\n   */\n  def classOf[T]: Class[T] \u003d null // This is a stub method. The actual implementation is filled in by the compiler.\n\n  /**\n   * Retrieve the single value of a type with a unique inhabitant.\n   *\n   * @example {{{\n   * object Foo\n   * val foo \u003d valueOf[Foo.type]\n   * // foo is Foo.type \u003d Foo\n   *\n   * val bar \u003d valueOf[23]\n   * // bar is 23.type \u003d 23\n   * }}}\n   * @group utilities\n   */\n  @inline def valueOf[T](implicit vt: ValueOf[T]): T \u003d vt.value\n\n  /** The `String` type in Scala has all the methods of the underlying\n   *  [[java.lang.String]], of which it is just an alias.\n   *\n   *  In addition, extension methods in [[scala.collection.StringOps]]\n   *  are added implicitly through the conversion [[augmentString]].\n   *  @group aliases\n   */\n  type String        \u003d java.lang.String\n  /**  @group aliases */\n  type Class[T]      \u003d java.lang.Class[T]\n\n  // miscellaneous -----------------------------------------------------\n  scala.`package`                         // to force scala package object to be seen.\n  scala.collection.immutable.List         // to force Nil, :: to be seen.\n\n  /**  @group aliases */\n  type Function[-A, +B] \u003d Function1[A, B]\n\n  /**  @group aliases */\n  type Map[K, +V] \u003d immutable.Map[K, V]\n  /**  @group aliases */\n  type Set[A]     \u003d immutable.Set[A]\n  /**  @group aliases */\n  val Map         \u003d immutable.Map\n  /**  @group aliases */\n  val Set         \u003d immutable.Set\n\n  /**\n   * Allows destructuring tuples with the same syntax as constructing them.\n   *\n   * @example {{{\n   * val tup \u003d \"foobar\" -\u003e 3\n   *\n   * val c \u003d tup match {\n   *   case str -\u003e i \u003d\u003e str.charAt(i)\n   * }\n   * }}}\n   * @group aliases\n   */\n  val -\u003e        \u003d Tuple2\n\n  // Manifest types, companions, and incantations for summoning\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  type OptManifest[T]   \u003d scala.reflect.OptManifest[T]\n  @implicitNotFound(msg \u003d \"No Manifest available for ${T}.\")\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  type Manifest[T]      \u003d scala.reflect.Manifest[T]\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  val Manifest          \u003d scala.reflect.Manifest\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  val NoManifest        \u003d scala.reflect.NoManifest\n\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use scala.reflect.classTag[T] and scala.reflect.runtime.universe.typeTag[T] instead\", \"2.10.0\")\n  def manifest[T](implicit m: Manifest[T]): Manifest[T]          \u003d m\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  def optManifest[T](implicit m: OptManifest[T]): OptManifest[T] \u003d m\n\n  // Minor variations on identity functions\n\n  /**\n   * A method that returns its input value.\n   * @tparam A type of the input value x.\n   * @param x the value of type `A` to be returned.\n   * @return the value `x`.\n   * @group utilities */\n  @inline def identity[A](x: A): A \u003d x // see `$conforms` for the implicit version\n\n  /** Summon an implicit value of type `T`. Usually, the argument is not passed explicitly.\n   *\n   *  @tparam T the type of the value to be summoned\n   *  @return the implicit value of type `T`\n   *  @group utilities\n   */\n  @inline def implicitly[T](implicit e: T): T \u003d e // TODO: when dependent method types are on by default, give this result type `e.type`, so that inliner has better chance of knowing which method to inline in calls like `implicitly[MatchingStrategy[Option]].zero`\n\n  /** Used to mark code blocks as being expressions, instead of being taken as part of anonymous classes and the like.\n   *  This is just a different name for [[identity]].\n   *\n   *  @example Separating code blocks from `new`:\n   *           {{{\n   *             val x \u003d new AnyRef\n   *             {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // the { ... } block is seen as the body of an anonymous class\n   *\n   *             val x \u003d new AnyRef\n   *\n   *             {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // an empty line is a brittle \"fix\"\n   *\n   *             val x \u003d new AnyRef\n   *             locally {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // locally guards the block and helps communicate intent\n   *           }}}\n   *  @group utilities\n   */\n  @inline def locally[T](@deprecatedName(\"x\") x: T): T \u003d x\n\n  // assertions ---------------------------------------------------------\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assert(assertion: Boolean): Unit \u003d {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @param message     a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assert(assertion: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assume(assumption: Boolean): Unit \u003d {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @param message      a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assume(assumption: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @group assertions\n   */\n  def require(requirement: Boolean): Unit \u003d {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed\")\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @param message       a String to include in the failure message\n   *  @group assertions\n   */\n  @inline final def require(requirement: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed: \"+ message)\n  }\n\n  /** `???` can be used for marking methods that remain to be implemented.\n   *  @throws NotImplementedError when `???` is invoked.\n   *  @group utilities\n   */\n  def ??? : Nothing \u003d throw new NotImplementedError\n\n  // implicit classes -----------------------------------------------------\n\n  /** @group implicit-classes-any */\n  implicit final class ArrowAssoc[A](private val self: A) extends AnyVal {\n    @inline def -\u003e [B](y: B): (A, B) \u003d (self, y)\n    @deprecated(\"Use `-\u003e` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.\", \"2.13.0\")\n    def →[B](y: B): (A, B) \u003d -\u003e(y)\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class Ensuring[A](private val self: A) extends AnyVal {\n    def ensuring(cond: Boolean): A \u003d { assert(cond); self }\n    def ensuring(cond: Boolean, msg: \u003d\u003e Any): A \u003d { assert(cond, msg); self }\n    def ensuring(cond: A \u003d\u003e Boolean): A \u003d { assert(cond(self)); self }\n    def ensuring(cond: A \u003d\u003e Boolean, msg: \u003d\u003e Any): A \u003d { assert(cond(self), msg); self }\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class StringFormat[A](private val self: A) extends AnyVal {\n    /** Returns string formatted according to given `format` string.\n     *  Format strings are as for `String.format`\n     *  (@see java.lang.String.format).\n     */\n    @deprecated(\"Use `formatString.format(value)` instead of `value.formatted(formatString)`,\\nor use the `f\\\"\\\"` string interpolator. In Java 15 and later, `formatted` resolves to the new method in String which has reversed parameters.\", \"2.12.16\")\n    @inline def formatted(fmtstr: String): String \u003d fmtstr format self\n  }\n\n  /** Injects String concatenation operator `+` to any classes. \n   * @group implicit-classes-any\n   */\n  @(deprecated @companionMethod)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\")\n  @(deprecated @companionClass)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\") // for Scaladoc\n  // scala/bug#8229 retaining the pre 2.11 name for source compatibility in shadowing this implicit\n  implicit final class any2stringadd[A](private val self: A) extends AnyVal {\n    def +(other: String): String \u003d String.valueOf(self) + other\n  }\n\n  /** @group char-sequence-wrappers */\n  final class SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]) extends CharSequence {\n    def length: Int                                     \u003d sequenceOfChars.length\n    def charAt(index: Int): Char                        \u003d sequenceOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence \u003d new SeqCharSequence(sequenceOfChars.slice(start, end))\n    override def toString                               \u003d sequenceOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]): SeqCharSequence \u003d new SeqCharSequence(sequenceOfChars)\n\n  /** @group char-sequence-wrappers */\n  final class ArrayCharSequence(arrayOfChars: Array[Char]) extends CharSequence {\n    def length: Int                                     \u003d arrayOfChars.length\n    def charAt(index: Int): Char                        \u003d arrayOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence \u003d new runtime.ArrayCharSequence(arrayOfChars, start, end)\n    override def toString                               \u003d arrayOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def ArrayCharSequence(arrayOfChars: Array[Char]): ArrayCharSequence \u003d new ArrayCharSequence(arrayOfChars)\n\n  /** @group conversions-string */\n  @inline implicit def augmentString(x: String): StringOps \u003d new StringOps(x)\n\n  // printing -----------------------------------------------------------\n\n  /** Prints an object to `out` using its `toString` method.\n   *\n   *  @param x the object to print; may be null.\n   *  @group console-output\n   */\n  def print(x: Any): Unit \u003d Console.print(x)\n\n  /** Prints a newline character on the default output.\n   *  @group console-output\n   */\n  def println(): Unit \u003d Console.println()\n\n  /** Prints out an object to the default output, followed by a newline character.\n   *\n   *  @param x the object to print.\n   *  @group console-output\n   */\n  def println(x: Any): Unit \u003d Console.println(x)\n\n  /** Prints its arguments as a formatted string to the default output,\n   *  based on a string pattern (in a fashion similar to printf in C).\n   *\n   *  The interpretation of the formatting patterns is described in\n   *  [[java.util.Formatter]].\n   *\n   *  Consider using the [[scala.StringContext.f f interpolator]] as more type safe and idiomatic.\n   *\n   *  @param text the pattern for formatting the arguments.\n   *  @param xs   the arguments used to instantiate the pattern.\n   *  @throws java.lang.IllegalArgumentException if there was a problem with the format string or arguments\n   *\n   *  @see [[scala.StringContext.f StringContext.f]]\n   *  @group console-output\n   */\n  def printf(text: String, xs: Any*): Unit \u003d Console.print(text.format(xs: _*))\n\n  // views --------------------------------------------------------------\n\n  // these two are morally deprecated but the @deprecated annotation has been moved to the extension method themselves,\n  // in order to provide a more specific deprecation method.\n  implicit def tuple2ToZippedOps[T1, T2](x: (T1, T2)): runtime.Tuple2Zipped.Ops[T1, T2]             \u003d new runtime.Tuple2Zipped.Ops(x)\n  implicit def tuple3ToZippedOps[T1, T2, T3](x: (T1, T2, T3)): runtime.Tuple3Zipped.Ops[T1, T2, T3] \u003d new runtime.Tuple3Zipped.Ops(x)\n\n  // Not specialized anymore since 2.13 but we still need separate methods\n  // to avoid https://github.com/scala/bug/issues/10746\n  // TODO: should not need @inline. add heuristic to inline factories for value classes.\n  @inline implicit def genericArrayOps[T](xs: Array[T]): ArrayOps[T]          \u003d new ArrayOps(xs)\n  @inline implicit def booleanArrayOps(xs: Array[Boolean]): ArrayOps[Boolean] \u003d new ArrayOps(xs)\n  @inline implicit def byteArrayOps(xs: Array[Byte]): ArrayOps[Byte]          \u003d new ArrayOps(xs)\n  @inline implicit def charArrayOps(xs: Array[Char]): ArrayOps[Char]          \u003d new ArrayOps(xs)\n  @inline implicit def doubleArrayOps(xs: Array[Double]): ArrayOps[Double]    \u003d new ArrayOps(xs)\n  @inline implicit def floatArrayOps(xs: Array[Float]): ArrayOps[Float]       \u003d new ArrayOps(xs)\n  @inline implicit def intArrayOps(xs: Array[Int]): ArrayOps[Int]             \u003d new ArrayOps(xs)\n  @inline implicit def longArrayOps(xs: Array[Long]): ArrayOps[Long]          \u003d new ArrayOps(xs)\n  @inline implicit def refArrayOps[T \u003c: AnyRef](xs: Array[T]): ArrayOps[T]    \u003d new ArrayOps(xs)\n  @inline implicit def shortArrayOps(xs: Array[Short]): ArrayOps[Short]       \u003d new ArrayOps(xs)\n  @inline implicit def unitArrayOps(xs: Array[Unit]): ArrayOps[Unit]          \u003d new ArrayOps(xs)\n\n  // \"Autoboxing\" and \"Autounboxing\" ---------------------------------------------------\n\n  /** @group conversions-anyval-to-java */\n  implicit def byte2Byte(x: Byte): java.lang.Byte             \u003d x.asInstanceOf[java.lang.Byte]\n  /** @group conversions-anyval-to-java */\n  implicit def short2Short(x: Short): java.lang.Short         \u003d x.asInstanceOf[java.lang.Short]\n  /** @group conversions-anyval-to-java */\n  implicit def char2Character(x: Char): java.lang.Character   \u003d x.asInstanceOf[java.lang.Character]\n  /** @group conversions-anyval-to-java */\n  implicit def int2Integer(x: Int): java.lang.Integer         \u003d x.asInstanceOf[java.lang.Integer]\n  /** @group conversions-anyval-to-java */\n  implicit def long2Long(x: Long): java.lang.Long             \u003d x.asInstanceOf[java.lang.Long]\n  /** @group conversions-anyval-to-java */\n  implicit def float2Float(x: Float): java.lang.Float         \u003d x.asInstanceOf[java.lang.Float]\n  /** @group conversions-anyval-to-java */\n  implicit def double2Double(x: Double): java.lang.Double     \u003d x.asInstanceOf[java.lang.Double]\n  /** @group conversions-anyval-to-java */\n  implicit def boolean2Boolean(x: Boolean): java.lang.Boolean \u003d x.asInstanceOf[java.lang.Boolean]\n\n  /** @group conversions-java-to-anyval */\n  implicit def Byte2byte(x: java.lang.Byte): Byte             \u003d x.asInstanceOf[Byte]\n  /** @group conversions-java-to-anyval */\n  implicit def Short2short(x: java.lang.Short): Short         \u003d x.asInstanceOf[Short]\n  /** @group conversions-java-to-anyval */\n  implicit def Character2char(x: java.lang.Character): Char   \u003d x.asInstanceOf[Char]\n  /** @group conversions-java-to-anyval */\n  implicit def Integer2int(x: java.lang.Integer): Int         \u003d x.asInstanceOf[Int]\n  /** @group conversions-java-to-anyval */\n  implicit def Long2long(x: java.lang.Long): Long             \u003d x.asInstanceOf[Long]\n  /** @group conversions-java-to-anyval */\n  implicit def Float2float(x: java.lang.Float): Float         \u003d x.asInstanceOf[Float]\n  /** @group conversions-java-to-anyval */\n  implicit def Double2double(x: java.lang.Double): Double     \u003d x.asInstanceOf[Double]\n  /** @group conversions-java-to-anyval */\n  implicit def Boolean2boolean(x: java.lang.Boolean): Boolean \u003d x.asInstanceOf[Boolean]\n\n  /** An implicit of type `A \u003d\u003e A` is available for all `A` because it can always\n   *  be implemented using the identity function. This also means that an\n   *  implicit of type `A \u003d\u003e B` is always available when `A \u003c: B`, because\n   *  `(A \u003d\u003e A) \u003c: (A \u003d\u003e B)`.\n   */\n  // $ to avoid accidental shadowing (e.g. scala/bug#7788)\n  implicit def $conforms[A]: A \u003d\u003e A \u003d \u003c:\u003c.refl\n}\n\n/** The `LowPriorityImplicits` class provides implicit values that\n*  are valid in all Scala compilation units without explicit qualification,\n*  but that are partially overridden by higher-priority conversions in object\n*  `Predef`.\n*/\n// scala/bug#7335 Parents of Predef are defined in the same compilation unit to avoid\n// cyclic reference errors compiling the standard library *without* a previously\n// compiled copy on the classpath.\nprivate[scala] abstract class LowPriorityImplicits extends LowPriorityImplicits2 {\n  import mutable.ArraySeq\n\n  /** We prefer the java.lang.* boxed types to these wrappers in\n   *  any potential conflicts.  Conflicts do exist because the wrappers\n   *  need to implement ScalaNumber in order to have a symmetric equals\n   *  method, but that implies implementing java.lang.Number as well.\n   *\n   *  Note - these are inlined because they are value classes, but\n   *  the call to xxxWrapper is not eliminated even though it does nothing.\n   *  Even inlined, every call site does a no-op retrieval of Predef\u0027s MODULE$\n   *  because maybe loading Predef has side effects!\n   */\n  @inline implicit def byteWrapper(x: Byte): runtime.RichByte          \u003d new runtime.RichByte(x)\n  @inline implicit def shortWrapper(x: Short): runtime.RichShort       \u003d new runtime.RichShort(x)\n  @inline implicit def intWrapper(x: Int): runtime.RichInt             \u003d new runtime.RichInt(x)\n  @inline implicit def charWrapper(c: Char): runtime.RichChar          \u003d new runtime.RichChar(c)\n  @inline implicit def longWrapper(x: Long): runtime.RichLong          \u003d new runtime.RichLong(x)\n  @inline implicit def floatWrapper(x: Float): runtime.RichFloat       \u003d new runtime.RichFloat(x)\n  @inline implicit def doubleWrapper(x: Double): runtime.RichDouble    \u003d new runtime.RichDouble(x)\n  @inline implicit def booleanWrapper(x: Boolean): runtime.RichBoolean \u003d new runtime.RichBoolean(x)\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def genericWrapArray[T](xs: Array[T]): ArraySeq[T] \u003d\n    if (xs eq null) null\n    else ArraySeq.make(xs)\n\n  // Since the JVM thinks arrays are covariant, one 0-length Array[AnyRef]\n  // is as good as another for all T \u003c: AnyRef.  Instead of creating 100,000,000\n  // unique ones by way of this implicit, let\u0027s share one.\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapRefArray[T \u003c: AnyRef](xs: Array[T]): ArraySeq.ofRef[T] \u003d {\n    if (xs eq null) null\n    else if (xs.length \u003d\u003d 0) ArraySeq.empty[AnyRef].asInstanceOf[ArraySeq.ofRef[T]]\n    else new ArraySeq.ofRef[T](xs)\n  }\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapIntArray(xs: Array[Int]): ArraySeq.ofInt \u003d if (xs ne null) new ArraySeq.ofInt(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapDoubleArray(xs: Array[Double]): ArraySeq.ofDouble \u003d if (xs ne null) new ArraySeq.ofDouble(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapLongArray(xs: Array[Long]): ArraySeq.ofLong \u003d if (xs ne null) new ArraySeq.ofLong(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapFloatArray(xs: Array[Float]): ArraySeq.ofFloat \u003d if (xs ne null) new ArraySeq.ofFloat(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapCharArray(xs: Array[Char]): ArraySeq.ofChar \u003d if (xs ne null) new ArraySeq.ofChar(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapByteArray(xs: Array[Byte]): ArraySeq.ofByte \u003d if (xs ne null) new ArraySeq.ofByte(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapShortArray(xs: Array[Short]): ArraySeq.ofShort \u003d if (xs ne null) new ArraySeq.ofShort(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapBooleanArray(xs: Array[Boolean]): ArraySeq.ofBoolean \u003d if (xs ne null) new ArraySeq.ofBoolean(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapUnitArray(xs: Array[Unit]): ArraySeq.ofUnit \u003d if (xs ne null) new ArraySeq.ofUnit(xs) else null\n\n  /** @group conversions-string */\n  implicit def wrapString(s: String): WrappedString \u003d if (s ne null) new WrappedString(s) else null\n}\n\nprivate[scala] abstract class LowPriorityImplicits2 {\n  @deprecated(\"implicit conversions from Array to immutable.IndexedSeq are implemented by copying; use `toIndexedSeq` explicitly if you want to copy, or use the more efficient non-copying ArraySeq.unsafeWrapArray\", since\u003d\"2.13.0\")\n  implicit def copyArrayToImmutableIndexedSeq[T](xs: Array[T]): IndexedSeq[T] \u003d\n    if (xs eq null) null\n    else new ArrayOps(xs).toIndexedSeq\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:05:49 INFO  compiling root (1 scala source)
2024.04.26 03:05:49 INFO  time: compiled root in 0.15s
2024.04.26 03:07:51 INFO  compiling root (1 scala source)
2024.04.26 03:07:51 INFO  time: compiled root in 0.17s
Apr. 26, 2024 3:08:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Predef.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:09:14 INFO  compiling root (1 scala source)
2024.04.26 03:09:14 INFO  time: compiled root in 86ms
2024.04.26 03:09:20 INFO  compiling root (1 scala source)
2024.04.26 03:09:20 INFO  time: compiled root in 0.17s
2024.04.26 03:10:04 INFO  compiling root (1 scala source)
2024.04.26 03:10:04 INFO  time: compiled root in 0.17s
2024.04.26 03:10:44 INFO  compiling root-test (3 scala sources)
2024.04.26 03:10:44 INFO  time: compiled root-test in 0.3s
2024.04.26 03:10:44 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 03:10:44 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 03:10:44 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 03:10:44 INFO  Loaded expression compiler in 0 milliseconds
2024.04.26 03:10:44 INFO  Loaded step filter in 0 milliseconds
2024.04.26 03:10:45 INFO  Loaded all sources and classes in 1 second
2024.04.26 03:10:45 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:56522 .
2024.04.26 03:10:45 INFO  Attaching to debuggee VM succeeded.
2024.04.26 03:11:46 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:11:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\npackage collection\npackage immutable\n\nimport scala.annotation.unchecked.uncheckedVariance\nimport scala.annotation.tailrec\nimport mutable.{Builder, ListBuffer}\nimport scala.collection.generic.DefaultSerializable\nimport scala.runtime.Statics.releaseFence\n\n/** A class for immutable linked lists representing ordered collections\n  *  of elements of type `A`.\n  *\n  *  This class comes with two implementing case classes `scala.Nil`\n  *  and `scala.::` that implement the abstract members `isEmpty`,\n  *  `head` and `tail`.\n  *\n  *  This class is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access\n  *  pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.\n  *\n  *  \u003d\u003dPerformance\u003d\u003d\n  *  \u0027\u0027\u0027Time:\u0027\u0027\u0027 `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list.\n  *  This includes the index-based lookup of elements, `length`, `append` and `reverse`.\n  *\n  *  \u0027\u0027\u0027Space:\u0027\u0027\u0027 `List` implements \u0027\u0027\u0027structural sharing\u0027\u0027\u0027 of the tail list. This means that many operations are either\n  *  zero- or constant-memory cost.\n  *  {{{\n  *  val mainList \u003d List(3, 2, 1)\n  *  val with4 \u003d    4 :: mainList  // re-uses mainList, costs one :: instance\n  *  val with42 \u003d   42 :: mainList // also re-uses mainList, cost one :: instance\n  *  val shorter \u003d  mainList.tail  // costs nothing as it uses the same 2::1::Nil instances as mainList\n  *  }}}\n  *\n  *  @example {{{\n  *  // Make a list via the companion object factory\n  *  val days \u003d List(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\")\n  *\n  *  // Make a list element-by-element\n  *  val when \u003d \"AM\" :: \"PM\" :: Nil\n  *\n  *  // Pattern match\n  *  days match {\n  *    case firstDay :: otherDays \u003d\u003e\n  *      println(\"The first day of the week is: \" + firstDay)\n  *    case Nil \u003d\u003e\n  *      println(\"There don\u0027t seem to be any week days.\")\n  *  }\n  *  }}}\n  *\n  *  @note The functional list is characterized by persistence and structural sharing, thus offering considerable\n  *        performance and space consumption benefits in some scenarios if used correctly.\n  *        However, note that objects having multiple references into the same functional list (that is,\n  *        objects that rely on structural sharing), will be serialized and deserialized with multiple lists, one for\n  *        each reference to it. I.e. structural sharing is lost after serialization/deserialization.\n  *\n  *  @see  [[https://docs.scala-lang.org/overviews/collections-2.13/concrete-immutable-collection-classes.html#lists \"Scala\u0027s Collection Library overview\"]]\n  *  section on `Lists` for more information.\n  *\n  *  @define coll list\n  *  @define Coll `List`\n  *  @define orderDependent\n  *  @define orderDependentFold\n  *  @define mayNotTerminateInf\n  *  @define willNotTerminateInf\n  */\n@SerialVersionUID(3L)\nsealed abstract class List[+A]\n  extends AbstractSeq[A]\n    with LinearSeq[A]\n    with LinearSeqOps[A, List, List[A]]\n    with StrictOptimizedLinearSeqOps[A, List, List[A]]\n    with StrictOptimizedSeqOps[A, List, List[A]]\n    with IterableFactoryDefaults[A, List]\n    with DefaultSerializable {\n\n  override def iterableFactory: SeqFactory[List] \u003d List\n\n  /** Adds an element at the beginning of this list.\n    *  @param elem the element to prepend.\n    *  @return  a list which contains `x` as first element and\n    *           which continues with this list.\n    *  Example:\n    *  {{{1 :: List(2, 3) \u003d List(2, 3).::(1) \u003d List(1, 2, 3)}}}\n    */\n  def :: [B \u003e: A](elem: B): List[B] \u003d  new ::(elem, this)\n\n  /** Adds the elements of a given list in front of this list.\n    *\n    * Example:\n    * {{{List(1, 2) ::: List(3, 4) \u003d List(3, 4).:::(List(1, 2)) \u003d List(1, 2, 3, 4)}}}\n    *\n    *  @param prefix  The list elements to prepend.\n    *  @return a list resulting from the concatenation of the given\n    *    list `prefix` and this list.\n    */\n  def ::: [B \u003e: A](prefix: List[B]): List[B] \u003d\n    if (isEmpty) prefix\n    else if (prefix.isEmpty) this\n    else {\n      val result \u003d new ::[B](prefix.head, this)\n      var curr \u003d result\n      var that \u003d prefix.tail\n      while (!that.isEmpty) {\n        val temp \u003d new ::[B](that.head, this)\n        curr.next \u003d temp\n        curr \u003d temp\n        that \u003d that.tail\n      }\n      releaseFence()\n      result\n    }\n\n  /** Adds the elements of a given list in reverse order in front of this list.\n    *  `xs reverse_::: ys` is equivalent to\n    *  `xs.reverse ::: ys` but is more efficient.\n    *\n    *  @param prefix the prefix to reverse and then prepend\n    *  @return       the concatenation of the reversed prefix and the current list.\n    */\n  def reverse_:::[B \u003e: A](prefix: List[B]): List[B] \u003d {\n    var these: List[B] \u003d this\n    var pres \u003d prefix\n    while (!pres.isEmpty) {\n      these \u003d pres.head :: these\n      pres \u003d pres.tail\n    }\n    these\n  }\n\n  override final def isEmpty: Boolean \u003d this eq Nil\n\n  override def prepended[B \u003e: A](elem: B): List[B] \u003d elem :: this\n\n  override def prependedAll[B \u003e: A](prefix: collection.IterableOnce[B]): List[B] \u003d prefix match {\n    case xs: List[B] \u003d\u003e xs ::: this\n    case _ if prefix.knownSize \u003d\u003d 0 \u003d\u003e this\n    case b: ListBuffer[B] if this.isEmpty \u003d\u003e b.toList\n    case _ \u003d\u003e\n      val iter \u003d prefix.iterator\n      if (iter.hasNext) {\n        val result \u003d new ::[B](iter.next(), this)\n        var curr \u003d result\n        while (iter.hasNext) {\n          val temp \u003d new ::[B](iter.next(), this)\n          curr.next \u003d temp\n          curr \u003d temp\n        }\n        releaseFence()\n        result\n      } else {\n        this\n      }\n  }\n\n  // When calling appendAll with another list `suffix`, avoid copying `suffix`\n  override def appendedAll[B \u003e: A](suffix: collection.IterableOnce[B]): List[B] \u003d suffix match {\n    case xs: List[B] \u003d\u003e this ::: xs\n    case _ \u003d\u003e super.appendedAll(suffix)\n  }\n\n  override def take(n: Int): List[A] \u003d if (isEmpty || n \u003c\u003d 0) Nil else {\n    val h \u003d new ::(head, Nil)\n    var t \u003d h\n    var rest \u003d tail\n    var i \u003d 1\n    while ({if (rest.isEmpty) return this; i \u003c n}) {\n      i +\u003d 1\n      val nx \u003d new ::(rest.head, Nil)\n      t.next \u003d nx\n      t \u003d nx\n      rest \u003d rest.tail\n    }\n    releaseFence()\n    h\n  }\n\n  /**\n    *  @example {{{\n    *  // Given a list\n    *  val letters \u003d List(\u0027a\u0027,\u0027b\u0027,\u0027c\u0027,\u0027d\u0027,\u0027e\u0027)\n    *\n    *  // `slice` returns all elements beginning at index `from` and afterwards,\n    *  // up until index `until` (excluding index `until`.)\n    *  letters.slice(1,3) // Returns List(\u0027b\u0027,\u0027c\u0027)\n    *  }}}\n    */\n  override def slice(from: Int, until: Int): List[A] \u003d {\n    val lo \u003d scala.math.max(from, 0)\n    if (until \u003c\u003d lo || isEmpty) Nil\n    else this drop lo take (until - lo)\n  }\n\n  override def takeRight(n: Int): List[A] \u003d {\n    @tailrec\n    def loop(lead: List[A], lag: List[A]): List[A] \u003d lead match {\n      case Nil \u003d\u003e lag\n      case _ :: tail \u003d\u003e loop(tail, lag.tail)\n    }\n    loop(drop(n), this)\n  }\n\n  // dropRight is inherited from LinearSeq\n\n  override def splitAt(n: Int): (List[A], List[A]) \u003d {\n    val b \u003d new ListBuffer[A]\n    var i \u003d 0\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 i \u003c n) {\n      i +\u003d 1\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    (b.toList, these)\n  }\n\n  override def updated[B \u003e: A](index: Int, elem: B): List[B] \u003d {\n    var i \u003d 0\n    var current \u003d this\n    val prefix \u003d ListBuffer.empty[B]\n    while (i \u003c index \u0026\u0026 current.nonEmpty) {\n      i +\u003d 1\n      prefix +\u003d current.head\n      current \u003d current.tail\n    }\n    if (i \u003d\u003d index \u0026\u0026 current.nonEmpty) {\n      prefix.prependToList(elem :: current.tail)\n    } else {\n      throw new IndexOutOfBoundsException(s\"$index is out of bounds (min 0, max ${length-1})\")\n    }\n  }\n\n  final override def map[B](f: A \u003d\u003e B): List[B] \u003d {\n    if (this eq Nil) Nil else {\n      val h \u003d new ::[B](f(head), Nil)\n      var t: ::[B] \u003d h\n      var rest \u003d tail\n      while (rest ne Nil) {\n        val nx \u003d new ::(f(rest.head), Nil)\n        t.next \u003d nx\n        t \u003d nx\n        rest \u003d rest.tail\n      }\n      releaseFence()\n      h\n    }\n  }\n\n  final override def collect[B](pf: PartialFunction[A, B]): List[B] \u003d {\n    if (this eq Nil) Nil else {\n      var rest \u003d this\n      var h: ::[B] \u003d null\n      var x: Any \u003d null\n      // Special case for first element\n      while (h eq null) {\n        x \u003d pf.applyOrElse(rest.head, List.partialNotApplied)\n        if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) h \u003d new ::(x.asInstanceOf[B], Nil)\n        rest \u003d rest.tail\n        if (rest eq Nil) return if (h eq null) Nil else h\n      }\n      var t \u003d h\n      // Remaining elements\n      while (rest ne Nil) {\n        x \u003d pf.applyOrElse(rest.head, List.partialNotApplied)\n        if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) {\n          val nx \u003d new ::(x.asInstanceOf[B], Nil)\n          t.next \u003d nx\n          t \u003d nx\n        }\n        rest \u003d rest.tail\n      }\n      releaseFence()\n      h\n    }\n  }\n\n  final override def flatMap[B](f: A \u003d\u003e IterableOnce[B]): List[B] \u003d {\n    var rest \u003d this\n    var h: ::[B] \u003d null\n    var t: ::[B] \u003d null\n    while (rest ne Nil) {\n      val it \u003d f(rest.head).iterator\n      while (it.hasNext) {\n        val nx \u003d new ::(it.next(), Nil)\n        if (t eq null) {\n          h \u003d nx\n        } else {\n          t.next \u003d nx\n        }\n        t \u003d nx\n      }\n      rest \u003d rest.tail\n    }\n    if (h eq null) Nil else {releaseFence(); h}\n  }\n\n  @inline final override def takeWhile(p: A \u003d\u003e Boolean): List[A] \u003d {\n    val b \u003d new ListBuffer[A]\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 p(these.head)) {\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    b.toList\n  }\n\n  @inline final override def span(p: A \u003d\u003e Boolean): (List[A], List[A]) \u003d {\n    val b \u003d new ListBuffer[A]\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 p(these.head)) {\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    (b.toList, these)\n  }\n\n  // Overridden with an implementation identical to the inherited one (at this time)\n  // solely so it can be finalized and thus inlinable.\n  @inline final override def foreach[U](f: A \u003d\u003e U): Unit \u003d {\n    var these \u003d this\n    while (!these.isEmpty) {\n      f(these.head)\n      these \u003d these.tail\n    }\n  }\n\n  final override def reverse: List[A] \u003d {\n    var result: List[A] \u003d Nil\n    var these \u003d this\n    while (!these.isEmpty) {\n      result \u003d these.head :: result\n      these \u003d these.tail\n    }\n    result\n  }\n\n  final override def foldRight[B](z: B)(op: (A, B) \u003d\u003e B): B \u003d {\n    var acc \u003d z\n    var these: List[A] \u003d reverse\n    while (!these.isEmpty) {\n      acc \u003d op(these.head, acc)\n      these \u003d these.tail\n    }\n    acc\n  }\n\n  // Copy/Paste overrides to avoid interface calls inside loops.\n\n  override final def length: Int \u003d {\n    var these \u003d this\n    var len \u003d 0\n    while (!these.isEmpty) {\n      len +\u003d 1\n      these \u003d these.tail\n    }\n    len\n  }\n\n  override final def lengthCompare(len: Int): Int \u003d {\n    @tailrec def loop(i: Int, xs: List[A]): Int \u003d {\n      if (i \u003d\u003d len)\n        if (xs.isEmpty) 0 else 1\n      else if (xs.isEmpty)\n        -1\n      else\n        loop(i + 1, xs.tail)\n    }\n    if (len \u003c 0) 1\n    else loop(0, coll)\n  }\n\n  override final def forall(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (!p(these.head)) return false\n      these \u003d these.tail\n    }\n    true\n  }\n\n  override final def exists(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (p(these.head)) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override final def contains[A1 \u003e: A](elem: A1): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (these.head \u003d\u003d elem) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override final def find(p: A \u003d\u003e Boolean): Option[A] \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (p(these.head)) return Some(these.head)\n      these \u003d these.tail\n    }\n    None\n  }\n\n  override def last: A \u003d {\n    if (isEmpty) throw new NoSuchElementException(\"List.last\")\n    else {\n      var these \u003d this\n      var scout \u003d tail\n      while (!scout.isEmpty) {\n        these \u003d scout\n        scout \u003d scout.tail\n      }\n      these.head\n    }\n  }\n\n  override def corresponds[B](that: collection.Seq[B])(p: (A, B) \u003d\u003e Boolean): Boolean \u003d that match {\n    case that: LinearSeq[B] \u003d\u003e\n      var i \u003d this\n      var j \u003d that\n      while (!(i.isEmpty || j.isEmpty)) {\n        if (!p(i.head, j.head))\n          return false\n        i \u003d i.tail\n        j \u003d j.tail\n      }\n      i.isEmpty \u0026\u0026 j.isEmpty\n    case _ \u003d\u003e\n      super.corresponds(that)(p)\n  }\n\n  override protected[this] def className \u003d \"List\"\n\n  /** Builds a new list by applying a function to all elements of this list.\n    *  Like `xs map f`, but returns `xs` unchanged if function\n    *  `f` maps all elements to themselves (as determined by `eq`).\n    *\n    *  @param f      the function to apply to each element.\n    *  @tparam B     the element type of the returned collection.\n    *  @return       a list resulting from applying the given function\n    *                `f` to each element of this list and collecting the results.\n    */\n  @`inline` final def mapConserve[B \u003e: A \u003c: AnyRef](f: A \u003d\u003e B): List[B] \u003d {\n    // Note to developers: there exists a duplication between this function and `reflect.internal.util.Collections#map2Conserve`.\n    // If any successful optimization attempts or other changes are made, please rehash them there too.\n    @tailrec\n    def loop(mappedHead: List[B], mappedLast: ::[B], unchanged: List[A], pending: List[A]): List[B] \u003d {\n      if (pending.isEmpty) {\n        if (mappedHead eq null) unchanged\n        else {\n          mappedLast.next \u003d (unchanged: List[B])\n          mappedHead\n        }\n      }\n      else {\n        val head0 \u003d pending.head\n        val head1 \u003d f(head0)\n\n        if (head1 eq head0.asInstanceOf[AnyRef])\n          loop(mappedHead, mappedLast, unchanged, pending.tail)\n        else {\n          var xc \u003d unchanged\n          var mappedHead1: List[B] \u003d mappedHead\n          var mappedLast1: ::[B] \u003d mappedLast\n          while (xc ne pending) {\n            val next \u003d new ::[B](xc.head, Nil)\n            if (mappedHead1 eq null) mappedHead1 \u003d next\n            if (mappedLast1 ne null) mappedLast1.next \u003d next\n            mappedLast1 \u003d next\n            xc \u003d xc.tail\n          }\n          val next \u003d new ::(head1, Nil)\n          if (mappedHead1 eq null) mappedHead1 \u003d next\n          if (mappedLast1 ne null) mappedLast1.next \u003d next\n          mappedLast1 \u003d next\n          val tail0 \u003d pending.tail\n          loop(mappedHead1, mappedLast1, tail0, tail0)\n\n        }\n      }\n    }\n    val result \u003d loop(null, null, this, this)\n    releaseFence()\n    result\n  }\n\n  override def filter(p: A \u003d\u003e Boolean): List[A] \u003d filterCommon(p, isFlipped \u003d false)\n\n  override def filterNot(p: A \u003d\u003e Boolean): List[A] \u003d filterCommon(p, isFlipped \u003d true)\n\n  private[this] def filterCommon(p: A \u003d\u003e Boolean, isFlipped: Boolean): List[A] \u003d {\n\n    // everything seen so far so far is not included\n    @tailrec def noneIn(l: List[A]): List[A] \u003d {\n      if (l.isEmpty)\n        Nil\n      else {\n        val h \u003d l.head\n        val t \u003d l.tail\n        if (p(h) !\u003d isFlipped)\n          allIn(l, t)\n        else\n          noneIn(t)\n      }\n    }\n\n    // everything from \u0027start\u0027 is included, if everything from this point is in we can return the origin\n    // start otherwise if we discover an element that is out we must create a new partial list.\n    @tailrec def allIn(start: List[A], remaining: List[A]): List[A] \u003d {\n      if (remaining.isEmpty)\n        start\n      else {\n        val x \u003d remaining.head\n        if (p(x) !\u003d isFlipped)\n          allIn(start, remaining.tail)\n        else\n          partialFill(start, remaining)\n      }\n    }\n\n    // we have seen elements that should be included then one that should be excluded, start building\n    def partialFill(origStart: List[A], firstMiss: List[A]): List[A] \u003d {\n      val newHead \u003d new ::(origStart.head, Nil)\n      var toProcess \u003d origStart.tail\n      var currentLast \u003d newHead\n\n      // we know that all elements are :: until at least firstMiss.tail\n      while (!(toProcess eq firstMiss)) {\n        val newElem \u003d new ::(toProcess.head, Nil)\n        currentLast.next \u003d newElem\n        currentLast \u003d newElem\n        toProcess \u003d toProcess.tail\n      }\n\n      // at this point newHead points to a list which is a duplicate of all the \u0027in\u0027 elements up to the first miss.\n      // currentLast is the last element in that list.\n\n      // now we are going to try and share as much of the tail as we can, only moving elements across when we have to.\n      var next \u003d firstMiss.tail\n      var nextToCopy \u003d next // the next element we would need to copy to our list if we cant share.\n      while (!next.isEmpty) {\n        // generally recommended is next.isNonEmpty but this incurs an extra method call.\n        val head: A \u003d next.head\n        if (p(head) !\u003d isFlipped) {\n          next \u003d next.tail\n        } else {\n          // its not a match - do we have outstanding elements?\n          while (!(nextToCopy eq next)) {\n            val newElem \u003d new ::(nextToCopy.head, Nil)\n            currentLast.next \u003d newElem\n            currentLast \u003d newElem\n            nextToCopy \u003d nextToCopy.tail\n          }\n          nextToCopy \u003d next.tail\n          next \u003d next.tail\n        }\n      }\n\n      // we have remaining elements - they are unchanged attach them to the end\n      if (!nextToCopy.isEmpty)\n        currentLast.next \u003d nextToCopy\n\n      newHead\n    }\n\n    val result \u003d noneIn(this)\n    releaseFence()\n    result\n  }\n\n  override def partition(p: A \u003d\u003e Boolean): (List[A], List[A]) \u003d {\n    if (isEmpty) List.TupleOfNil\n    else super.partition(p) match {\n      case (Nil, xs) \u003d\u003e (Nil, this)\n      case (xs, Nil) \u003d\u003e (this, Nil)\n      case pair \u003d\u003e pair\n    }\n  }\n\n  final override def toList: List[A] \u003d this\n\n  // Override for performance\n  override def equals(o: scala.Any): Boolean \u003d {\n    @tailrec def listEq(a: List[_], b: List[_]): Boolean \u003d\n      (a eq b) || {\n        val aEmpty \u003d a.isEmpty\n        val bEmpty \u003d b.isEmpty\n        if (!(aEmpty || bEmpty) \u0026\u0026 a.head \u003d\u003d b.head) {\n          listEq(a.tail, b.tail)\n        }\n        else {\n          aEmpty \u0026\u0026 bEmpty\n        }\n      }\n\n    o match {\n      case that: List[_] \u003d\u003e listEq(this, that)\n      case _ \u003d\u003e super.equals(o)\n    }\n  }\n\n  // TODO: uncomment once bincompat allows (reference: scala/scala#9365)\n  /*\n  // Override for performance: traverse only as much as needed\n  // and share tail when nothing needs to be filtered out anymore\n  override def diff[B \u003e: A](that: collection.Seq[B]): AnyRef \u003d {\n    if (that.isEmpty || this.isEmpty) this\n    else if (tail.isEmpty) if (that.contains(head)) Nil else this\n    else {\n      val occ \u003d occCounts(that)\n      val b \u003d new ListBuffer[A]()\n      @tailrec\n      def rec(remainder: List[A]): List[A] \u003d {\n        if(occ.isEmpty) b.prependToList(remainder)\n        else remainder match {\n          case Nil \u003d\u003e b.result()\n          case head :: next \u003d\u003e {\n            occ.updateWith(head){\n              case None \u003d\u003e {\n                b.append(head)\n                None\n              }\n              case Some(1) \u003d\u003e None\n              case Some(n) \u003d\u003e Some(n - 1)\n            }\n            rec(next)\n          }\n        }\n      }\n      rec(this)\n    }\n  }\n  */\n\n}\n\n// Internal code that mutates `next` _must_ call `Statics.releaseFence()` if either immediately, or\n// before a newly-allocated, thread-local :: instance is aliased (e.g. in ListBuffer.toList)\nfinal case class :: [+A](override val head: A, private[scala] var next: List[A @uncheckedVariance]) // sound because `next` is used only locally\n  extends List[A] {\n  releaseFence()\n  override def headOption: Some[A] \u003d Some(head)\n  override def tail: List[A] \u003d next\n}\n\ncase object Nil extends List[Nothing] {\n  override def head: Nothing \u003d throw new NoSuchElementException(\"head of empty list\")\n  override def headOption: None.type \u003d None\n  override def tail: Nothing \u003d throw new UnsupportedOperationException(\"tail of empty list\")\n  override def last: Nothing \u003d throw new NoSuchElementException(\"last of empty list\")\n  override def init: Nothing \u003d throw new UnsupportedOperationException(\"init of empty list\")\n  override def knownSize: Int \u003d 0\n  override def iterator: Iterator[Nothing] \u003d Iterator.empty\n  override def unzip[A1, A2](implicit asPair: Nothing \u003d\u003e (A1, A2)): (List[A1], List[A2]) \u003d EmptyUnzip\n\n  @transient\n  private[this] val EmptyUnzip \u003d (Nil, Nil)\n}\n\n/**\n  * $factoryInfo\n  * @define coll list\n  * @define Coll `List`\n  */\n@SerialVersionUID(3L)\nobject List extends StrictOptimizedSeqFactory[List] {\n  private val TupleOfNil \u003d (Nil, Nil)\n\n  def from[B](coll: collection.IterableOnce[B]): List[B] \u003d Nil.prependedAll(coll)\n\n  def newBuilder[A]: Builder[A, List[A]] \u003d new ListBuffer()\n\n  def empty[A]: List[A] \u003d Nil\n\n  @transient\n  private[collection] val partialNotApplied \u003d new Function1[Any, Any] { def apply(x: Any): Any \u003d this }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:11:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala"
  ]
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:639)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:11:46 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:493)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:11:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.Compilers.semanticTokens(Compilers.scala:482)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$semanticTokensFull$2(MetalsLspService.scala:1649)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 12 more

2024.04.26 03:11:46 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:391)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

2024.04.26 03:11:46 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:11:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1727)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1726)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 25 more

2024.04.26 03:11:46 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:408)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:11:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1511)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 13 more

2024.04.26 03:11:46 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:11:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1727)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1726)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 25 more

2024.04.26 03:11:46 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:478)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:11:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1717)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1716)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 13 more

2024.04.26 03:12:16 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java

Uri: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/Boolean.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.lang.constant.ConstantDescs;\nimport java.lang.constant.DynamicConstantDesc;\nimport java.util.Optional;\n\nimport static java.lang.constant.ConstantDescs.BSM_GET_STATIC_FINAL;\nimport static java.lang.constant.ConstantDescs.CD_Boolean;\n\n/**\n * The Boolean class wraps a value of the primitive type\n * {@code boolean} in an object. An object of type\n * {@code Boolean} contains a single field whose type is\n * {@code boolean}.\n *\n * \u003cp\u003eIn addition, this class provides many methods for\n * converting a {@code boolean} to a {@code String} and a\n * {@code String} to a {@code boolean}, as well as other\n * constants and methods useful when dealing with a\n * {@code boolean}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * @author  Arthur van Hoff\n * @since   1.0\n */\n@jdk.internal.ValueBased\npublic final class Boolean implements java.io.Serializable,\n                                      Comparable\u003cBoolean\u003e, Constable\n{\n    /**\n     * The {@code Boolean} object corresponding to the primitive\n     * value {@code true}.\n     */\n    public static final Boolean TRUE \u003d new Boolean(true);\n\n    /**\n     * The {@code Boolean} object corresponding to the primitive\n     * value {@code false}.\n     */\n    public static final Boolean FALSE \u003d new Boolean(false);\n\n    /**\n     * The Class object representing the primitive type boolean.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cBoolean\u003e TYPE \u003d (Class\u003cBoolean\u003e) Class.getPrimitiveClass(\"boolean\");\n\n    /**\n     * The value of the Boolean.\n     *\n     * @serial\n     */\n    private final boolean value;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -3665804199014368530L;\n\n    /**\n     * Allocates a {@code Boolean} object representing the\n     * {@code value} argument.\n     *\n     * @param   value   the value of the {@code Boolean}.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(boolean)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     * Also consider using the final fields {@link #TRUE} and {@link #FALSE}\n     * if possible.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Boolean(boolean value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Allocates a {@code Boolean} object representing the value\n     * {@code true} if the string argument is not {@code null}\n     * and is equal, ignoring case, to the string {@code \"true\"}.\n     * Otherwise, allocates a {@code Boolean} object representing the\n     * value {@code false}.\n     *\n     * @param   s   the string to be converted to a {@code Boolean}.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseBoolean(String)} to convert a string to a\n     * {@code boolean} primitive, or use {@link #valueOf(String)}\n     * to convert a string to a {@code Boolean} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Boolean(String s) {\n        this(parseBoolean(s));\n    }\n\n    /**\n     * Parses the string argument as a boolean.  The {@code boolean}\n     * returned represents the value {@code true} if the string argument\n     * is not {@code null} and is equal, ignoring case, to the string\n     * {@code \"true\"}.\n     * Otherwise, a false value is returned, including for a null\n     * argument.\u003cp\u003e\n     * Example: {@code Boolean.parseBoolean(\"True\")} returns {@code true}.\u003cbr\u003e\n     * Example: {@code Boolean.parseBoolean(\"yes\")} returns {@code false}.\n     *\n     * @param      s   the {@code String} containing the boolean\n     *                 representation to be parsed\n     * @return     the boolean represented by the string argument\n     * @since 1.5\n     */\n    public static boolean parseBoolean(String s) {\n        return \"true\".equalsIgnoreCase(s);\n    }\n\n    /**\n     * Returns the value of this {@code Boolean} object as a boolean\n     * primitive.\n     *\n     * @return  the primitive {@code boolean} value of this object.\n     */\n    @IntrinsicCandidate\n    public boolean booleanValue() {\n        return value;\n    }\n\n    /**\n     * Returns a {@code Boolean} instance representing the specified\n     * {@code boolean} value.  If the specified {@code boolean} value\n     * is {@code true}, this method returns {@code Boolean.TRUE};\n     * if it is {@code false}, this method returns {@code Boolean.FALSE}.\n     * If a new {@code Boolean} instance is not required, this method\n     * should generally be used in preference to the constructor\n     * {@link #Boolean(boolean)}, as this method is likely to yield\n     * significantly better space and time performance.\n     *\n     * @param  b a boolean value.\n     * @return a {@code Boolean} instance representing {@code b}.\n     * @since  1.4\n     */\n    @IntrinsicCandidate\n    public static Boolean valueOf(boolean b) {\n        return (b ? TRUE : FALSE);\n    }\n\n    /**\n     * Returns a {@code Boolean} with a value represented by the\n     * specified string.  The {@code Boolean} returned represents a\n     * true value if the string argument is not {@code null}\n     * and is equal, ignoring case, to the string {@code \"true\"}.\n     * Otherwise, a false value is returned, including for a null\n     * argument.\n     *\n     * @param   s   a string.\n     * @return  the {@code Boolean} value represented by the string.\n     */\n    public static Boolean valueOf(String s) {\n        return parseBoolean(s) ? TRUE : FALSE;\n    }\n\n    /**\n     * Returns a {@code String} object representing the specified\n     * boolean.  If the specified boolean is {@code true}, then\n     * the string {@code \"true\"} will be returned, otherwise the\n     * string {@code \"false\"} will be returned.\n     *\n     * @param b the boolean to be converted\n     * @return the string representation of the specified {@code boolean}\n     * @since 1.4\n     */\n    public static String toString(boolean b) {\n        return String.valueOf(b);\n    }\n\n    /**\n     * Returns a {@code String} object representing this Boolean\u0027s\n     * value.  If this object represents the value {@code true},\n     * a string equal to {@code \"true\"} is returned. Otherwise, a\n     * string equal to {@code \"false\"} is returned.\n     *\n     * @return  a string representation of this object.\n     */\n    @Override\n    public String toString() {\n        return String.valueOf(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Boolean} object.\n     *\n     * @return  the integer {@code 1231} if this object represents\n     * {@code true}; returns the integer {@code 1237} if this\n     * object represents {@code false}.\n     */\n    @Override\n    public int hashCode() {\n        return Boolean.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for a {@code boolean} value; compatible with\n     * {@code Boolean.hashCode()}.\n     *\n     * @param value the value to hash\n     * @return a hash code value for a {@code boolean} value.\n     * @since 1.8\n     */\n    public static int hashCode(boolean value) {\n        return value ? 1231 : 1237;\n    }\n\n    /**\n     * Returns {@code true} if and only if the argument is not\n     * {@code null} and is a {@code Boolean} object that\n     * represents the same {@code boolean} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the Boolean objects represent the\n     *          same value; {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Boolean) {\n            return value \u003d\u003d ((Boolean)obj).booleanValue();\n        }\n        return false;\n    }\n\n    /**\n     * Returns {@code true} if and only if the system property named\n     * by the argument exists and is equal to, ignoring case, the\n     * string {@code \"true\"}.\n     * A system property is accessible through {@code getProperty}, a\n     * method defined by the {@code System} class.  \u003cp\u003e If there is no\n     * property with the specified name, or if the specified name is\n     * empty or null, then {@code false} is returned.\n     *\n     * @param   name   the system property name.\n     * @return  the {@code boolean} value of the system property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static boolean getBoolean(String name) {\n        boolean result \u003d false;\n        try {\n            result \u003d parseBoolean(System.getProperty(name));\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        return result;\n    }\n\n    /**\n     * Compares this {@code Boolean} instance with another.\n     *\n     * @param   b the {@code Boolean} instance to be compared\n     * @return  zero if this object represents the same boolean value as the\n     *          argument; a positive value if this object represents true\n     *          and the argument represents false; and a negative value if\n     *          this object represents false and the argument represents true\n     * @throws  NullPointerException if the argument is {@code null}\n     * @see     Comparable\n     * @since  1.5\n     */\n    public int compareTo(Boolean b) {\n        return compare(this.value, b.value);\n    }\n\n    /**\n     * Compares two {@code boolean} values.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Boolean.valueOf(x).compareTo(Boolean.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code boolean} to compare\n     * @param  y the second {@code boolean} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code !x \u0026\u0026 y}; and\n     *         a value greater than {@code 0} if {@code x \u0026\u0026 !y}\n     * @since 1.7\n     */\n    public static int compare(boolean x, boolean y) {\n        return (x \u003d\u003d y) ? 0 : (x ? 1 : -1);\n    }\n\n    /**\n     * Returns the result of applying the logical AND operator to the\n     * specified {@code boolean} operands.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the logical AND of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static boolean logicalAnd(boolean a, boolean b) {\n        return a \u0026\u0026 b;\n    }\n\n    /**\n     * Returns the result of applying the logical OR operator to the\n     * specified {@code boolean} operands.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the logical OR of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static boolean logicalOr(boolean a, boolean b) {\n        return a || b;\n    }\n\n    /**\n     * Returns the result of applying the logical XOR operator to the\n     * specified {@code boolean} operands.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return  the logical XOR of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static boolean logicalXor(boolean a, boolean b) {\n        return a ^ b;\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance.\n     *\n     * @return an {@link Optional} describing the {@linkplain Boolean} instance\n     * @since 15\n     */\n    @Override\n    public Optional\u003cDynamicConstantDesc\u003cBoolean\u003e\u003e describeConstable() {\n        return Optional.of(value ? ConstantDescs.TRUE : ConstantDescs.FALSE);\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:12:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/Boolean.java"
  ]
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:639)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:12:16 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/Boolean.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:493)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.Compilers.semanticTokens(Compilers.scala:482)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$semanticTokensFull$2(MetalsLspService.scala:1649)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 12 more

2024.04.26 03:12:16 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/Boolean.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:391)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

2024.04.26 03:12:16 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/Boolean.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1727)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1726)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 25 more

2024.04.26 03:12:16 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/Boolean.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:408)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1511)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 13 more

2024.04.26 03:12:16 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/Boolean.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1727)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1726)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 25 more

2024.04.26 03:12:16 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/Boolean.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:478)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1717)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1716)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 13 more

Apr. 26, 2024 3:12:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala"
  ]
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:639)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:12:20 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:391)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

2024.04.26 03:12:20 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1727)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1726)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 25 more

2024.04.26 03:12:20 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:408)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1511)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 13 more

2024.04.26 03:12:20 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1727)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1726)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 25 more

2024.04.26 03:12:20 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:478)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1717)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1716)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 13 more

2024.04.26 03:12:20 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:493)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.Compilers.semanticTokens(Compilers.scala:482)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$semanticTokensFull$2(MetalsLspService.scala:1649)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 12 more

2024.04.26 03:12:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java

Uri: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serial;\nimport java.io.StreamCorruptedException;\n\n/**\n * A mutable sequence of characters.  This class provides an API compatible\n * with {@code StringBuffer}, but with no guarantee of synchronization.\n * This class is designed for use as a drop-in replacement for\n * {@code StringBuffer} in places where the string buffer was being\n * used by a single thread (as is generally the case).   Where possible,\n * it is recommended that this class be used in preference to\n * {@code StringBuffer} as it will be faster under most implementations.\n *\n * \u003cp\u003eThe principal operations on a {@code StringBuilder} are the\n * {@code append} and {@code insert} methods, which are\n * overloaded so as to accept data of any type. Each effectively\n * converts a given datum to a string and then appends or inserts the\n * characters of that string to the string builder. The\n * {@code append} method always adds these characters at the end\n * of the builder; the {@code insert} method adds the characters at\n * a specified point.\n * \u003cp\u003e\n * For example, if {@code z} refers to a string builder object\n * whose current contents are \"{@code start}\", then\n * the method call {@code z.append(\"le\")} would cause the string\n * builder to contain \"{@code startle}\", whereas\n * {@code z.insert(4, \"le\")} would alter the string builder to\n * contain \"{@code starlet}\".\n * \u003cp\u003e\n * In general, if sb refers to an instance of a {@code StringBuilder},\n * then {@code sb.append(x)} has the same effect as\n * {@code sb.insert(sb.length(), x)}.\n * \u003cp\u003e\n * Every string builder has a capacity. As long as the length of the\n * character sequence contained in the string builder does not exceed\n * the capacity, it is not necessary to allocate a new internal\n * buffer. If the internal buffer overflows, it is automatically made larger.\n *\n * \u003cp\u003eInstances of {@code StringBuilder} are not safe for\n * use by multiple threads. If such synchronization is required then it is\n * recommended that {@link java.lang.StringBuffer} be used.\n *\n * \u003cp\u003eUnless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * @apiNote\n * {@code StringBuilder} implements {@code Comparable} but does not override\n * {@link Object#equals equals}. Thus, the natural ordering of {@code StringBuilder}\n * is inconsistent with equals. Care should be exercised if {@code StringBuilder}\n * objects are used as keys in a {@code SortedMap} or elements in a {@code SortedSet}.\n * See {@link Comparable}, {@link java.util.SortedMap SortedMap}, or\n * {@link java.util.SortedSet SortedSet} for more information.\n *\n * @author      Michael McCloskey\n * @see         java.lang.StringBuffer\n * @see         java.lang.String\n * @since       1.5\n */\npublic final class StringBuilder\n    extends AbstractStringBuilder\n    implements java.io.Serializable, Comparable\u003cStringBuilder\u003e, CharSequence\n{\n\n    /** use serialVersionUID for interoperability */\n    @Serial\n    static final long serialVersionUID \u003d 4383685877147921099L;\n\n    /**\n     * Constructs a string builder with no characters in it and an\n     * initial capacity of 16 characters.\n     */\n    @IntrinsicCandidate\n    public StringBuilder() {\n        super(16);\n    }\n\n    /**\n     * Constructs a string builder with no characters in it and an\n     * initial capacity specified by the {@code capacity} argument.\n     *\n     * @param      capacity  the initial capacity.\n     * @throws     NegativeArraySizeException  if the {@code capacity}\n     *               argument is less than {@code 0}.\n     */\n    @IntrinsicCandidate\n    public StringBuilder(int capacity) {\n        super(capacity);\n    }\n\n    /**\n     * Constructs a string builder initialized to the contents of the\n     * specified string. The initial capacity of the string builder is\n     * {@code 16} plus the length of the string argument.\n     *\n     * @param   str   the initial contents of the buffer.\n     */\n    @IntrinsicCandidate\n    public StringBuilder(String str) {\n        super(str);\n    }\n\n    /**\n     * Constructs a string builder that contains the same characters\n     * as the specified {@code CharSequence}. The initial capacity of\n     * the string builder is {@code 16} plus the length of the\n     * {@code CharSequence} argument.\n     *\n     * @param      seq   the sequence to copy.\n     */\n    public StringBuilder(CharSequence seq) {\n        super(seq);\n    }\n\n    /**\n     * Compares two {@code StringBuilder} instances lexicographically. This method\n     * follows the same rules for lexicographical comparison as defined in the\n     * {@linkplain java.lang.CharSequence#compare(java.lang.CharSequence,\n     * java.lang.CharSequence)  CharSequence.compare(this, another)} method.\n     *\n     * \u003cp\u003e\n     * For finer-grained, locale-sensitive String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param another the {@code StringBuilder} to be compared with\n     *\n     * @return  the value {@code 0} if this {@code StringBuilder} contains the same\n     * character sequence as that of the argument {@code StringBuilder}; a negative integer\n     * if this {@code StringBuilder} is lexicographically less than the\n     * {@code StringBuilder} argument; or a positive integer if this {@code StringBuilder}\n     * is lexicographically greater than the {@code StringBuilder} argument.\n     *\n     * @since 11\n     */\n    @Override\n    public int compareTo(StringBuilder another) {\n        return super.compareTo(another);\n    }\n\n    @Override\n    public StringBuilder append(Object obj) {\n        return append(String.valueOf(obj));\n    }\n\n    @Override\n    @IntrinsicCandidate\n    public StringBuilder append(String str) {\n        super.append(str);\n        return this;\n    }\n\n    /**\n     * Appends the specified {@code StringBuffer} to this sequence.\n     * \u003cp\u003e\n     * The characters of the {@code StringBuffer} argument are appended,\n     * in order, to this sequence, increasing the\n     * length of this sequence by the length of the argument.\n     * If {@code sb} is {@code null}, then the four characters\n     * {@code \"null\"} are appended to this sequence.\n     * \u003cp\u003e\n     * Let \u003ci\u003en\u003c/i\u003e be the length of this character sequence just prior to\n     * execution of the {@code append} method. Then the character at index\n     * \u003ci\u003ek\u003c/i\u003e in the new character sequence is equal to the character at\n     * index \u003ci\u003ek\u003c/i\u003e in the old character sequence, if \u003ci\u003ek\u003c/i\u003e is less than\n     * \u003ci\u003en\u003c/i\u003e; otherwise, it is equal to the character at index \u003ci\u003ek-n\u003c/i\u003e\n     * in the argument {@code sb}.\n     *\n     * @param   sb   the {@code StringBuffer} to append.\n     * @return  a reference to this object.\n     */\n    public StringBuilder append(StringBuffer sb) {\n        super.append(sb);\n        return this;\n    }\n\n    @Override\n    public StringBuilder append(CharSequence s) {\n        super.append(s);\n        return this;\n    }\n\n    /**\n     * @throws     IndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder append(CharSequence s, int start, int end) {\n        super.append(s, start, end);\n        return this;\n    }\n\n    @Override\n    public StringBuilder append(char[] str) {\n        super.append(str);\n        return this;\n    }\n\n    /**\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder append(char[] str, int offset, int len) {\n        super.append(str, offset, len);\n        return this;\n    }\n\n    @Override\n    public StringBuilder append(boolean b) {\n        super.append(b);\n        return this;\n    }\n\n    @Override\n    @IntrinsicCandidate\n    public StringBuilder append(char c) {\n        super.append(c);\n        return this;\n    }\n\n    @Override\n    @IntrinsicCandidate\n    public StringBuilder append(int i) {\n        super.append(i);\n        return this;\n    }\n\n    @Override\n    public StringBuilder append(long lng) {\n        super.append(lng);\n        return this;\n    }\n\n    @Override\n    public StringBuilder append(float f) {\n        super.append(f);\n        return this;\n    }\n\n    @Override\n    public StringBuilder append(double d) {\n        super.append(d);\n        return this;\n    }\n\n    /**\n     * @since 1.5\n     */\n    @Override\n    public StringBuilder appendCodePoint(int codePoint) {\n        super.appendCodePoint(codePoint);\n        return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder delete(int start, int end) {\n        super.delete(start, end);\n        return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder deleteCharAt(int index) {\n        super.deleteCharAt(index);\n        return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder replace(int start, int end, String str) {\n        super.replace(start, end, str);\n        return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int index, char[] str, int offset,\n                                int len)\n    {\n        super.insert(index, str, offset, len);\n        return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int offset, Object obj) {\n            super.insert(offset, obj);\n            return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int offset, String str) {\n        super.insert(offset, str);\n        return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int offset, char[] str) {\n        super.insert(offset, str);\n        return this;\n    }\n\n    /**\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int dstOffset, CharSequence s) {\n            super.insert(dstOffset, s);\n            return this;\n    }\n\n    /**\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int dstOffset, CharSequence s,\n                                int start, int end)\n    {\n        super.insert(dstOffset, s, start, end);\n        return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int offset, boolean b) {\n        super.insert(offset, b);\n        return this;\n    }\n\n    /**\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int offset, char c) {\n        super.insert(offset, c);\n        return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int offset, int i) {\n        super.insert(offset, i);\n        return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int offset, long l) {\n        super.insert(offset, l);\n        return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int offset, float f) {\n        super.insert(offset, f);\n        return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int offset, double d) {\n        super.insert(offset, d);\n        return this;\n    }\n\n    @Override\n    public int indexOf(String str) {\n        return super.indexOf(str);\n    }\n\n    @Override\n    public int indexOf(String str, int fromIndex) {\n        return super.indexOf(str, fromIndex);\n    }\n\n    @Override\n    public int lastIndexOf(String str) {\n        return super.lastIndexOf(str);\n    }\n\n    @Override\n    public int lastIndexOf(String str, int fromIndex) {\n        return super.lastIndexOf(str, fromIndex);\n    }\n\n    @Override\n    public StringBuilder reverse() {\n        super.reverse();\n        return this;\n    }\n\n    @Override\n    @IntrinsicCandidate\n    public String toString() {\n        // Create a copy, don\u0027t share the array\n        return new String(this);\n    }\n\n    /**\n     * Save the state of the {@code StringBuilder} instance to a stream\n     * (that is, serialize it).\n     *\n     * @serialData the number of characters currently stored in the string\n     *             builder ({@code int}), followed by the characters in the\n     *             string builder ({@code char[]}).   The length of the\n     *             {@code char} array may be greater than the number of\n     *             characters currently stored in the string builder, in which\n     *             case extra characters are ignored.\n     *\n     * @param  s the {@code ObjectOutputStream} to which data is written\n     * @throws IOException if an I/O error occurs\n     */\n    @Serial\n    private void writeObject(ObjectOutputStream s) throws IOException {\n        s.defaultWriteObject();\n        s.writeInt(count);\n        char[] val \u003d new char[capacity()];\n        if (isLatin1()) {\n            StringLatin1.getChars(value, 0, count, val, 0);\n        } else {\n            StringUTF16.getChars(value, 0, count, val, 0);\n        }\n        s.writeObject(val);\n    }\n\n    /**\n     * readObject is called to restore the state of the StringBuilder from\n     * a stream.\n     *\n     * @param  s the {@code ObjectInputStream} from which data is read\n     * @throws IOException if an I/O error occurs\n     * @throws ClassNotFoundException if a serialized class cannot be loaded\n     */\n    @Serial\n    private void readObject(ObjectInputStream s)\n            throws IOException, ClassNotFoundException {\n        s.defaultReadObject();\n        int c \u003d s.readInt();\n        char[] val \u003d (char[]) s.readObject();\n        if (c \u003c 0 || c \u003e val.length) {\n            throw new StreamCorruptedException(\"count value invalid\");\n        }\n        initBytes(val, 0, val.length);\n        count \u003d c;\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:12:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java"
  ]
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:639)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:12:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:493)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.Compilers.semanticTokens(Compilers.scala:482)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$semanticTokensFull$2(MetalsLspService.scala:1649)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 12 more

2024.04.26 03:12:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:391)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

2024.04.26 03:12:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1727)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1726)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 25 more

2024.04.26 03:12:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:408)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1511)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 13 more

2024.04.26 03:12:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1727)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1726)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 25 more

2024.04.26 03:12:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:478)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:12:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1717)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1716)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 13 more

2024.04.26 03:13:27 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 03:13:27 INFO  Closing debug server tcp://0.0.0.0:56520
2024.04.26 03:14:00 INFO  compiling root-test (3 scala sources)
2024.04.26 03:14:00 INFO  time: compiled root-test in 0.21s
2024.04.26 03:14:00 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-server.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.04.26 03:14:00 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\.metals\dap-client.trace.json or C:\Users\Gewin Singh\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.04.26 03:14:00 INFO  Starting debug proxy for [Chess.ChessGame]
2024.04.26 03:14:00 INFO  Loaded expression compiler in 1 millisecond
2024.04.26 03:14:00 INFO  Loaded step filter in 0 milliseconds
2024.04.26 03:14:02 INFO  Loaded all sources and classes in 1 second
2024.04.26 03:14:02 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:56611 .
2024.04.26 03:14:02 INFO  Attaching to debuggee VM succeeded.
2024.04.26 03:14:09 ERROR Could not find any completions for the debugger
java.lang.Exception: No source data available
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$15(DebugProxy.scala:174)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$1(DebugProxy.scala:174)
	at scala.meta.internal.metals.debug.MessageIdAdapter.$anonfun$listen$1(MessageIdAdapter.scala:57)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at scala.meta.internal.metals.debug.SocketEndpoint.listen(SocketEndpoint.scala:26)
	at scala.meta.internal.metals.debug.MessageIdAdapter.listen(MessageIdAdapter.scala:47)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$listenToClient$1(DebugProxy.scala:81)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 03:14:11 ERROR Could not find any completions for the debugger
java.lang.Exception: No source data available
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$15(DebugProxy.scala:174)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$handleClientMessage$1(DebugProxy.scala:174)
	at scala.meta.internal.metals.debug.MessageIdAdapter.$anonfun$listen$1(MessageIdAdapter.scala:57)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at scala.meta.internal.metals.debug.SocketEndpoint.listen(SocketEndpoint.scala:26)
	at scala.meta.internal.metals.debug.MessageIdAdapter.listen(MessageIdAdapter.scala:47)
	at scala.meta.internal.metals.debug.DebugProxy.$anonfun$listenToClient$1(DebugProxy.scala:81)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

Apr. 26, 2024 3:14:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:15:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/Boolean.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/Boolean.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:15:29 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:15:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\npackage collection\npackage immutable\n\nimport scala.annotation.unchecked.uncheckedVariance\nimport scala.annotation.tailrec\nimport mutable.{Builder, ListBuffer}\nimport scala.collection.generic.DefaultSerializable\nimport scala.runtime.Statics.releaseFence\n\n/** A class for immutable linked lists representing ordered collections\n  *  of elements of type `A`.\n  *\n  *  This class comes with two implementing case classes `scala.Nil`\n  *  and `scala.::` that implement the abstract members `isEmpty`,\n  *  `head` and `tail`.\n  *\n  *  This class is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access\n  *  pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.\n  *\n  *  \u003d\u003dPerformance\u003d\u003d\n  *  \u0027\u0027\u0027Time:\u0027\u0027\u0027 `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list.\n  *  This includes the index-based lookup of elements, `length`, `append` and `reverse`.\n  *\n  *  \u0027\u0027\u0027Space:\u0027\u0027\u0027 `List` implements \u0027\u0027\u0027structural sharing\u0027\u0027\u0027 of the tail list. This means that many operations are either\n  *  zero- or constant-memory cost.\n  *  {{{\n  *  val mainList \u003d List(3, 2, 1)\n  *  val with4 \u003d    4 :: mainList  // re-uses mainList, costs one :: instance\n  *  val with42 \u003d   42 :: mainList // also re-uses mainList, cost one :: instance\n  *  val shorter \u003d  mainList.tail  // costs nothing as it uses the same 2::1::Nil instances as mainList\n  *  }}}\n  *\n  *  @example {{{\n  *  // Make a list via the companion object factory\n  *  val days \u003d List(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\")\n  *\n  *  // Make a list element-by-element\n  *  val when \u003d \"AM\" :: \"PM\" :: Nil\n  *\n  *  // Pattern match\n  *  days match {\n  *    case firstDay :: otherDays \u003d\u003e\n  *      println(\"The first day of the week is: \" + firstDay)\n  *    case Nil \u003d\u003e\n  *      println(\"There don\u0027t seem to be any week days.\")\n  *  }\n  *  }}}\n  *\n  *  @note The functional list is characterized by persistence and structural sharing, thus offering considerable\n  *        performance and space consumption benefits in some scenarios if used correctly.\n  *        However, note that objects having multiple references into the same functional list (that is,\n  *        objects that rely on structural sharing), will be serialized and deserialized with multiple lists, one for\n  *        each reference to it. I.e. structural sharing is lost after serialization/deserialization.\n  *\n  *  @see  [[https://docs.scala-lang.org/overviews/collections-2.13/concrete-immutable-collection-classes.html#lists \"Scala\u0027s Collection Library overview\"]]\n  *  section on `Lists` for more information.\n  *\n  *  @define coll list\n  *  @define Coll `List`\n  *  @define orderDependent\n  *  @define orderDependentFold\n  *  @define mayNotTerminateInf\n  *  @define willNotTerminateInf\n  */\n@SerialVersionUID(3L)\nsealed abstract class List[+A]\n  extends AbstractSeq[A]\n    with LinearSeq[A]\n    with LinearSeqOps[A, List, List[A]]\n    with StrictOptimizedLinearSeqOps[A, List, List[A]]\n    with StrictOptimizedSeqOps[A, List, List[A]]\n    with IterableFactoryDefaults[A, List]\n    with DefaultSerializable {\n\n  override def iterableFactory: SeqFactory[List] \u003d List\n\n  /** Adds an element at the beginning of this list.\n    *  @param elem the element to prepend.\n    *  @return  a list which contains `x` as first element and\n    *           which continues with this list.\n    *  Example:\n    *  {{{1 :: List(2, 3) \u003d List(2, 3).::(1) \u003d List(1, 2, 3)}}}\n    */\n  def :: [B \u003e: A](elem: B): List[B] \u003d  new ::(elem, this)\n\n  /** Adds the elements of a given list in front of this list.\n    *\n    * Example:\n    * {{{List(1, 2) ::: List(3, 4) \u003d List(3, 4).:::(List(1, 2)) \u003d List(1, 2, 3, 4)}}}\n    *\n    *  @param prefix  The list elements to prepend.\n    *  @return a list resulting from the concatenation of the given\n    *    list `prefix` and this list.\n    */\n  def ::: [B \u003e: A](prefix: List[B]): List[B] \u003d\n    if (isEmpty) prefix\n    else if (prefix.isEmpty) this\n    else {\n      val result \u003d new ::[B](prefix.head, this)\n      var curr \u003d result\n      var that \u003d prefix.tail\n      while (!that.isEmpty) {\n        val temp \u003d new ::[B](that.head, this)\n        curr.next \u003d temp\n        curr \u003d temp\n        that \u003d that.tail\n      }\n      releaseFence()\n      result\n    }\n\n  /** Adds the elements of a given list in reverse order in front of this list.\n    *  `xs reverse_::: ys` is equivalent to\n    *  `xs.reverse ::: ys` but is more efficient.\n    *\n    *  @param prefix the prefix to reverse and then prepend\n    *  @return       the concatenation of the reversed prefix and the current list.\n    */\n  def reverse_:::[B \u003e: A](prefix: List[B]): List[B] \u003d {\n    var these: List[B] \u003d this\n    var pres \u003d prefix\n    while (!pres.isEmpty) {\n      these \u003d pres.head :: these\n      pres \u003d pres.tail\n    }\n    these\n  }\n\n  override final def isEmpty: Boolean \u003d this eq Nil\n\n  override def prepended[B \u003e: A](elem: B): List[B] \u003d elem :: this\n\n  override def prependedAll[B \u003e: A](prefix: collection.IterableOnce[B]): List[B] \u003d prefix match {\n    case xs: List[B] \u003d\u003e xs ::: this\n    case _ if prefix.knownSize \u003d\u003d 0 \u003d\u003e this\n    case b: ListBuffer[B] if this.isEmpty \u003d\u003e b.toList\n    case _ \u003d\u003e\n      val iter \u003d prefix.iterator\n      if (iter.hasNext) {\n        val result \u003d new ::[B](iter.next(), this)\n        var curr \u003d result\n        while (iter.hasNext) {\n          val temp \u003d new ::[B](iter.next(), this)\n          curr.next \u003d temp\n          curr \u003d temp\n        }\n        releaseFence()\n        result\n      } else {\n        this\n      }\n  }\n\n  // When calling appendAll with another list `suffix`, avoid copying `suffix`\n  override def appendedAll[B \u003e: A](suffix: collection.IterableOnce[B]): List[B] \u003d suffix match {\n    case xs: List[B] \u003d\u003e this ::: xs\n    case _ \u003d\u003e super.appendedAll(suffix)\n  }\n\n  override def take(n: Int): List[A] \u003d if (isEmpty || n \u003c\u003d 0) Nil else {\n    val h \u003d new ::(head, Nil)\n    var t \u003d h\n    var rest \u003d tail\n    var i \u003d 1\n    while ({if (rest.isEmpty) return this; i \u003c n}) {\n      i +\u003d 1\n      val nx \u003d new ::(rest.head, Nil)\n      t.next \u003d nx\n      t \u003d nx\n      rest \u003d rest.tail\n    }\n    releaseFence()\n    h\n  }\n\n  /**\n    *  @example {{{\n    *  // Given a list\n    *  val letters \u003d List(\u0027a\u0027,\u0027b\u0027,\u0027c\u0027,\u0027d\u0027,\u0027e\u0027)\n    *\n    *  // `slice` returns all elements beginning at index `from` and afterwards,\n    *  // up until index `until` (excluding index `until`.)\n    *  letters.slice(1,3) // Returns List(\u0027b\u0027,\u0027c\u0027)\n    *  }}}\n    */\n  override def slice(from: Int, until: Int): List[A] \u003d {\n    val lo \u003d scala.math.max(from, 0)\n    if (until \u003c\u003d lo || isEmpty) Nil\n    else this drop lo take (until - lo)\n  }\n\n  override def takeRight(n: Int): List[A] \u003d {\n    @tailrec\n    def loop(lead: List[A], lag: List[A]): List[A] \u003d lead match {\n      case Nil \u003d\u003e lag\n      case _ :: tail \u003d\u003e loop(tail, lag.tail)\n    }\n    loop(drop(n), this)\n  }\n\n  // dropRight is inherited from LinearSeq\n\n  override def splitAt(n: Int): (List[A], List[A]) \u003d {\n    val b \u003d new ListBuffer[A]\n    var i \u003d 0\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 i \u003c n) {\n      i +\u003d 1\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    (b.toList, these)\n  }\n\n  override def updated[B \u003e: A](index: Int, elem: B): List[B] \u003d {\n    var i \u003d 0\n    var current \u003d this\n    val prefix \u003d ListBuffer.empty[B]\n    while (i \u003c index \u0026\u0026 current.nonEmpty) {\n      i +\u003d 1\n      prefix +\u003d current.head\n      current \u003d current.tail\n    }\n    if (i \u003d\u003d index \u0026\u0026 current.nonEmpty) {\n      prefix.prependToList(elem :: current.tail)\n    } else {\n      throw new IndexOutOfBoundsException(s\"$index is out of bounds (min 0, max ${length-1})\")\n    }\n  }\n\n  final override def map[B](f: A \u003d\u003e B): List[B] \u003d {\n    if (this eq Nil) Nil else {\n      val h \u003d new ::[B](f(head), Nil)\n      var t: ::[B] \u003d h\n      var rest \u003d tail\n      while (rest ne Nil) {\n        val nx \u003d new ::(f(rest.head), Nil)\n        t.next \u003d nx\n        t \u003d nx\n        rest \u003d rest.tail\n      }\n      releaseFence()\n      h\n    }\n  }\n\n  final override def collect[B](pf: PartialFunction[A, B]): List[B] \u003d {\n    if (this eq Nil) Nil else {\n      var rest \u003d this\n      var h: ::[B] \u003d null\n      var x: Any \u003d null\n      // Special case for first element\n      while (h eq null) {\n        x \u003d pf.applyOrElse(rest.head, List.partialNotApplied)\n        if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) h \u003d new ::(x.asInstanceOf[B], Nil)\n        rest \u003d rest.tail\n        if (rest eq Nil) return if (h eq null) Nil else h\n      }\n      var t \u003d h\n      // Remaining elements\n      while (rest ne Nil) {\n        x \u003d pf.applyOrElse(rest.head, List.partialNotApplied)\n        if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) {\n          val nx \u003d new ::(x.asInstanceOf[B], Nil)\n          t.next \u003d nx\n          t \u003d nx\n        }\n        rest \u003d rest.tail\n      }\n      releaseFence()\n      h\n    }\n  }\n\n  final override def flatMap[B](f: A \u003d\u003e IterableOnce[B]): List[B] \u003d {\n    var rest \u003d this\n    var h: ::[B] \u003d null\n    var t: ::[B] \u003d null\n    while (rest ne Nil) {\n      val it \u003d f(rest.head).iterator\n      while (it.hasNext) {\n        val nx \u003d new ::(it.next(), Nil)\n        if (t eq null) {\n          h \u003d nx\n        } else {\n          t.next \u003d nx\n        }\n        t \u003d nx\n      }\n      rest \u003d rest.tail\n    }\n    if (h eq null) Nil else {releaseFence(); h}\n  }\n\n  @inline final override def takeWhile(p: A \u003d\u003e Boolean): List[A] \u003d {\n    val b \u003d new ListBuffer[A]\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 p(these.head)) {\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    b.toList\n  }\n\n  @inline final override def span(p: A \u003d\u003e Boolean): (List[A], List[A]) \u003d {\n    val b \u003d new ListBuffer[A]\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 p(these.head)) {\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    (b.toList, these)\n  }\n\n  // Overridden with an implementation identical to the inherited one (at this time)\n  // solely so it can be finalized and thus inlinable.\n  @inline final override def foreach[U](f: A \u003d\u003e U): Unit \u003d {\n    var these \u003d this\n    while (!these.isEmpty) {\n      f(these.head)\n      these \u003d these.tail\n    }\n  }\n\n  final override def reverse: List[A] \u003d {\n    var result: List[A] \u003d Nil\n    var these \u003d this\n    while (!these.isEmpty) {\n      result \u003d these.head :: result\n      these \u003d these.tail\n    }\n    result\n  }\n\n  final override def foldRight[B](z: B)(op: (A, B) \u003d\u003e B): B \u003d {\n    var acc \u003d z\n    var these: List[A] \u003d reverse\n    while (!these.isEmpty) {\n      acc \u003d op(these.head, acc)\n      these \u003d these.tail\n    }\n    acc\n  }\n\n  // Copy/Paste overrides to avoid interface calls inside loops.\n\n  override final def length: Int \u003d {\n    var these \u003d this\n    var len \u003d 0\n    while (!these.isEmpty) {\n      len +\u003d 1\n      these \u003d these.tail\n    }\n    len\n  }\n\n  override final def lengthCompare(len: Int): Int \u003d {\n    @tailrec def loop(i: Int, xs: List[A]): Int \u003d {\n      if (i \u003d\u003d len)\n        if (xs.isEmpty) 0 else 1\n      else if (xs.isEmpty)\n        -1\n      else\n        loop(i + 1, xs.tail)\n    }\n    if (len \u003c 0) 1\n    else loop(0, coll)\n  }\n\n  override final def forall(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (!p(these.head)) return false\n      these \u003d these.tail\n    }\n    true\n  }\n\n  override final def exists(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (p(these.head)) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override final def contains[A1 \u003e: A](elem: A1): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (these.head \u003d\u003d elem) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override final def find(p: A \u003d\u003e Boolean): Option[A] \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (p(these.head)) return Some(these.head)\n      these \u003d these.tail\n    }\n    None\n  }\n\n  override def last: A \u003d {\n    if (isEmpty) throw new NoSuchElementException(\"List.last\")\n    else {\n      var these \u003d this\n      var scout \u003d tail\n      while (!scout.isEmpty) {\n        these \u003d scout\n        scout \u003d scout.tail\n      }\n      these.head\n    }\n  }\n\n  override def corresponds[B](that: collection.Seq[B])(p: (A, B) \u003d\u003e Boolean): Boolean \u003d that match {\n    case that: LinearSeq[B] \u003d\u003e\n      var i \u003d this\n      var j \u003d that\n      while (!(i.isEmpty || j.isEmpty)) {\n        if (!p(i.head, j.head))\n          return false\n        i \u003d i.tail\n        j \u003d j.tail\n      }\n      i.isEmpty \u0026\u0026 j.isEmpty\n    case _ \u003d\u003e\n      super.corresponds(that)(p)\n  }\n\n  override protected[this] def className \u003d \"List\"\n\n  /** Builds a new list by applying a function to all elements of this list.\n    *  Like `xs map f`, but returns `xs` unchanged if function\n    *  `f` maps all elements to themselves (as determined by `eq`).\n    *\n    *  @param f      the function to apply to each element.\n    *  @tparam B     the element type of the returned collection.\n    *  @return       a list resulting from applying the given function\n    *                `f` to each element of this list and collecting the results.\n    */\n  @`inline` final def mapConserve[B \u003e: A \u003c: AnyRef](f: A \u003d\u003e B): List[B] \u003d {\n    // Note to developers: there exists a duplication between this function and `reflect.internal.util.Collections#map2Conserve`.\n    // If any successful optimization attempts or other changes are made, please rehash them there too.\n    @tailrec\n    def loop(mappedHead: List[B], mappedLast: ::[B], unchanged: List[A], pending: List[A]): List[B] \u003d {\n      if (pending.isEmpty) {\n        if (mappedHead eq null) unchanged\n        else {\n          mappedLast.next \u003d (unchanged: List[B])\n          mappedHead\n        }\n      }\n      else {\n        val head0 \u003d pending.head\n        val head1 \u003d f(head0)\n\n        if (head1 eq head0.asInstanceOf[AnyRef])\n          loop(mappedHead, mappedLast, unchanged, pending.tail)\n        else {\n          var xc \u003d unchanged\n          var mappedHead1: List[B] \u003d mappedHead\n          var mappedLast1: ::[B] \u003d mappedLast\n          while (xc ne pending) {\n            val next \u003d new ::[B](xc.head, Nil)\n            if (mappedHead1 eq null) mappedHead1 \u003d next\n            if (mappedLast1 ne null) mappedLast1.next \u003d next\n            mappedLast1 \u003d next\n            xc \u003d xc.tail\n          }\n          val next \u003d new ::(head1, Nil)\n          if (mappedHead1 eq null) mappedHead1 \u003d next\n          if (mappedLast1 ne null) mappedLast1.next \u003d next\n          mappedLast1 \u003d next\n          val tail0 \u003d pending.tail\n          loop(mappedHead1, mappedLast1, tail0, tail0)\n\n        }\n      }\n    }\n    val result \u003d loop(null, null, this, this)\n    releaseFence()\n    result\n  }\n\n  override def filter(p: A \u003d\u003e Boolean): List[A] \u003d filterCommon(p, isFlipped \u003d false)\n\n  override def filterNot(p: A \u003d\u003e Boolean): List[A] \u003d filterCommon(p, isFlipped \u003d true)\n\n  private[this] def filterCommon(p: A \u003d\u003e Boolean, isFlipped: Boolean): List[A] \u003d {\n\n    // everything seen so far so far is not included\n    @tailrec def noneIn(l: List[A]): List[A] \u003d {\n      if (l.isEmpty)\n        Nil\n      else {\n        val h \u003d l.head\n        val t \u003d l.tail\n        if (p(h) !\u003d isFlipped)\n          allIn(l, t)\n        else\n          noneIn(t)\n      }\n    }\n\n    // everything from \u0027start\u0027 is included, if everything from this point is in we can return the origin\n    // start otherwise if we discover an element that is out we must create a new partial list.\n    @tailrec def allIn(start: List[A], remaining: List[A]): List[A] \u003d {\n      if (remaining.isEmpty)\n        start\n      else {\n        val x \u003d remaining.head\n        if (p(x) !\u003d isFlipped)\n          allIn(start, remaining.tail)\n        else\n          partialFill(start, remaining)\n      }\n    }\n\n    // we have seen elements that should be included then one that should be excluded, start building\n    def partialFill(origStart: List[A], firstMiss: List[A]): List[A] \u003d {\n      val newHead \u003d new ::(origStart.head, Nil)\n      var toProcess \u003d origStart.tail\n      var currentLast \u003d newHead\n\n      // we know that all elements are :: until at least firstMiss.tail\n      while (!(toProcess eq firstMiss)) {\n        val newElem \u003d new ::(toProcess.head, Nil)\n        currentLast.next \u003d newElem\n        currentLast \u003d newElem\n        toProcess \u003d toProcess.tail\n      }\n\n      // at this point newHead points to a list which is a duplicate of all the \u0027in\u0027 elements up to the first miss.\n      // currentLast is the last element in that list.\n\n      // now we are going to try and share as much of the tail as we can, only moving elements across when we have to.\n      var next \u003d firstMiss.tail\n      var nextToCopy \u003d next // the next element we would need to copy to our list if we cant share.\n      while (!next.isEmpty) {\n        // generally recommended is next.isNonEmpty but this incurs an extra method call.\n        val head: A \u003d next.head\n        if (p(head) !\u003d isFlipped) {\n          next \u003d next.tail\n        } else {\n          // its not a match - do we have outstanding elements?\n          while (!(nextToCopy eq next)) {\n            val newElem \u003d new ::(nextToCopy.head, Nil)\n            currentLast.next \u003d newElem\n            currentLast \u003d newElem\n            nextToCopy \u003d nextToCopy.tail\n          }\n          nextToCopy \u003d next.tail\n          next \u003d next.tail\n        }\n      }\n\n      // we have remaining elements - they are unchanged attach them to the end\n      if (!nextToCopy.isEmpty)\n        currentLast.next \u003d nextToCopy\n\n      newHead\n    }\n\n    val result \u003d noneIn(this)\n    releaseFence()\n    result\n  }\n\n  override def partition(p: A \u003d\u003e Boolean): (List[A], List[A]) \u003d {\n    if (isEmpty) List.TupleOfNil\n    else super.partition(p) match {\n      case (Nil, xs) \u003d\u003e (Nil, this)\n      case (xs, Nil) \u003d\u003e (this, Nil)\n      case pair \u003d\u003e pair\n    }\n  }\n\n  final override def toList: List[A] \u003d this\n\n  // Override for performance\n  override def equals(o: scala.Any): Boolean \u003d {\n    @tailrec def listEq(a: List[_], b: List[_]): Boolean \u003d\n      (a eq b) || {\n        val aEmpty \u003d a.isEmpty\n        val bEmpty \u003d b.isEmpty\n        if (!(aEmpty || bEmpty) \u0026\u0026 a.head \u003d\u003d b.head) {\n          listEq(a.tail, b.tail)\n        }\n        else {\n          aEmpty \u0026\u0026 bEmpty\n        }\n      }\n\n    o match {\n      case that: List[_] \u003d\u003e listEq(this, that)\n      case _ \u003d\u003e super.equals(o)\n    }\n  }\n\n  // TODO: uncomment once bincompat allows (reference: scala/scala#9365)\n  /*\n  // Override for performance: traverse only as much as needed\n  // and share tail when nothing needs to be filtered out anymore\n  override def diff[B \u003e: A](that: collection.Seq[B]): AnyRef \u003d {\n    if (that.isEmpty || this.isEmpty) this\n    else if (tail.isEmpty) if (that.contains(head)) Nil else this\n    else {\n      val occ \u003d occCounts(that)\n      val b \u003d new ListBuffer[A]()\n      @tailrec\n      def rec(remainder: List[A]): List[A] \u003d {\n        if(occ.isEmpty) b.prependToList(remainder)\n        else remainder match {\n          case Nil \u003d\u003e b.result()\n          case head :: next \u003d\u003e {\n            occ.updateWith(head){\n              case None \u003d\u003e {\n                b.append(head)\n                None\n              }\n              case Some(1) \u003d\u003e None\n              case Some(n) \u003d\u003e Some(n - 1)\n            }\n            rec(next)\n          }\n        }\n      }\n      rec(this)\n    }\n  }\n  */\n\n}\n\n// Internal code that mutates `next` _must_ call `Statics.releaseFence()` if either immediately, or\n// before a newly-allocated, thread-local :: instance is aliased (e.g. in ListBuffer.toList)\nfinal case class :: [+A](override val head: A, private[scala] var next: List[A @uncheckedVariance]) // sound because `next` is used only locally\n  extends List[A] {\n  releaseFence()\n  override def headOption: Some[A] \u003d Some(head)\n  override def tail: List[A] \u003d next\n}\n\ncase object Nil extends List[Nothing] {\n  override def head: Nothing \u003d throw new NoSuchElementException(\"head of empty list\")\n  override def headOption: None.type \u003d None\n  override def tail: Nothing \u003d throw new UnsupportedOperationException(\"tail of empty list\")\n  override def last: Nothing \u003d throw new NoSuchElementException(\"last of empty list\")\n  override def init: Nothing \u003d throw new UnsupportedOperationException(\"init of empty list\")\n  override def knownSize: Int \u003d 0\n  override def iterator: Iterator[Nothing] \u003d Iterator.empty\n  override def unzip[A1, A2](implicit asPair: Nothing \u003d\u003e (A1, A2)): (List[A1], List[A2]) \u003d EmptyUnzip\n\n  @transient\n  private[this] val EmptyUnzip \u003d (Nil, Nil)\n}\n\n/**\n  * $factoryInfo\n  * @define coll list\n  * @define Coll `List`\n  */\n@SerialVersionUID(3L)\nobject List extends StrictOptimizedSeqFactory[List] {\n  private val TupleOfNil \u003d (Nil, Nil)\n\n  def from[B](coll: collection.IterableOnce[B]): List[B] \u003d Nil.prependedAll(coll)\n\n  def newBuilder[A]: Builder[A, List[A]] \u003d new ListBuffer()\n\n  def empty[A]: List[A] \u003d Nil\n\n  @transient\n  private[collection] val partialNotApplied \u003d new Function1[Any, Any] { def apply(x: Any): Any \u003d this }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:15:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:15:29 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:15:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\npackage collection\npackage immutable\n\nimport scala.annotation.unchecked.uncheckedVariance\nimport scala.annotation.tailrec\nimport mutable.{Builder, ListBuffer}\nimport scala.collection.generic.DefaultSerializable\nimport scala.runtime.Statics.releaseFence\n\n/** A class for immutable linked lists representing ordered collections\n  *  of elements of type `A`.\n  *\n  *  This class comes with two implementing case classes `scala.Nil`\n  *  and `scala.::` that implement the abstract members `isEmpty`,\n  *  `head` and `tail`.\n  *\n  *  This class is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access\n  *  pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.\n  *\n  *  \u003d\u003dPerformance\u003d\u003d\n  *  \u0027\u0027\u0027Time:\u0027\u0027\u0027 `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list.\n  *  This includes the index-based lookup of elements, `length`, `append` and `reverse`.\n  *\n  *  \u0027\u0027\u0027Space:\u0027\u0027\u0027 `List` implements \u0027\u0027\u0027structural sharing\u0027\u0027\u0027 of the tail list. This means that many operations are either\n  *  zero- or constant-memory cost.\n  *  {{{\n  *  val mainList \u003d List(3, 2, 1)\n  *  val with4 \u003d    4 :: mainList  // re-uses mainList, costs one :: instance\n  *  val with42 \u003d   42 :: mainList // also re-uses mainList, cost one :: instance\n  *  val shorter \u003d  mainList.tail  // costs nothing as it uses the same 2::1::Nil instances as mainList\n  *  }}}\n  *\n  *  @example {{{\n  *  // Make a list via the companion object factory\n  *  val days \u003d List(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\")\n  *\n  *  // Make a list element-by-element\n  *  val when \u003d \"AM\" :: \"PM\" :: Nil\n  *\n  *  // Pattern match\n  *  days match {\n  *    case firstDay :: otherDays \u003d\u003e\n  *      println(\"The first day of the week is: \" + firstDay)\n  *    case Nil \u003d\u003e\n  *      println(\"There don\u0027t seem to be any week days.\")\n  *  }\n  *  }}}\n  *\n  *  @note The functional list is characterized by persistence and structural sharing, thus offering considerable\n  *        performance and space consumption benefits in some scenarios if used correctly.\n  *        However, note that objects having multiple references into the same functional list (that is,\n  *        objects that rely on structural sharing), will be serialized and deserialized with multiple lists, one for\n  *        each reference to it. I.e. structural sharing is lost after serialization/deserialization.\n  *\n  *  @see  [[https://docs.scala-lang.org/overviews/collections-2.13/concrete-immutable-collection-classes.html#lists \"Scala\u0027s Collection Library overview\"]]\n  *  section on `Lists` for more information.\n  *\n  *  @define coll list\n  *  @define Coll `List`\n  *  @define orderDependent\n  *  @define orderDependentFold\n  *  @define mayNotTerminateInf\n  *  @define willNotTerminateInf\n  */\n@SerialVersionUID(3L)\nsealed abstract class List[+A]\n  extends AbstractSeq[A]\n    with LinearSeq[A]\n    with LinearSeqOps[A, List, List[A]]\n    with StrictOptimizedLinearSeqOps[A, List, List[A]]\n    with StrictOptimizedSeqOps[A, List, List[A]]\n    with IterableFactoryDefaults[A, List]\n    with DefaultSerializable {\n\n  override def iterableFactory: SeqFactory[List] \u003d List\n\n  /** Adds an element at the beginning of this list.\n    *  @param elem the element to prepend.\n    *  @return  a list which contains `x` as first element and\n    *           which continues with this list.\n    *  Example:\n    *  {{{1 :: List(2, 3) \u003d List(2, 3).::(1) \u003d List(1, 2, 3)}}}\n    */\n  def :: [B \u003e: A](elem: B): List[B] \u003d  new ::(elem, this)\n\n  /** Adds the elements of a given list in front of this list.\n    *\n    * Example:\n    * {{{List(1, 2) ::: List(3, 4) \u003d List(3, 4).:::(List(1, 2)) \u003d List(1, 2, 3, 4)}}}\n    *\n    *  @param prefix  The list elements to prepend.\n    *  @return a list resulting from the concatenation of the given\n    *    list `prefix` and this list.\n    */\n  def ::: [B \u003e: A](prefix: List[B]): List[B] \u003d\n    if (isEmpty) prefix\n    else if (prefix.isEmpty) this\n    else {\n      val result \u003d new ::[B](prefix.head, this)\n      var curr \u003d result\n      var that \u003d prefix.tail\n      while (!that.isEmpty) {\n        val temp \u003d new ::[B](that.head, this)\n        curr.next \u003d temp\n        curr \u003d temp\n        that \u003d that.tail\n      }\n      releaseFence()\n      result\n    }\n\n  /** Adds the elements of a given list in reverse order in front of this list.\n    *  `xs reverse_::: ys` is equivalent to\n    *  `xs.reverse ::: ys` but is more efficient.\n    *\n    *  @param prefix the prefix to reverse and then prepend\n    *  @return       the concatenation of the reversed prefix and the current list.\n    */\n  def reverse_:::[B \u003e: A](prefix: List[B]): List[B] \u003d {\n    var these: List[B] \u003d this\n    var pres \u003d prefix\n    while (!pres.isEmpty) {\n      these \u003d pres.head :: these\n      pres \u003d pres.tail\n    }\n    these\n  }\n\n  override final def isEmpty: Boolean \u003d this eq Nil\n\n  override def prepended[B \u003e: A](elem: B): List[B] \u003d elem :: this\n\n  override def prependedAll[B \u003e: A](prefix: collection.IterableOnce[B]): List[B] \u003d prefix match {\n    case xs: List[B] \u003d\u003e xs ::: this\n    case _ if prefix.knownSize \u003d\u003d 0 \u003d\u003e this\n    case b: ListBuffer[B] if this.isEmpty \u003d\u003e b.toList\n    case _ \u003d\u003e\n      val iter \u003d prefix.iterator\n      if (iter.hasNext) {\n        val result \u003d new ::[B](iter.next(), this)\n        var curr \u003d result\n        while (iter.hasNext) {\n          val temp \u003d new ::[B](iter.next(), this)\n          curr.next \u003d temp\n          curr \u003d temp\n        }\n        releaseFence()\n        result\n      } else {\n        this\n      }\n  }\n\n  // When calling appendAll with another list `suffix`, avoid copying `suffix`\n  override def appendedAll[B \u003e: A](suffix: collection.IterableOnce[B]): List[B] \u003d suffix match {\n    case xs: List[B] \u003d\u003e this ::: xs\n    case _ \u003d\u003e super.appendedAll(suffix)\n  }\n\n  override def take(n: Int): List[A] \u003d if (isEmpty || n \u003c\u003d 0) Nil else {\n    val h \u003d new ::(head, Nil)\n    var t \u003d h\n    var rest \u003d tail\n    var i \u003d 1\n    while ({if (rest.isEmpty) return this; i \u003c n}) {\n      i +\u003d 1\n      val nx \u003d new ::(rest.head, Nil)\n      t.next \u003d nx\n      t \u003d nx\n      rest \u003d rest.tail\n    }\n    releaseFence()\n    h\n  }\n\n  /**\n    *  @example {{{\n    *  // Given a list\n    *  val letters \u003d List(\u0027a\u0027,\u0027b\u0027,\u0027c\u0027,\u0027d\u0027,\u0027e\u0027)\n    *\n    *  // `slice` returns all elements beginning at index `from` and afterwards,\n    *  // up until index `until` (excluding index `until`.)\n    *  letters.slice(1,3) // Returns List(\u0027b\u0027,\u0027c\u0027)\n    *  }}}\n    */\n  override def slice(from: Int, until: Int): List[A] \u003d {\n    val lo \u003d scala.math.max(from, 0)\n    if (until \u003c\u003d lo || isEmpty) Nil\n    else this drop lo take (until - lo)\n  }\n\n  override def takeRight(n: Int): List[A] \u003d {\n    @tailrec\n    def loop(lead: List[A], lag: List[A]): List[A] \u003d lead match {\n      case Nil \u003d\u003e lag\n      case _ :: tail \u003d\u003e loop(tail, lag.tail)\n    }\n    loop(drop(n), this)\n  }\n\n  // dropRight is inherited from LinearSeq\n\n  override def splitAt(n: Int): (List[A], List[A]) \u003d {\n    val b \u003d new ListBuffer[A]\n    var i \u003d 0\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 i \u003c n) {\n      i +\u003d 1\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    (b.toList, these)\n  }\n\n  override def updated[B \u003e: A](index: Int, elem: B): List[B] \u003d {\n    var i \u003d 0\n    var current \u003d this\n    val prefix \u003d ListBuffer.empty[B]\n    while (i \u003c index \u0026\u0026 current.nonEmpty) {\n      i +\u003d 1\n      prefix +\u003d current.head\n      current \u003d current.tail\n    }\n    if (i \u003d\u003d index \u0026\u0026 current.nonEmpty) {\n      prefix.prependToList(elem :: current.tail)\n    } else {\n      throw new IndexOutOfBoundsException(s\"$index is out of bounds (min 0, max ${length-1})\")\n    }\n  }\n\n  final override def map[B](f: A \u003d\u003e B): List[B] \u003d {\n    if (this eq Nil) Nil else {\n      val h \u003d new ::[B](f(head), Nil)\n      var t: ::[B] \u003d h\n      var rest \u003d tail\n      while (rest ne Nil) {\n        val nx \u003d new ::(f(rest.head), Nil)\n        t.next \u003d nx\n        t \u003d nx\n        rest \u003d rest.tail\n      }\n      releaseFence()\n      h\n    }\n  }\n\n  final override def collect[B](pf: PartialFunction[A, B]): List[B] \u003d {\n    if (this eq Nil) Nil else {\n      var rest \u003d this\n      var h: ::[B] \u003d null\n      var x: Any \u003d null\n      // Special case for first element\n      while (h eq null) {\n        x \u003d pf.applyOrElse(rest.head, List.partialNotApplied)\n        if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) h \u003d new ::(x.asInstanceOf[B], Nil)\n        rest \u003d rest.tail\n        if (rest eq Nil) return if (h eq null) Nil else h\n      }\n      var t \u003d h\n      // Remaining elements\n      while (rest ne Nil) {\n        x \u003d pf.applyOrElse(rest.head, List.partialNotApplied)\n        if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) {\n          val nx \u003d new ::(x.asInstanceOf[B], Nil)\n          t.next \u003d nx\n          t \u003d nx\n        }\n        rest \u003d rest.tail\n      }\n      releaseFence()\n      h\n    }\n  }\n\n  final override def flatMap[B](f: A \u003d\u003e IterableOnce[B]): List[B] \u003d {\n    var rest \u003d this\n    var h: ::[B] \u003d null\n    var t: ::[B] \u003d null\n    while (rest ne Nil) {\n      val it \u003d f(rest.head).iterator\n      while (it.hasNext) {\n        val nx \u003d new ::(it.next(), Nil)\n        if (t eq null) {\n          h \u003d nx\n        } else {\n          t.next \u003d nx\n        }\n        t \u003d nx\n      }\n      rest \u003d rest.tail\n    }\n    if (h eq null) Nil else {releaseFence(); h}\n  }\n\n  @inline final override def takeWhile(p: A \u003d\u003e Boolean): List[A] \u003d {\n    val b \u003d new ListBuffer[A]\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 p(these.head)) {\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    b.toList\n  }\n\n  @inline final override def span(p: A \u003d\u003e Boolean): (List[A], List[A]) \u003d {\n    val b \u003d new ListBuffer[A]\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 p(these.head)) {\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    (b.toList, these)\n  }\n\n  // Overridden with an implementation identical to the inherited one (at this time)\n  // solely so it can be finalized and thus inlinable.\n  @inline final override def foreach[U](f: A \u003d\u003e U): Unit \u003d {\n    var these \u003d this\n    while (!these.isEmpty) {\n      f(these.head)\n      these \u003d these.tail\n    }\n  }\n\n  final override def reverse: List[A] \u003d {\n    var result: List[A] \u003d Nil\n    var these \u003d this\n    while (!these.isEmpty) {\n      result \u003d these.head :: result\n      these \u003d these.tail\n    }\n    result\n  }\n\n  final override def foldRight[B](z: B)(op: (A, B) \u003d\u003e B): B \u003d {\n    var acc \u003d z\n    var these: List[A] \u003d reverse\n    while (!these.isEmpty) {\n      acc \u003d op(these.head, acc)\n      these \u003d these.tail\n    }\n    acc\n  }\n\n  // Copy/Paste overrides to avoid interface calls inside loops.\n\n  override final def length: Int \u003d {\n    var these \u003d this\n    var len \u003d 0\n    while (!these.isEmpty) {\n      len +\u003d 1\n      these \u003d these.tail\n    }\n    len\n  }\n\n  override final def lengthCompare(len: Int): Int \u003d {\n    @tailrec def loop(i: Int, xs: List[A]): Int \u003d {\n      if (i \u003d\u003d len)\n        if (xs.isEmpty) 0 else 1\n      else if (xs.isEmpty)\n        -1\n      else\n        loop(i + 1, xs.tail)\n    }\n    if (len \u003c 0) 1\n    else loop(0, coll)\n  }\n\n  override final def forall(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (!p(these.head)) return false\n      these \u003d these.tail\n    }\n    true\n  }\n\n  override final def exists(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (p(these.head)) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override final def contains[A1 \u003e: A](elem: A1): Boolean \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (these.head \u003d\u003d elem) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override final def find(p: A \u003d\u003e Boolean): Option[A] \u003d {\n    var these: List[A] \u003d this\n    while (!these.isEmpty) {\n      if (p(these.head)) return Some(these.head)\n      these \u003d these.tail\n    }\n    None\n  }\n\n  override def last: A \u003d {\n    if (isEmpty) throw new NoSuchElementException(\"List.last\")\n    else {\n      var these \u003d this\n      var scout \u003d tail\n      while (!scout.isEmpty) {\n        these \u003d scout\n        scout \u003d scout.tail\n      }\n      these.head\n    }\n  }\n\n  override def corresponds[B](that: collection.Seq[B])(p: (A, B) \u003d\u003e Boolean): Boolean \u003d that match {\n    case that: LinearSeq[B] \u003d\u003e\n      var i \u003d this\n      var j \u003d that\n      while (!(i.isEmpty || j.isEmpty)) {\n        if (!p(i.head, j.head))\n          return false\n        i \u003d i.tail\n        j \u003d j.tail\n      }\n      i.isEmpty \u0026\u0026 j.isEmpty\n    case _ \u003d\u003e\n      super.corresponds(that)(p)\n  }\n\n  override protected[this] def className \u003d \"List\"\n\n  /** Builds a new list by applying a function to all elements of this list.\n    *  Like `xs map f`, but returns `xs` unchanged if function\n    *  `f` maps all elements to themselves (as determined by `eq`).\n    *\n    *  @param f      the function to apply to each element.\n    *  @tparam B     the element type of the returned collection.\n    *  @return       a list resulting from applying the given function\n    *                `f` to each element of this list and collecting the results.\n    */\n  @`inline` final def mapConserve[B \u003e: A \u003c: AnyRef](f: A \u003d\u003e B): List[B] \u003d {\n    // Note to developers: there exists a duplication between this function and `reflect.internal.util.Collections#map2Conserve`.\n    // If any successful optimization attempts or other changes are made, please rehash them there too.\n    @tailrec\n    def loop(mappedHead: List[B], mappedLast: ::[B], unchanged: List[A], pending: List[A]): List[B] \u003d {\n      if (pending.isEmpty) {\n        if (mappedHead eq null) unchanged\n        else {\n          mappedLast.next \u003d (unchanged: List[B])\n          mappedHead\n        }\n      }\n      else {\n        val head0 \u003d pending.head\n        val head1 \u003d f(head0)\n\n        if (head1 eq head0.asInstanceOf[AnyRef])\n          loop(mappedHead, mappedLast, unchanged, pending.tail)\n        else {\n          var xc \u003d unchanged\n          var mappedHead1: List[B] \u003d mappedHead\n          var mappedLast1: ::[B] \u003d mappedLast\n          while (xc ne pending) {\n            val next \u003d new ::[B](xc.head, Nil)\n            if (mappedHead1 eq null) mappedHead1 \u003d next\n            if (mappedLast1 ne null) mappedLast1.next \u003d next\n            mappedLast1 \u003d next\n            xc \u003d xc.tail\n          }\n          val next \u003d new ::(head1, Nil)\n          if (mappedHead1 eq null) mappedHead1 \u003d next\n          if (mappedLast1 ne null) mappedLast1.next \u003d next\n          mappedLast1 \u003d next\n          val tail0 \u003d pending.tail\n          loop(mappedHead1, mappedLast1, tail0, tail0)\n\n        }\n      }\n    }\n    val result \u003d loop(null, null, this, this)\n    releaseFence()\n    result\n  }\n\n  override def filter(p: A \u003d\u003e Boolean): List[A] \u003d filterCommon(p, isFlipped \u003d false)\n\n  override def filterNot(p: A \u003d\u003e Boolean): List[A] \u003d filterCommon(p, isFlipped \u003d true)\n\n  private[this] def filterCommon(p: A \u003d\u003e Boolean, isFlipped: Boolean): List[A] \u003d {\n\n    // everything seen so far so far is not included\n    @tailrec def noneIn(l: List[A]): List[A] \u003d {\n      if (l.isEmpty)\n        Nil\n      else {\n        val h \u003d l.head\n        val t \u003d l.tail\n        if (p(h) !\u003d isFlipped)\n          allIn(l, t)\n        else\n          noneIn(t)\n      }\n    }\n\n    // everything from \u0027start\u0027 is included, if everything from this point is in we can return the origin\n    // start otherwise if we discover an element that is out we must create a new partial list.\n    @tailrec def allIn(start: List[A], remaining: List[A]): List[A] \u003d {\n      if (remaining.isEmpty)\n        start\n      else {\n        val x \u003d remaining.head\n        if (p(x) !\u003d isFlipped)\n          allIn(start, remaining.tail)\n        else\n          partialFill(start, remaining)\n      }\n    }\n\n    // we have seen elements that should be included then one that should be excluded, start building\n    def partialFill(origStart: List[A], firstMiss: List[A]): List[A] \u003d {\n      val newHead \u003d new ::(origStart.head, Nil)\n      var toProcess \u003d origStart.tail\n      var currentLast \u003d newHead\n\n      // we know that all elements are :: until at least firstMiss.tail\n      while (!(toProcess eq firstMiss)) {\n        val newElem \u003d new ::(toProcess.head, Nil)\n        currentLast.next \u003d newElem\n        currentLast \u003d newElem\n        toProcess \u003d toProcess.tail\n      }\n\n      // at this point newHead points to a list which is a duplicate of all the \u0027in\u0027 elements up to the first miss.\n      // currentLast is the last element in that list.\n\n      // now we are going to try and share as much of the tail as we can, only moving elements across when we have to.\n      var next \u003d firstMiss.tail\n      var nextToCopy \u003d next // the next element we would need to copy to our list if we cant share.\n      while (!next.isEmpty) {\n        // generally recommended is next.isNonEmpty but this incurs an extra method call.\n        val head: A \u003d next.head\n        if (p(head) !\u003d isFlipped) {\n          next \u003d next.tail\n        } else {\n          // its not a match - do we have outstanding elements?\n          while (!(nextToCopy eq next)) {\n            val newElem \u003d new ::(nextToCopy.head, Nil)\n            currentLast.next \u003d newElem\n            currentLast \u003d newElem\n            nextToCopy \u003d nextToCopy.tail\n          }\n          nextToCopy \u003d next.tail\n          next \u003d next.tail\n        }\n      }\n\n      // we have remaining elements - they are unchanged attach them to the end\n      if (!nextToCopy.isEmpty)\n        currentLast.next \u003d nextToCopy\n\n      newHead\n    }\n\n    val result \u003d noneIn(this)\n    releaseFence()\n    result\n  }\n\n  override def partition(p: A \u003d\u003e Boolean): (List[A], List[A]) \u003d {\n    if (isEmpty) List.TupleOfNil\n    else super.partition(p) match {\n      case (Nil, xs) \u003d\u003e (Nil, this)\n      case (xs, Nil) \u003d\u003e (this, Nil)\n      case pair \u003d\u003e pair\n    }\n  }\n\n  final override def toList: List[A] \u003d this\n\n  // Override for performance\n  override def equals(o: scala.Any): Boolean \u003d {\n    @tailrec def listEq(a: List[_], b: List[_]): Boolean \u003d\n      (a eq b) || {\n        val aEmpty \u003d a.isEmpty\n        val bEmpty \u003d b.isEmpty\n        if (!(aEmpty || bEmpty) \u0026\u0026 a.head \u003d\u003d b.head) {\n          listEq(a.tail, b.tail)\n        }\n        else {\n          aEmpty \u0026\u0026 bEmpty\n        }\n      }\n\n    o match {\n      case that: List[_] \u003d\u003e listEq(this, that)\n      case _ \u003d\u003e super.equals(o)\n    }\n  }\n\n  // TODO: uncomment once bincompat allows (reference: scala/scala#9365)\n  /*\n  // Override for performance: traverse only as much as needed\n  // and share tail when nothing needs to be filtered out anymore\n  override def diff[B \u003e: A](that: collection.Seq[B]): AnyRef \u003d {\n    if (that.isEmpty || this.isEmpty) this\n    else if (tail.isEmpty) if (that.contains(head)) Nil else this\n    else {\n      val occ \u003d occCounts(that)\n      val b \u003d new ListBuffer[A]()\n      @tailrec\n      def rec(remainder: List[A]): List[A] \u003d {\n        if(occ.isEmpty) b.prependToList(remainder)\n        else remainder match {\n          case Nil \u003d\u003e b.result()\n          case head :: next \u003d\u003e {\n            occ.updateWith(head){\n              case None \u003d\u003e {\n                b.append(head)\n                None\n              }\n              case Some(1) \u003d\u003e None\n              case Some(n) \u003d\u003e Some(n - 1)\n            }\n            rec(next)\n          }\n        }\n      }\n      rec(this)\n    }\n  }\n  */\n\n}\n\n// Internal code that mutates `next` _must_ call `Statics.releaseFence()` if either immediately, or\n// before a newly-allocated, thread-local :: instance is aliased (e.g. in ListBuffer.toList)\nfinal case class :: [+A](override val head: A, private[scala] var next: List[A @uncheckedVariance]) // sound because `next` is used only locally\n  extends List[A] {\n  releaseFence()\n  override def headOption: Some[A] \u003d Some(head)\n  override def tail: List[A] \u003d next\n}\n\ncase object Nil extends List[Nothing] {\n  override def head: Nothing \u003d throw new NoSuchElementException(\"head of empty list\")\n  override def headOption: None.type \u003d None\n  override def tail: Nothing \u003d throw new UnsupportedOperationException(\"tail of empty list\")\n  override def last: Nothing \u003d throw new NoSuchElementException(\"last of empty list\")\n  override def init: Nothing \u003d throw new UnsupportedOperationException(\"init of empty list\")\n  override def knownSize: Int \u003d 0\n  override def iterator: Iterator[Nothing] \u003d Iterator.empty\n  override def unzip[A1, A2](implicit asPair: Nothing \u003d\u003e (A1, A2)): (List[A1], List[A2]) \u003d EmptyUnzip\n\n  @transient\n  private[this] val EmptyUnzip \u003d (Nil, Nil)\n}\n\n/**\n  * $factoryInfo\n  * @define coll list\n  * @define Coll `List`\n  */\n@SerialVersionUID(3L)\nobject List extends StrictOptimizedSeqFactory[List] {\n  private val TupleOfNil \u003d (Nil, Nil)\n\n  def from[B](coll: collection.IterableOnce[B]): List[B] \u003d Nil.prependedAll(coll)\n\n  def newBuilder[A]: Builder[A, List[A]] \u003d new ListBuffer()\n\n  def empty[A]: List[A] \u003d Nil\n\n  @transient\n  private[collection] val partialNotApplied \u003d new Function1[Any, Any] { def apply(x: Any): Any \u003d this }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:15:29 INFO  compiling root (1 scala source)
2024.04.26 03:15:29 INFO  time: compiled root in 0.12s
2024.04.26 03:15:39 INFO  compiling root (1 scala source)
2024.04.26 03:15:39 INFO  time: compiled root in 0.1s
2024.04.26 03:15:44 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:15:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Predef.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nimport scala.language.implicitConversions\n\nimport scala.collection.{mutable, immutable, ArrayOps, StringOps}, immutable.WrappedString\nimport scala.annotation.{elidable, implicitNotFound}, elidable.ASSERTION\nimport scala.annotation.meta.{ companionClass, companionMethod }\n\n/** The `Predef` object provides definitions that are accessible in all Scala\n *  compilation units without explicit qualification.\n *\n *  \u003d\u003d\u003d Commonly Used Types \u003d\u003d\u003d\n *  Predef provides type aliases for types which are commonly used, such as\n *  the immutable collection types [[scala.collection.immutable.Map]] and\n *  [[scala.collection.immutable.Set]].\n *\n *  \u003d\u003d\u003d Console Output \u003d\u003d\u003d\n *  For basic console output, `Predef` provides convenience methods [[print(x:Any* print]] and [[println(x:Any* println]],\n *  which are aliases of the methods in the object [[scala.Console]].\n *\n *  \u003d\u003d\u003d Assertions \u003d\u003d\u003d\n *  A set of `assert` functions are provided for use as a way to document\n *  and dynamically check invariants in code. Invocations of `assert` can be elided\n *  at compile time by providing the command line option `-Xdisable-assertions`,\n *  which raises `-Xelide-below` above `elidable.ASSERTION`, to the `scalac` command.\n *\n *  Variants of `assert` intended for use with static analysis tools are also\n *  provided: `assume`, `require` and `ensuring`. `require` and `ensuring` are\n *  intended for use as a means of design-by-contract style specification\n *  of pre- and post-conditions on functions, with the intention that these\n *  specifications could be consumed by a static analysis tool. For instance,\n *\n *  {{{\n *  def addNaturals(nats: List[Int]): Int \u003d {\n *    require(nats forall (_ \u003e\u003d 0), \"List contains negative numbers\")\n *    nats.foldLeft(0)(_ + _)\n *  } ensuring(_ \u003e\u003d 0)\n *  }}}\n *\n *  The declaration of `addNaturals` states that the list of integers passed should\n *  only contain natural numbers (i.e. non-negative), and that the result returned\n *  will also be natural. `require` is distinct from `assert` in that if the\n *  condition fails, then the caller of the function is to blame rather than a\n *  logical error having been made within `addNaturals` itself. `ensuring` is a\n *  form of `assert` that declares the guarantee the function is providing with\n *  regards to its return value.\n *\n *  \u003d\u003d\u003d Implicit Conversions \u003d\u003d\u003d\n *  A number of commonly applied implicit conversions are also defined here, and\n *  in the parent type [[scala.LowPriorityImplicits]]. Implicit conversions\n *  are provided for the \"widening\" of numeric values, for instance, converting a\n *  Short value to a Long value as required, and to add additional higher-order\n *  functions to Array values. These are described in more detail in the documentation of [[scala.Array]].\n *\n * @groupname utilities Utility Methods\n * @groupprio utilities 10\n *\n * @groupname assertions Assertions\n * @groupprio assertions 20\n * @groupdesc assertions These methods support program verification and runtime correctness.\n *\n * @groupname console-output Console Output\n * @groupprio console-output 30\n * @groupdesc console-output These methods provide output via the console.\n *\n * @groupname aliases Aliases\n * @groupprio aliases 50\n * @groupdesc aliases These aliases bring selected immutable types into scope without any imports.\n *\n * @groupname conversions-string String Conversions\n * @groupprio conversions-string 60\n * @groupdesc conversions-string Conversions from String to StringOps or WrappedString.\n *\n * @groupname implicit-classes-any Implicit Classes\n * @groupprio implicit-classes-any 70\n * @groupdesc implicit-classes-any These implicit classes add useful extension methods to every type.\n *\n * @groupname char-sequence-wrappers CharSequence Wrappers\n * @groupprio char-sequence-wrappers 80\n * @groupdesc char-sequence-wrappers Wrappers that implements CharSequence and were implicit classes.\n *\n * @groupname conversions-java-to-anyval Java to Scala\n * @groupprio conversions-java-to-anyval 90\n * @groupdesc conversions-java-to-anyval Implicit conversion from Java primitive wrapper types to Scala equivalents.\n *\n * @groupname conversions-anyval-to-java Scala to Java\n * @groupprio conversions-anyval-to-java 100\n * @groupdesc conversions-anyval-to-java Implicit conversion from Scala AnyVals to Java primitive wrapper types equivalents.\n *\n * @groupname conversions-array-to-wrapped-array Array to ArraySeq\n * @groupprio conversions-array-to-wrapped-array 110\n * @groupdesc conversions-array-to-wrapped-array Conversions from Arrays to ArraySeqs.\n */\nobject Predef extends LowPriorityImplicits {\n  /**\n   * Retrieve the runtime representation of a class type. `classOf[T]` is equivalent to\n   * the class literal `T.class` in Java.\n   *\n   * @example {{{\n   * val listClass \u003d classOf[List[_]]\n   * // listClass is java.lang.Class[List[_]] \u003d class scala.collection.immutable.List\n   *\n   * val mapIntString \u003d classOf[Map[Int,String]]\n   * // mapIntString is java.lang.Class[Map[Int,String]] \u003d interface scala.collection.immutable.Map\n   * }}}\n   *\n   * @return The runtime [[Class]] representation of type `T`.\n   * @group utilities\n   */\n  def classOf[T]: Class[T] \u003d null // This is a stub method. The actual implementation is filled in by the compiler.\n\n  /**\n   * Retrieve the single value of a type with a unique inhabitant.\n   *\n   * @example {{{\n   * object Foo\n   * val foo \u003d valueOf[Foo.type]\n   * // foo is Foo.type \u003d Foo\n   *\n   * val bar \u003d valueOf[23]\n   * // bar is 23.type \u003d 23\n   * }}}\n   * @group utilities\n   */\n  @inline def valueOf[T](implicit vt: ValueOf[T]): T \u003d vt.value\n\n  /** The `String` type in Scala has all the methods of the underlying\n   *  [[java.lang.String]], of which it is just an alias.\n   *\n   *  In addition, extension methods in [[scala.collection.StringOps]]\n   *  are added implicitly through the conversion [[augmentString]].\n   *  @group aliases\n   */\n  type String        \u003d java.lang.String\n  /**  @group aliases */\n  type Class[T]      \u003d java.lang.Class[T]\n\n  // miscellaneous -----------------------------------------------------\n  scala.`package`                         // to force scala package object to be seen.\n  scala.collection.immutable.List         // to force Nil, :: to be seen.\n\n  /**  @group aliases */\n  type Function[-A, +B] \u003d Function1[A, B]\n\n  /**  @group aliases */\n  type Map[K, +V] \u003d immutable.Map[K, V]\n  /**  @group aliases */\n  type Set[A]     \u003d immutable.Set[A]\n  /**  @group aliases */\n  val Map         \u003d immutable.Map\n  /**  @group aliases */\n  val Set         \u003d immutable.Set\n\n  /**\n   * Allows destructuring tuples with the same syntax as constructing them.\n   *\n   * @example {{{\n   * val tup \u003d \"foobar\" -\u003e 3\n   *\n   * val c \u003d tup match {\n   *   case str -\u003e i \u003d\u003e str.charAt(i)\n   * }\n   * }}}\n   * @group aliases\n   */\n  val -\u003e        \u003d Tuple2\n\n  // Manifest types, companions, and incantations for summoning\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  type OptManifest[T]   \u003d scala.reflect.OptManifest[T]\n  @implicitNotFound(msg \u003d \"No Manifest available for ${T}.\")\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  type Manifest[T]      \u003d scala.reflect.Manifest[T]\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  val Manifest          \u003d scala.reflect.Manifest\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  val NoManifest        \u003d scala.reflect.NoManifest\n\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use scala.reflect.classTag[T] and scala.reflect.runtime.universe.typeTag[T] instead\", \"2.10.0\")\n  def manifest[T](implicit m: Manifest[T]): Manifest[T]          \u003d m\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  def optManifest[T](implicit m: OptManifest[T]): OptManifest[T] \u003d m\n\n  // Minor variations on identity functions\n\n  /**\n   * A method that returns its input value.\n   * @tparam A type of the input value x.\n   * @param x the value of type `A` to be returned.\n   * @return the value `x`.\n   * @group utilities */\n  @inline def identity[A](x: A): A \u003d x // see `$conforms` for the implicit version\n\n  /** Summon an implicit value of type `T`. Usually, the argument is not passed explicitly.\n   *\n   *  @tparam T the type of the value to be summoned\n   *  @return the implicit value of type `T`\n   *  @group utilities\n   */\n  @inline def implicitly[T](implicit e: T): T \u003d e // TODO: when dependent method types are on by default, give this result type `e.type`, so that inliner has better chance of knowing which method to inline in calls like `implicitly[MatchingStrategy[Option]].zero`\n\n  /** Used to mark code blocks as being expressions, instead of being taken as part of anonymous classes and the like.\n   *  This is just a different name for [[identity]].\n   *\n   *  @example Separating code blocks from `new`:\n   *           {{{\n   *             val x \u003d new AnyRef\n   *             {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // the { ... } block is seen as the body of an anonymous class\n   *\n   *             val x \u003d new AnyRef\n   *\n   *             {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // an empty line is a brittle \"fix\"\n   *\n   *             val x \u003d new AnyRef\n   *             locally {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // locally guards the block and helps communicate intent\n   *           }}}\n   *  @group utilities\n   */\n  @inline def locally[T](@deprecatedName(\"x\") x: T): T \u003d x\n\n  // assertions ---------------------------------------------------------\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assert(assertion: Boolean): Unit \u003d {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @param message     a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assert(assertion: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assume(assumption: Boolean): Unit \u003d {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @param message      a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assume(assumption: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @group assertions\n   */\n  def require(requirement: Boolean): Unit \u003d {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed\")\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @param message       a String to include in the failure message\n   *  @group assertions\n   */\n  @inline final def require(requirement: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed: \"+ message)\n  }\n\n  /** `???` can be used for marking methods that remain to be implemented.\n   *  @throws NotImplementedError when `???` is invoked.\n   *  @group utilities\n   */\n  def ??? : Nothing \u003d throw new NotImplementedError\n\n  // implicit classes -----------------------------------------------------\n\n  /** @group implicit-classes-any */\n  implicit final class ArrowAssoc[A](private val self: A) extends AnyVal {\n    @inline def -\u003e [B](y: B): (A, B) \u003d (self, y)\n    @deprecated(\"Use `-\u003e` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.\", \"2.13.0\")\n    def →[B](y: B): (A, B) \u003d -\u003e(y)\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class Ensuring[A](private val self: A) extends AnyVal {\n    def ensuring(cond: Boolean): A \u003d { assert(cond); self }\n    def ensuring(cond: Boolean, msg: \u003d\u003e Any): A \u003d { assert(cond, msg); self }\n    def ensuring(cond: A \u003d\u003e Boolean): A \u003d { assert(cond(self)); self }\n    def ensuring(cond: A \u003d\u003e Boolean, msg: \u003d\u003e Any): A \u003d { assert(cond(self), msg); self }\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class StringFormat[A](private val self: A) extends AnyVal {\n    /** Returns string formatted according to given `format` string.\n     *  Format strings are as for `String.format`\n     *  (@see java.lang.String.format).\n     */\n    @deprecated(\"Use `formatString.format(value)` instead of `value.formatted(formatString)`,\\nor use the `f\\\"\\\"` string interpolator. In Java 15 and later, `formatted` resolves to the new method in String which has reversed parameters.\", \"2.12.16\")\n    @inline def formatted(fmtstr: String): String \u003d fmtstr format self\n  }\n\n  /** Injects String concatenation operator `+` to any classes. \n   * @group implicit-classes-any\n   */\n  @(deprecated @companionMethod)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\")\n  @(deprecated @companionClass)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\") // for Scaladoc\n  // scala/bug#8229 retaining the pre 2.11 name for source compatibility in shadowing this implicit\n  implicit final class any2stringadd[A](private val self: A) extends AnyVal {\n    def +(other: String): String \u003d String.valueOf(self) + other\n  }\n\n  /** @group char-sequence-wrappers */\n  final class SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]) extends CharSequence {\n    def length: Int                                     \u003d sequenceOfChars.length\n    def charAt(index: Int): Char                        \u003d sequenceOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence \u003d new SeqCharSequence(sequenceOfChars.slice(start, end))\n    override def toString                               \u003d sequenceOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]): SeqCharSequence \u003d new SeqCharSequence(sequenceOfChars)\n\n  /** @group char-sequence-wrappers */\n  final class ArrayCharSequence(arrayOfChars: Array[Char]) extends CharSequence {\n    def length: Int                                     \u003d arrayOfChars.length\n    def charAt(index: Int): Char                        \u003d arrayOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence \u003d new runtime.ArrayCharSequence(arrayOfChars, start, end)\n    override def toString                               \u003d arrayOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def ArrayCharSequence(arrayOfChars: Array[Char]): ArrayCharSequence \u003d new ArrayCharSequence(arrayOfChars)\n\n  /** @group conversions-string */\n  @inline implicit def augmentString(x: String): StringOps \u003d new StringOps(x)\n\n  // printing -----------------------------------------------------------\n\n  /** Prints an object to `out` using its `toString` method.\n   *\n   *  @param x the object to print; may be null.\n   *  @group console-output\n   */\n  def print(x: Any): Unit \u003d Console.print(x)\n\n  /** Prints a newline character on the default output.\n   *  @group console-output\n   */\n  def println(): Unit \u003d Console.println()\n\n  /** Prints out an object to the default output, followed by a newline character.\n   *\n   *  @param x the object to print.\n   *  @group console-output\n   */\n  def println(x: Any): Unit \u003d Console.println(x)\n\n  /** Prints its arguments as a formatted string to the default output,\n   *  based on a string pattern (in a fashion similar to printf in C).\n   *\n   *  The interpretation of the formatting patterns is described in\n   *  [[java.util.Formatter]].\n   *\n   *  Consider using the [[scala.StringContext.f f interpolator]] as more type safe and idiomatic.\n   *\n   *  @param text the pattern for formatting the arguments.\n   *  @param xs   the arguments used to instantiate the pattern.\n   *  @throws java.lang.IllegalArgumentException if there was a problem with the format string or arguments\n   *\n   *  @see [[scala.StringContext.f StringContext.f]]\n   *  @group console-output\n   */\n  def printf(text: String, xs: Any*): Unit \u003d Console.print(text.format(xs: _*))\n\n  // views --------------------------------------------------------------\n\n  // these two are morally deprecated but the @deprecated annotation has been moved to the extension method themselves,\n  // in order to provide a more specific deprecation method.\n  implicit def tuple2ToZippedOps[T1, T2](x: (T1, T2)): runtime.Tuple2Zipped.Ops[T1, T2]             \u003d new runtime.Tuple2Zipped.Ops(x)\n  implicit def tuple3ToZippedOps[T1, T2, T3](x: (T1, T2, T3)): runtime.Tuple3Zipped.Ops[T1, T2, T3] \u003d new runtime.Tuple3Zipped.Ops(x)\n\n  // Not specialized anymore since 2.13 but we still need separate methods\n  // to avoid https://github.com/scala/bug/issues/10746\n  // TODO: should not need @inline. add heuristic to inline factories for value classes.\n  @inline implicit def genericArrayOps[T](xs: Array[T]): ArrayOps[T]          \u003d new ArrayOps(xs)\n  @inline implicit def booleanArrayOps(xs: Array[Boolean]): ArrayOps[Boolean] \u003d new ArrayOps(xs)\n  @inline implicit def byteArrayOps(xs: Array[Byte]): ArrayOps[Byte]          \u003d new ArrayOps(xs)\n  @inline implicit def charArrayOps(xs: Array[Char]): ArrayOps[Char]          \u003d new ArrayOps(xs)\n  @inline implicit def doubleArrayOps(xs: Array[Double]): ArrayOps[Double]    \u003d new ArrayOps(xs)\n  @inline implicit def floatArrayOps(xs: Array[Float]): ArrayOps[Float]       \u003d new ArrayOps(xs)\n  @inline implicit def intArrayOps(xs: Array[Int]): ArrayOps[Int]             \u003d new ArrayOps(xs)\n  @inline implicit def longArrayOps(xs: Array[Long]): ArrayOps[Long]          \u003d new ArrayOps(xs)\n  @inline implicit def refArrayOps[T \u003c: AnyRef](xs: Array[T]): ArrayOps[T]    \u003d new ArrayOps(xs)\n  @inline implicit def shortArrayOps(xs: Array[Short]): ArrayOps[Short]       \u003d new ArrayOps(xs)\n  @inline implicit def unitArrayOps(xs: Array[Unit]): ArrayOps[Unit]          \u003d new ArrayOps(xs)\n\n  // \"Autoboxing\" and \"Autounboxing\" ---------------------------------------------------\n\n  /** @group conversions-anyval-to-java */\n  implicit def byte2Byte(x: Byte): java.lang.Byte             \u003d x.asInstanceOf[java.lang.Byte]\n  /** @group conversions-anyval-to-java */\n  implicit def short2Short(x: Short): java.lang.Short         \u003d x.asInstanceOf[java.lang.Short]\n  /** @group conversions-anyval-to-java */\n  implicit def char2Character(x: Char): java.lang.Character   \u003d x.asInstanceOf[java.lang.Character]\n  /** @group conversions-anyval-to-java */\n  implicit def int2Integer(x: Int): java.lang.Integer         \u003d x.asInstanceOf[java.lang.Integer]\n  /** @group conversions-anyval-to-java */\n  implicit def long2Long(x: Long): java.lang.Long             \u003d x.asInstanceOf[java.lang.Long]\n  /** @group conversions-anyval-to-java */\n  implicit def float2Float(x: Float): java.lang.Float         \u003d x.asInstanceOf[java.lang.Float]\n  /** @group conversions-anyval-to-java */\n  implicit def double2Double(x: Double): java.lang.Double     \u003d x.asInstanceOf[java.lang.Double]\n  /** @group conversions-anyval-to-java */\n  implicit def boolean2Boolean(x: Boolean): java.lang.Boolean \u003d x.asInstanceOf[java.lang.Boolean]\n\n  /** @group conversions-java-to-anyval */\n  implicit def Byte2byte(x: java.lang.Byte): Byte             \u003d x.asInstanceOf[Byte]\n  /** @group conversions-java-to-anyval */\n  implicit def Short2short(x: java.lang.Short): Short         \u003d x.asInstanceOf[Short]\n  /** @group conversions-java-to-anyval */\n  implicit def Character2char(x: java.lang.Character): Char   \u003d x.asInstanceOf[Char]\n  /** @group conversions-java-to-anyval */\n  implicit def Integer2int(x: java.lang.Integer): Int         \u003d x.asInstanceOf[Int]\n  /** @group conversions-java-to-anyval */\n  implicit def Long2long(x: java.lang.Long): Long             \u003d x.asInstanceOf[Long]\n  /** @group conversions-java-to-anyval */\n  implicit def Float2float(x: java.lang.Float): Float         \u003d x.asInstanceOf[Float]\n  /** @group conversions-java-to-anyval */\n  implicit def Double2double(x: java.lang.Double): Double     \u003d x.asInstanceOf[Double]\n  /** @group conversions-java-to-anyval */\n  implicit def Boolean2boolean(x: java.lang.Boolean): Boolean \u003d x.asInstanceOf[Boolean]\n\n  /** An implicit of type `A \u003d\u003e A` is available for all `A` because it can always\n   *  be implemented using the identity function. This also means that an\n   *  implicit of type `A \u003d\u003e B` is always available when `A \u003c: B`, because\n   *  `(A \u003d\u003e A) \u003c: (A \u003d\u003e B)`.\n   */\n  // $ to avoid accidental shadowing (e.g. scala/bug#7788)\n  implicit def $conforms[A]: A \u003d\u003e A \u003d \u003c:\u003c.refl\n}\n\n/** The `LowPriorityImplicits` class provides implicit values that\n*  are valid in all Scala compilation units without explicit qualification,\n*  but that are partially overridden by higher-priority conversions in object\n*  `Predef`.\n*/\n// scala/bug#7335 Parents of Predef are defined in the same compilation unit to avoid\n// cyclic reference errors compiling the standard library *without* a previously\n// compiled copy on the classpath.\nprivate[scala] abstract class LowPriorityImplicits extends LowPriorityImplicits2 {\n  import mutable.ArraySeq\n\n  /** We prefer the java.lang.* boxed types to these wrappers in\n   *  any potential conflicts.  Conflicts do exist because the wrappers\n   *  need to implement ScalaNumber in order to have a symmetric equals\n   *  method, but that implies implementing java.lang.Number as well.\n   *\n   *  Note - these are inlined because they are value classes, but\n   *  the call to xxxWrapper is not eliminated even though it does nothing.\n   *  Even inlined, every call site does a no-op retrieval of Predef\u0027s MODULE$\n   *  because maybe loading Predef has side effects!\n   */\n  @inline implicit def byteWrapper(x: Byte): runtime.RichByte          \u003d new runtime.RichByte(x)\n  @inline implicit def shortWrapper(x: Short): runtime.RichShort       \u003d new runtime.RichShort(x)\n  @inline implicit def intWrapper(x: Int): runtime.RichInt             \u003d new runtime.RichInt(x)\n  @inline implicit def charWrapper(c: Char): runtime.RichChar          \u003d new runtime.RichChar(c)\n  @inline implicit def longWrapper(x: Long): runtime.RichLong          \u003d new runtime.RichLong(x)\n  @inline implicit def floatWrapper(x: Float): runtime.RichFloat       \u003d new runtime.RichFloat(x)\n  @inline implicit def doubleWrapper(x: Double): runtime.RichDouble    \u003d new runtime.RichDouble(x)\n  @inline implicit def booleanWrapper(x: Boolean): runtime.RichBoolean \u003d new runtime.RichBoolean(x)\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def genericWrapArray[T](xs: Array[T]): ArraySeq[T] \u003d\n    if (xs eq null) null\n    else ArraySeq.make(xs)\n\n  // Since the JVM thinks arrays are covariant, one 0-length Array[AnyRef]\n  // is as good as another for all T \u003c: AnyRef.  Instead of creating 100,000,000\n  // unique ones by way of this implicit, let\u0027s share one.\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapRefArray[T \u003c: AnyRef](xs: Array[T]): ArraySeq.ofRef[T] \u003d {\n    if (xs eq null) null\n    else if (xs.length \u003d\u003d 0) ArraySeq.empty[AnyRef].asInstanceOf[ArraySeq.ofRef[T]]\n    else new ArraySeq.ofRef[T](xs)\n  }\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapIntArray(xs: Array[Int]): ArraySeq.ofInt \u003d if (xs ne null) new ArraySeq.ofInt(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapDoubleArray(xs: Array[Double]): ArraySeq.ofDouble \u003d if (xs ne null) new ArraySeq.ofDouble(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapLongArray(xs: Array[Long]): ArraySeq.ofLong \u003d if (xs ne null) new ArraySeq.ofLong(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapFloatArray(xs: Array[Float]): ArraySeq.ofFloat \u003d if (xs ne null) new ArraySeq.ofFloat(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapCharArray(xs: Array[Char]): ArraySeq.ofChar \u003d if (xs ne null) new ArraySeq.ofChar(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapByteArray(xs: Array[Byte]): ArraySeq.ofByte \u003d if (xs ne null) new ArraySeq.ofByte(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapShortArray(xs: Array[Short]): ArraySeq.ofShort \u003d if (xs ne null) new ArraySeq.ofShort(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapBooleanArray(xs: Array[Boolean]): ArraySeq.ofBoolean \u003d if (xs ne null) new ArraySeq.ofBoolean(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapUnitArray(xs: Array[Unit]): ArraySeq.ofUnit \u003d if (xs ne null) new ArraySeq.ofUnit(xs) else null\n\n  /** @group conversions-string */\n  implicit def wrapString(s: String): WrappedString \u003d if (s ne null) new WrappedString(s) else null\n}\n\nprivate[scala] abstract class LowPriorityImplicits2 {\n  @deprecated(\"implicit conversions from Array to immutable.IndexedSeq are implemented by copying; use `toIndexedSeq` explicitly if you want to copy, or use the more efficient non-copying ArraySeq.unsafeWrapArray\", since\u003d\"2.13.0\")\n  implicit def copyArrayToImmutableIndexedSeq[T](xs: Array[T]): IndexedSeq[T] \u003d\n    if (xs eq null) null\n    else new ArrayOps(xs).toIndexedSeq\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:15:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Predef.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:15:44 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:15:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Predef.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nimport scala.language.implicitConversions\n\nimport scala.collection.{mutable, immutable, ArrayOps, StringOps}, immutable.WrappedString\nimport scala.annotation.{elidable, implicitNotFound}, elidable.ASSERTION\nimport scala.annotation.meta.{ companionClass, companionMethod }\n\n/** The `Predef` object provides definitions that are accessible in all Scala\n *  compilation units without explicit qualification.\n *\n *  \u003d\u003d\u003d Commonly Used Types \u003d\u003d\u003d\n *  Predef provides type aliases for types which are commonly used, such as\n *  the immutable collection types [[scala.collection.immutable.Map]] and\n *  [[scala.collection.immutable.Set]].\n *\n *  \u003d\u003d\u003d Console Output \u003d\u003d\u003d\n *  For basic console output, `Predef` provides convenience methods [[print(x:Any* print]] and [[println(x:Any* println]],\n *  which are aliases of the methods in the object [[scala.Console]].\n *\n *  \u003d\u003d\u003d Assertions \u003d\u003d\u003d\n *  A set of `assert` functions are provided for use as a way to document\n *  and dynamically check invariants in code. Invocations of `assert` can be elided\n *  at compile time by providing the command line option `-Xdisable-assertions`,\n *  which raises `-Xelide-below` above `elidable.ASSERTION`, to the `scalac` command.\n *\n *  Variants of `assert` intended for use with static analysis tools are also\n *  provided: `assume`, `require` and `ensuring`. `require` and `ensuring` are\n *  intended for use as a means of design-by-contract style specification\n *  of pre- and post-conditions on functions, with the intention that these\n *  specifications could be consumed by a static analysis tool. For instance,\n *\n *  {{{\n *  def addNaturals(nats: List[Int]): Int \u003d {\n *    require(nats forall (_ \u003e\u003d 0), \"List contains negative numbers\")\n *    nats.foldLeft(0)(_ + _)\n *  } ensuring(_ \u003e\u003d 0)\n *  }}}\n *\n *  The declaration of `addNaturals` states that the list of integers passed should\n *  only contain natural numbers (i.e. non-negative), and that the result returned\n *  will also be natural. `require` is distinct from `assert` in that if the\n *  condition fails, then the caller of the function is to blame rather than a\n *  logical error having been made within `addNaturals` itself. `ensuring` is a\n *  form of `assert` that declares the guarantee the function is providing with\n *  regards to its return value.\n *\n *  \u003d\u003d\u003d Implicit Conversions \u003d\u003d\u003d\n *  A number of commonly applied implicit conversions are also defined here, and\n *  in the parent type [[scala.LowPriorityImplicits]]. Implicit conversions\n *  are provided for the \"widening\" of numeric values, for instance, converting a\n *  Short value to a Long value as required, and to add additional higher-order\n *  functions to Array values. These are described in more detail in the documentation of [[scala.Array]].\n *\n * @groupname utilities Utility Methods\n * @groupprio utilities 10\n *\n * @groupname assertions Assertions\n * @groupprio assertions 20\n * @groupdesc assertions These methods support program verification and runtime correctness.\n *\n * @groupname console-output Console Output\n * @groupprio console-output 30\n * @groupdesc console-output These methods provide output via the console.\n *\n * @groupname aliases Aliases\n * @groupprio aliases 50\n * @groupdesc aliases These aliases bring selected immutable types into scope without any imports.\n *\n * @groupname conversions-string String Conversions\n * @groupprio conversions-string 60\n * @groupdesc conversions-string Conversions from String to StringOps or WrappedString.\n *\n * @groupname implicit-classes-any Implicit Classes\n * @groupprio implicit-classes-any 70\n * @groupdesc implicit-classes-any These implicit classes add useful extension methods to every type.\n *\n * @groupname char-sequence-wrappers CharSequence Wrappers\n * @groupprio char-sequence-wrappers 80\n * @groupdesc char-sequence-wrappers Wrappers that implements CharSequence and were implicit classes.\n *\n * @groupname conversions-java-to-anyval Java to Scala\n * @groupprio conversions-java-to-anyval 90\n * @groupdesc conversions-java-to-anyval Implicit conversion from Java primitive wrapper types to Scala equivalents.\n *\n * @groupname conversions-anyval-to-java Scala to Java\n * @groupprio conversions-anyval-to-java 100\n * @groupdesc conversions-anyval-to-java Implicit conversion from Scala AnyVals to Java primitive wrapper types equivalents.\n *\n * @groupname conversions-array-to-wrapped-array Array to ArraySeq\n * @groupprio conversions-array-to-wrapped-array 110\n * @groupdesc conversions-array-to-wrapped-array Conversions from Arrays to ArraySeqs.\n */\nobject Predef extends LowPriorityImplicits {\n  /**\n   * Retrieve the runtime representation of a class type. `classOf[T]` is equivalent to\n   * the class literal `T.class` in Java.\n   *\n   * @example {{{\n   * val listClass \u003d classOf[List[_]]\n   * // listClass is java.lang.Class[List[_]] \u003d class scala.collection.immutable.List\n   *\n   * val mapIntString \u003d classOf[Map[Int,String]]\n   * // mapIntString is java.lang.Class[Map[Int,String]] \u003d interface scala.collection.immutable.Map\n   * }}}\n   *\n   * @return The runtime [[Class]] representation of type `T`.\n   * @group utilities\n   */\n  def classOf[T]: Class[T] \u003d null // This is a stub method. The actual implementation is filled in by the compiler.\n\n  /**\n   * Retrieve the single value of a type with a unique inhabitant.\n   *\n   * @example {{{\n   * object Foo\n   * val foo \u003d valueOf[Foo.type]\n   * // foo is Foo.type \u003d Foo\n   *\n   * val bar \u003d valueOf[23]\n   * // bar is 23.type \u003d 23\n   * }}}\n   * @group utilities\n   */\n  @inline def valueOf[T](implicit vt: ValueOf[T]): T \u003d vt.value\n\n  /** The `String` type in Scala has all the methods of the underlying\n   *  [[java.lang.String]], of which it is just an alias.\n   *\n   *  In addition, extension methods in [[scala.collection.StringOps]]\n   *  are added implicitly through the conversion [[augmentString]].\n   *  @group aliases\n   */\n  type String        \u003d java.lang.String\n  /**  @group aliases */\n  type Class[T]      \u003d java.lang.Class[T]\n\n  // miscellaneous -----------------------------------------------------\n  scala.`package`                         // to force scala package object to be seen.\n  scala.collection.immutable.List         // to force Nil, :: to be seen.\n\n  /**  @group aliases */\n  type Function[-A, +B] \u003d Function1[A, B]\n\n  /**  @group aliases */\n  type Map[K, +V] \u003d immutable.Map[K, V]\n  /**  @group aliases */\n  type Set[A]     \u003d immutable.Set[A]\n  /**  @group aliases */\n  val Map         \u003d immutable.Map\n  /**  @group aliases */\n  val Set         \u003d immutable.Set\n\n  /**\n   * Allows destructuring tuples with the same syntax as constructing them.\n   *\n   * @example {{{\n   * val tup \u003d \"foobar\" -\u003e 3\n   *\n   * val c \u003d tup match {\n   *   case str -\u003e i \u003d\u003e str.charAt(i)\n   * }\n   * }}}\n   * @group aliases\n   */\n  val -\u003e        \u003d Tuple2\n\n  // Manifest types, companions, and incantations for summoning\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  type OptManifest[T]   \u003d scala.reflect.OptManifest[T]\n  @implicitNotFound(msg \u003d \"No Manifest available for ${T}.\")\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  type Manifest[T]      \u003d scala.reflect.Manifest[T]\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  val Manifest          \u003d scala.reflect.Manifest\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  val NoManifest        \u003d scala.reflect.NoManifest\n\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use scala.reflect.classTag[T] and scala.reflect.runtime.universe.typeTag[T] instead\", \"2.10.0\")\n  def manifest[T](implicit m: Manifest[T]): Manifest[T]          \u003d m\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn\u0027t have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  def optManifest[T](implicit m: OptManifest[T]): OptManifest[T] \u003d m\n\n  // Minor variations on identity functions\n\n  /**\n   * A method that returns its input value.\n   * @tparam A type of the input value x.\n   * @param x the value of type `A` to be returned.\n   * @return the value `x`.\n   * @group utilities */\n  @inline def identity[A](x: A): A \u003d x // see `$conforms` for the implicit version\n\n  /** Summon an implicit value of type `T`. Usually, the argument is not passed explicitly.\n   *\n   *  @tparam T the type of the value to be summoned\n   *  @return the implicit value of type `T`\n   *  @group utilities\n   */\n  @inline def implicitly[T](implicit e: T): T \u003d e // TODO: when dependent method types are on by default, give this result type `e.type`, so that inliner has better chance of knowing which method to inline in calls like `implicitly[MatchingStrategy[Option]].zero`\n\n  /** Used to mark code blocks as being expressions, instead of being taken as part of anonymous classes and the like.\n   *  This is just a different name for [[identity]].\n   *\n   *  @example Separating code blocks from `new`:\n   *           {{{\n   *             val x \u003d new AnyRef\n   *             {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // the { ... } block is seen as the body of an anonymous class\n   *\n   *             val x \u003d new AnyRef\n   *\n   *             {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // an empty line is a brittle \"fix\"\n   *\n   *             val x \u003d new AnyRef\n   *             locally {\n   *               val y \u003d ...\n   *               println(y)\n   *             }\n   *             // locally guards the block and helps communicate intent\n   *           }}}\n   *  @group utilities\n   */\n  @inline def locally[T](@deprecatedName(\"x\") x: T): T \u003d x\n\n  // assertions ---------------------------------------------------------\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assert(assertion: Boolean): Unit \u003d {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @param message     a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assert(assertion: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assume(assumption: Boolean): Unit \u003d {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @param message      a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assume(assumption: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @group assertions\n   */\n  def require(requirement: Boolean): Unit \u003d {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed\")\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @param message       a String to include in the failure message\n   *  @group assertions\n   */\n  @inline final def require(requirement: Boolean, message: \u003d\u003e Any): Unit \u003d {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed: \"+ message)\n  }\n\n  /** `???` can be used for marking methods that remain to be implemented.\n   *  @throws NotImplementedError when `???` is invoked.\n   *  @group utilities\n   */\n  def ??? : Nothing \u003d throw new NotImplementedError\n\n  // implicit classes -----------------------------------------------------\n\n  /** @group implicit-classes-any */\n  implicit final class ArrowAssoc[A](private val self: A) extends AnyVal {\n    @inline def -\u003e [B](y: B): (A, B) \u003d (self, y)\n    @deprecated(\"Use `-\u003e` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.\", \"2.13.0\")\n    def →[B](y: B): (A, B) \u003d -\u003e(y)\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class Ensuring[A](private val self: A) extends AnyVal {\n    def ensuring(cond: Boolean): A \u003d { assert(cond); self }\n    def ensuring(cond: Boolean, msg: \u003d\u003e Any): A \u003d { assert(cond, msg); self }\n    def ensuring(cond: A \u003d\u003e Boolean): A \u003d { assert(cond(self)); self }\n    def ensuring(cond: A \u003d\u003e Boolean, msg: \u003d\u003e Any): A \u003d { assert(cond(self), msg); self }\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class StringFormat[A](private val self: A) extends AnyVal {\n    /** Returns string formatted according to given `format` string.\n     *  Format strings are as for `String.format`\n     *  (@see java.lang.String.format).\n     */\n    @deprecated(\"Use `formatString.format(value)` instead of `value.formatted(formatString)`,\\nor use the `f\\\"\\\"` string interpolator. In Java 15 and later, `formatted` resolves to the new method in String which has reversed parameters.\", \"2.12.16\")\n    @inline def formatted(fmtstr: String): String \u003d fmtstr format self\n  }\n\n  /** Injects String concatenation operator `+` to any classes. \n   * @group implicit-classes-any\n   */\n  @(deprecated @companionMethod)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\")\n  @(deprecated @companionClass)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\") // for Scaladoc\n  // scala/bug#8229 retaining the pre 2.11 name for source compatibility in shadowing this implicit\n  implicit final class any2stringadd[A](private val self: A) extends AnyVal {\n    def +(other: String): String \u003d String.valueOf(self) + other\n  }\n\n  /** @group char-sequence-wrappers */\n  final class SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]) extends CharSequence {\n    def length: Int                                     \u003d sequenceOfChars.length\n    def charAt(index: Int): Char                        \u003d sequenceOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence \u003d new SeqCharSequence(sequenceOfChars.slice(start, end))\n    override def toString                               \u003d sequenceOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]): SeqCharSequence \u003d new SeqCharSequence(sequenceOfChars)\n\n  /** @group char-sequence-wrappers */\n  final class ArrayCharSequence(arrayOfChars: Array[Char]) extends CharSequence {\n    def length: Int                                     \u003d arrayOfChars.length\n    def charAt(index: Int): Char                        \u003d arrayOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence \u003d new runtime.ArrayCharSequence(arrayOfChars, start, end)\n    override def toString                               \u003d arrayOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def ArrayCharSequence(arrayOfChars: Array[Char]): ArrayCharSequence \u003d new ArrayCharSequence(arrayOfChars)\n\n  /** @group conversions-string */\n  @inline implicit def augmentString(x: String): StringOps \u003d new StringOps(x)\n\n  // printing -----------------------------------------------------------\n\n  /** Prints an object to `out` using its `toString` method.\n   *\n   *  @param x the object to print; may be null.\n   *  @group console-output\n   */\n  def print(x: Any): Unit \u003d Console.print(x)\n\n  /** Prints a newline character on the default output.\n   *  @group console-output\n   */\n  def println(): Unit \u003d Console.println()\n\n  /** Prints out an object to the default output, followed by a newline character.\n   *\n   *  @param x the object to print.\n   *  @group console-output\n   */\n  def println(x: Any): Unit \u003d Console.println(x)\n\n  /** Prints its arguments as a formatted string to the default output,\n   *  based on a string pattern (in a fashion similar to printf in C).\n   *\n   *  The interpretation of the formatting patterns is described in\n   *  [[java.util.Formatter]].\n   *\n   *  Consider using the [[scala.StringContext.f f interpolator]] as more type safe and idiomatic.\n   *\n   *  @param text the pattern for formatting the arguments.\n   *  @param xs   the arguments used to instantiate the pattern.\n   *  @throws java.lang.IllegalArgumentException if there was a problem with the format string or arguments\n   *\n   *  @see [[scala.StringContext.f StringContext.f]]\n   *  @group console-output\n   */\n  def printf(text: String, xs: Any*): Unit \u003d Console.print(text.format(xs: _*))\n\n  // views --------------------------------------------------------------\n\n  // these two are morally deprecated but the @deprecated annotation has been moved to the extension method themselves,\n  // in order to provide a more specific deprecation method.\n  implicit def tuple2ToZippedOps[T1, T2](x: (T1, T2)): runtime.Tuple2Zipped.Ops[T1, T2]             \u003d new runtime.Tuple2Zipped.Ops(x)\n  implicit def tuple3ToZippedOps[T1, T2, T3](x: (T1, T2, T3)): runtime.Tuple3Zipped.Ops[T1, T2, T3] \u003d new runtime.Tuple3Zipped.Ops(x)\n\n  // Not specialized anymore since 2.13 but we still need separate methods\n  // to avoid https://github.com/scala/bug/issues/10746\n  // TODO: should not need @inline. add heuristic to inline factories for value classes.\n  @inline implicit def genericArrayOps[T](xs: Array[T]): ArrayOps[T]          \u003d new ArrayOps(xs)\n  @inline implicit def booleanArrayOps(xs: Array[Boolean]): ArrayOps[Boolean] \u003d new ArrayOps(xs)\n  @inline implicit def byteArrayOps(xs: Array[Byte]): ArrayOps[Byte]          \u003d new ArrayOps(xs)\n  @inline implicit def charArrayOps(xs: Array[Char]): ArrayOps[Char]          \u003d new ArrayOps(xs)\n  @inline implicit def doubleArrayOps(xs: Array[Double]): ArrayOps[Double]    \u003d new ArrayOps(xs)\n  @inline implicit def floatArrayOps(xs: Array[Float]): ArrayOps[Float]       \u003d new ArrayOps(xs)\n  @inline implicit def intArrayOps(xs: Array[Int]): ArrayOps[Int]             \u003d new ArrayOps(xs)\n  @inline implicit def longArrayOps(xs: Array[Long]): ArrayOps[Long]          \u003d new ArrayOps(xs)\n  @inline implicit def refArrayOps[T \u003c: AnyRef](xs: Array[T]): ArrayOps[T]    \u003d new ArrayOps(xs)\n  @inline implicit def shortArrayOps(xs: Array[Short]): ArrayOps[Short]       \u003d new ArrayOps(xs)\n  @inline implicit def unitArrayOps(xs: Array[Unit]): ArrayOps[Unit]          \u003d new ArrayOps(xs)\n\n  // \"Autoboxing\" and \"Autounboxing\" ---------------------------------------------------\n\n  /** @group conversions-anyval-to-java */\n  implicit def byte2Byte(x: Byte): java.lang.Byte             \u003d x.asInstanceOf[java.lang.Byte]\n  /** @group conversions-anyval-to-java */\n  implicit def short2Short(x: Short): java.lang.Short         \u003d x.asInstanceOf[java.lang.Short]\n  /** @group conversions-anyval-to-java */\n  implicit def char2Character(x: Char): java.lang.Character   \u003d x.asInstanceOf[java.lang.Character]\n  /** @group conversions-anyval-to-java */\n  implicit def int2Integer(x: Int): java.lang.Integer         \u003d x.asInstanceOf[java.lang.Integer]\n  /** @group conversions-anyval-to-java */\n  implicit def long2Long(x: Long): java.lang.Long             \u003d x.asInstanceOf[java.lang.Long]\n  /** @group conversions-anyval-to-java */\n  implicit def float2Float(x: Float): java.lang.Float         \u003d x.asInstanceOf[java.lang.Float]\n  /** @group conversions-anyval-to-java */\n  implicit def double2Double(x: Double): java.lang.Double     \u003d x.asInstanceOf[java.lang.Double]\n  /** @group conversions-anyval-to-java */\n  implicit def boolean2Boolean(x: Boolean): java.lang.Boolean \u003d x.asInstanceOf[java.lang.Boolean]\n\n  /** @group conversions-java-to-anyval */\n  implicit def Byte2byte(x: java.lang.Byte): Byte             \u003d x.asInstanceOf[Byte]\n  /** @group conversions-java-to-anyval */\n  implicit def Short2short(x: java.lang.Short): Short         \u003d x.asInstanceOf[Short]\n  /** @group conversions-java-to-anyval */\n  implicit def Character2char(x: java.lang.Character): Char   \u003d x.asInstanceOf[Char]\n  /** @group conversions-java-to-anyval */\n  implicit def Integer2int(x: java.lang.Integer): Int         \u003d x.asInstanceOf[Int]\n  /** @group conversions-java-to-anyval */\n  implicit def Long2long(x: java.lang.Long): Long             \u003d x.asInstanceOf[Long]\n  /** @group conversions-java-to-anyval */\n  implicit def Float2float(x: java.lang.Float): Float         \u003d x.asInstanceOf[Float]\n  /** @group conversions-java-to-anyval */\n  implicit def Double2double(x: java.lang.Double): Double     \u003d x.asInstanceOf[Double]\n  /** @group conversions-java-to-anyval */\n  implicit def Boolean2boolean(x: java.lang.Boolean): Boolean \u003d x.asInstanceOf[Boolean]\n\n  /** An implicit of type `A \u003d\u003e A` is available for all `A` because it can always\n   *  be implemented using the identity function. This also means that an\n   *  implicit of type `A \u003d\u003e B` is always available when `A \u003c: B`, because\n   *  `(A \u003d\u003e A) \u003c: (A \u003d\u003e B)`.\n   */\n  // $ to avoid accidental shadowing (e.g. scala/bug#7788)\n  implicit def $conforms[A]: A \u003d\u003e A \u003d \u003c:\u003c.refl\n}\n\n/** The `LowPriorityImplicits` class provides implicit values that\n*  are valid in all Scala compilation units without explicit qualification,\n*  but that are partially overridden by higher-priority conversions in object\n*  `Predef`.\n*/\n// scala/bug#7335 Parents of Predef are defined in the same compilation unit to avoid\n// cyclic reference errors compiling the standard library *without* a previously\n// compiled copy on the classpath.\nprivate[scala] abstract class LowPriorityImplicits extends LowPriorityImplicits2 {\n  import mutable.ArraySeq\n\n  /** We prefer the java.lang.* boxed types to these wrappers in\n   *  any potential conflicts.  Conflicts do exist because the wrappers\n   *  need to implement ScalaNumber in order to have a symmetric equals\n   *  method, but that implies implementing java.lang.Number as well.\n   *\n   *  Note - these are inlined because they are value classes, but\n   *  the call to xxxWrapper is not eliminated even though it does nothing.\n   *  Even inlined, every call site does a no-op retrieval of Predef\u0027s MODULE$\n   *  because maybe loading Predef has side effects!\n   */\n  @inline implicit def byteWrapper(x: Byte): runtime.RichByte          \u003d new runtime.RichByte(x)\n  @inline implicit def shortWrapper(x: Short): runtime.RichShort       \u003d new runtime.RichShort(x)\n  @inline implicit def intWrapper(x: Int): runtime.RichInt             \u003d new runtime.RichInt(x)\n  @inline implicit def charWrapper(c: Char): runtime.RichChar          \u003d new runtime.RichChar(c)\n  @inline implicit def longWrapper(x: Long): runtime.RichLong          \u003d new runtime.RichLong(x)\n  @inline implicit def floatWrapper(x: Float): runtime.RichFloat       \u003d new runtime.RichFloat(x)\n  @inline implicit def doubleWrapper(x: Double): runtime.RichDouble    \u003d new runtime.RichDouble(x)\n  @inline implicit def booleanWrapper(x: Boolean): runtime.RichBoolean \u003d new runtime.RichBoolean(x)\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def genericWrapArray[T](xs: Array[T]): ArraySeq[T] \u003d\n    if (xs eq null) null\n    else ArraySeq.make(xs)\n\n  // Since the JVM thinks arrays are covariant, one 0-length Array[AnyRef]\n  // is as good as another for all T \u003c: AnyRef.  Instead of creating 100,000,000\n  // unique ones by way of this implicit, let\u0027s share one.\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapRefArray[T \u003c: AnyRef](xs: Array[T]): ArraySeq.ofRef[T] \u003d {\n    if (xs eq null) null\n    else if (xs.length \u003d\u003d 0) ArraySeq.empty[AnyRef].asInstanceOf[ArraySeq.ofRef[T]]\n    else new ArraySeq.ofRef[T](xs)\n  }\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapIntArray(xs: Array[Int]): ArraySeq.ofInt \u003d if (xs ne null) new ArraySeq.ofInt(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapDoubleArray(xs: Array[Double]): ArraySeq.ofDouble \u003d if (xs ne null) new ArraySeq.ofDouble(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapLongArray(xs: Array[Long]): ArraySeq.ofLong \u003d if (xs ne null) new ArraySeq.ofLong(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapFloatArray(xs: Array[Float]): ArraySeq.ofFloat \u003d if (xs ne null) new ArraySeq.ofFloat(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapCharArray(xs: Array[Char]): ArraySeq.ofChar \u003d if (xs ne null) new ArraySeq.ofChar(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapByteArray(xs: Array[Byte]): ArraySeq.ofByte \u003d if (xs ne null) new ArraySeq.ofByte(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapShortArray(xs: Array[Short]): ArraySeq.ofShort \u003d if (xs ne null) new ArraySeq.ofShort(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapBooleanArray(xs: Array[Boolean]): ArraySeq.ofBoolean \u003d if (xs ne null) new ArraySeq.ofBoolean(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapUnitArray(xs: Array[Unit]): ArraySeq.ofUnit \u003d if (xs ne null) new ArraySeq.ofUnit(xs) else null\n\n  /** @group conversions-string */\n  implicit def wrapString(s: String): WrappedString \u003d if (s ne null) new WrappedString(s) else null\n}\n\nprivate[scala] abstract class LowPriorityImplicits2 {\n  @deprecated(\"implicit conversions from Array to immutable.IndexedSeq are implemented by copying; use `toIndexedSeq` explicitly if you want to copy, or use the more efficient non-copying ArraySeq.unsafeWrapArray\", since\u003d\"2.13.0\")\n  implicit def copyArrayToImmutableIndexedSeq[T](xs: Array[T]): IndexedSeq[T] \u003d\n    if (xs eq null) null\n    else new ArrayOps(xs).toIndexedSeq\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:15:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 6091
2024.04.26 03:16:50 INFO  compiling root (1 scala source)
2024.04.26 03:16:50 INFO  time: compiled root in 0.22s
2024.04.26 03:16:50 INFO  compiling root (1 scala source)
2024.04.26 03:16:50 INFO  time: compiled root in 99ms
2024.04.26 03:17:53 INFO  compiling root (1 scala source)
2024.04.26 03:17:53 INFO  time: compiled root in 0.2s
2024.04.26 03:17:53 INFO  compiling root (1 scala source)
2024.04.26 03:17:53 INFO  time: compiled root in 99ms
Apr. 26, 2024 3:18:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/immutable/List.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/immutable/List.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:18:29 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:18:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\nimport scala.annotation.migration\n\n/**\n * Core Scala types. They are always available without an explicit import.\n * @contentDiagram hideNodes \"scala.Serializable\"\n */\npackage object scala {\n  type Cloneable    \u003d java.lang.Cloneable\n  type Serializable \u003d java.io.Serializable\n\n  type Throwable \u003d java.lang.Throwable\n  type Exception \u003d java.lang.Exception\n  type Error     \u003d java.lang.Error\n\n  type RuntimeException                \u003d java.lang.RuntimeException\n  type NullPointerException            \u003d java.lang.NullPointerException\n  type ClassCastException              \u003d java.lang.ClassCastException\n  type IndexOutOfBoundsException       \u003d java.lang.IndexOutOfBoundsException\n  type ArrayIndexOutOfBoundsException  \u003d java.lang.ArrayIndexOutOfBoundsException\n  type StringIndexOutOfBoundsException \u003d java.lang.StringIndexOutOfBoundsException\n  type UnsupportedOperationException   \u003d java.lang.UnsupportedOperationException\n  type IllegalArgumentException        \u003d java.lang.IllegalArgumentException\n  type NoSuchElementException          \u003d java.util.NoSuchElementException\n  type NumberFormatException           \u003d java.lang.NumberFormatException\n  type AbstractMethodError             \u003d java.lang.AbstractMethodError\n  type InterruptedException            \u003d java.lang.InterruptedException\n\n  // A dummy used by the specialization annotation.\n  val AnyRef \u003d new Specializable {\n    override def toString \u003d \"object AnyRef\"\n  }\n\n  @deprecated(\"Use IterableOnce instead of TraversableOnce\", \"2.13.0\")\n  type TraversableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  type IterableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  type Traversable[+A] \u003d scala.collection.Iterable[A]\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  val Traversable \u003d scala.collection.Iterable\n\n  type Iterable[+A] \u003d scala.collection.Iterable[A]\n  val Iterable \u003d scala.collection.Iterable\n\n  @migration(\"scala.Seq is now scala.collection.immutable.Seq instead of scala.collection.Seq\", \"2.13.0\")\n  type Seq[+A] \u003d scala.collection.immutable.Seq[A]\n  val Seq \u003d scala.collection.immutable.Seq\n\n  @migration(\"scala.IndexedSeq is now scala.collection.immutable.IndexedSeq instead of scala.collection.IndexedSeq\", \"2.13.0\")\n  type IndexedSeq[+A] \u003d scala.collection.immutable.IndexedSeq[A]\n  val IndexedSeq \u003d scala.collection.immutable.IndexedSeq\n\n  type Iterator[+A] \u003d scala.collection.Iterator[A]\n  val Iterator \u003d scala.collection.Iterator\n\n  @deprecated(\"Use scala.collection.BufferedIterator instead of scala.BufferedIterator\", \"2.13.0\")\n  type BufferedIterator[+A] \u003d scala.collection.BufferedIterator[A]\n\n  type List[+A] \u003d scala.collection.immutable.List[A]\n  val List \u003d scala.collection.immutable.List\n\n  val Nil \u003d scala.collection.immutable.Nil\n\n  type ::[+A] \u003d scala.collection.immutable.::[A]\n  val :: \u003d scala.collection.immutable.::\n\n  val +: \u003d scala.collection.+:\n  val :+ \u003d scala.collection.:+\n\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  type Stream[+A] \u003d scala.collection.immutable.Stream[A]\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  val Stream \u003d scala.collection.immutable.Stream\n\n  type LazyList[+A] \u003d scala.collection.immutable.LazyList[A]\n  val LazyList \u003d scala.collection.immutable.LazyList\n  // This should be an alias to LazyList.#:: but we need to support Stream, too\n  //val #:: \u003d scala.collection.immutable.LazyList.#::\n  object #:: {\n    def unapply[A](s: LazyList[A]): Option[(A, LazyList[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n    @deprecated(\"Prefer LazyList instead\", since \u003d \"2.13.0\")\n    def unapply[A](s: Stream[A]): Option[(A, Stream[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n  }\n\n  type Vector[+A] \u003d scala.collection.immutable.Vector[A]\n  val Vector \u003d scala.collection.immutable.Vector\n\n  type StringBuilder \u003d scala.collection.mutable.StringBuilder\n  val StringBuilder \u003d scala.collection.mutable.StringBuilder\n\n  type Range \u003d scala.collection.immutable.Range\n  val Range \u003d scala.collection.immutable.Range\n\n  // Numeric types which were moved into scala.math.*\n\n  type BigDecimal \u003d scala.math.BigDecimal\n  val BigDecimal \u003d scala.math.BigDecimal\n\n  type BigInt \u003d scala.math.BigInt\n  val BigInt \u003d scala.math.BigInt\n\n  type Equiv[T] \u003d scala.math.Equiv[T]\n  val Equiv \u003d scala.math.Equiv\n\n  type Fractional[T] \u003d scala.math.Fractional[T]\n  val Fractional \u003d scala.math.Fractional\n\n  type Integral[T] \u003d scala.math.Integral[T]\n  val Integral \u003d scala.math.Integral\n\n  type Numeric[T] \u003d scala.math.Numeric[T]\n  val Numeric \u003d scala.math.Numeric\n\n  type Ordered[T] \u003d scala.math.Ordered[T]\n  val Ordered \u003d scala.math.Ordered\n\n  type Ordering[T] \u003d scala.math.Ordering[T]\n  val Ordering \u003d scala.math.Ordering\n\n  type PartialOrdering[T] \u003d scala.math.PartialOrdering[T]\n  type PartiallyOrdered[T] \u003d scala.math.PartiallyOrdered[T]\n\n  type Either[+A, +B] \u003d scala.util.Either[A, B]\n  val Either \u003d scala.util.Either\n\n  type Left[+A, +B] \u003d scala.util.Left[A, B]\n  val Left \u003d scala.util.Left\n\n  type Right[+A, +B] \u003d scala.util.Right[A, B]\n  val Right \u003d scala.util.Right\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:18:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:18:29 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:18:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\nimport scala.annotation.migration\n\n/**\n * Core Scala types. They are always available without an explicit import.\n * @contentDiagram hideNodes \"scala.Serializable\"\n */\npackage object scala {\n  type Cloneable    \u003d java.lang.Cloneable\n  type Serializable \u003d java.io.Serializable\n\n  type Throwable \u003d java.lang.Throwable\n  type Exception \u003d java.lang.Exception\n  type Error     \u003d java.lang.Error\n\n  type RuntimeException                \u003d java.lang.RuntimeException\n  type NullPointerException            \u003d java.lang.NullPointerException\n  type ClassCastException              \u003d java.lang.ClassCastException\n  type IndexOutOfBoundsException       \u003d java.lang.IndexOutOfBoundsException\n  type ArrayIndexOutOfBoundsException  \u003d java.lang.ArrayIndexOutOfBoundsException\n  type StringIndexOutOfBoundsException \u003d java.lang.StringIndexOutOfBoundsException\n  type UnsupportedOperationException   \u003d java.lang.UnsupportedOperationException\n  type IllegalArgumentException        \u003d java.lang.IllegalArgumentException\n  type NoSuchElementException          \u003d java.util.NoSuchElementException\n  type NumberFormatException           \u003d java.lang.NumberFormatException\n  type AbstractMethodError             \u003d java.lang.AbstractMethodError\n  type InterruptedException            \u003d java.lang.InterruptedException\n\n  // A dummy used by the specialization annotation.\n  val AnyRef \u003d new Specializable {\n    override def toString \u003d \"object AnyRef\"\n  }\n\n  @deprecated(\"Use IterableOnce instead of TraversableOnce\", \"2.13.0\")\n  type TraversableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  type IterableOnce[+A] \u003d scala.collection.IterableOnce[A]\n\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  type Traversable[+A] \u003d scala.collection.Iterable[A]\n  @deprecated(\"Use Iterable instead of Traversable\", \"2.13.0\")\n  val Traversable \u003d scala.collection.Iterable\n\n  type Iterable[+A] \u003d scala.collection.Iterable[A]\n  val Iterable \u003d scala.collection.Iterable\n\n  @migration(\"scala.Seq is now scala.collection.immutable.Seq instead of scala.collection.Seq\", \"2.13.0\")\n  type Seq[+A] \u003d scala.collection.immutable.Seq[A]\n  val Seq \u003d scala.collection.immutable.Seq\n\n  @migration(\"scala.IndexedSeq is now scala.collection.immutable.IndexedSeq instead of scala.collection.IndexedSeq\", \"2.13.0\")\n  type IndexedSeq[+A] \u003d scala.collection.immutable.IndexedSeq[A]\n  val IndexedSeq \u003d scala.collection.immutable.IndexedSeq\n\n  type Iterator[+A] \u003d scala.collection.Iterator[A]\n  val Iterator \u003d scala.collection.Iterator\n\n  @deprecated(\"Use scala.collection.BufferedIterator instead of scala.BufferedIterator\", \"2.13.0\")\n  type BufferedIterator[+A] \u003d scala.collection.BufferedIterator[A]\n\n  type List[+A] \u003d scala.collection.immutable.List[A]\n  val List \u003d scala.collection.immutable.List\n\n  val Nil \u003d scala.collection.immutable.Nil\n\n  type ::[+A] \u003d scala.collection.immutable.::[A]\n  val :: \u003d scala.collection.immutable.::\n\n  val +: \u003d scala.collection.+:\n  val :+ \u003d scala.collection.:+\n\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  type Stream[+A] \u003d scala.collection.immutable.Stream[A]\n  @deprecated(\"Use LazyList instead of Stream\", \"2.13.0\")\n  val Stream \u003d scala.collection.immutable.Stream\n\n  type LazyList[+A] \u003d scala.collection.immutable.LazyList[A]\n  val LazyList \u003d scala.collection.immutable.LazyList\n  // This should be an alias to LazyList.#:: but we need to support Stream, too\n  //val #:: \u003d scala.collection.immutable.LazyList.#::\n  object #:: {\n    def unapply[A](s: LazyList[A]): Option[(A, LazyList[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n    @deprecated(\"Prefer LazyList instead\", since \u003d \"2.13.0\")\n    def unapply[A](s: Stream[A]): Option[(A, Stream[A])] \u003d\n      if (s.nonEmpty) Some((s.head, s.tail)) else None\n  }\n\n  type Vector[+A] \u003d scala.collection.immutable.Vector[A]\n  val Vector \u003d scala.collection.immutable.Vector\n\n  type StringBuilder \u003d scala.collection.mutable.StringBuilder\n  val StringBuilder \u003d scala.collection.mutable.StringBuilder\n\n  type Range \u003d scala.collection.immutable.Range\n  val Range \u003d scala.collection.immutable.Range\n\n  // Numeric types which were moved into scala.math.*\n\n  type BigDecimal \u003d scala.math.BigDecimal\n  val BigDecimal \u003d scala.math.BigDecimal\n\n  type BigInt \u003d scala.math.BigInt\n  val BigInt \u003d scala.math.BigInt\n\n  type Equiv[T] \u003d scala.math.Equiv[T]\n  val Equiv \u003d scala.math.Equiv\n\n  type Fractional[T] \u003d scala.math.Fractional[T]\n  val Fractional \u003d scala.math.Fractional\n\n  type Integral[T] \u003d scala.math.Integral[T]\n  val Integral \u003d scala.math.Integral\n\n  type Numeric[T] \u003d scala.math.Numeric[T]\n  val Numeric \u003d scala.math.Numeric\n\n  type Ordered[T] \u003d scala.math.Ordered[T]\n  val Ordered \u003d scala.math.Ordered\n\n  type Ordering[T] \u003d scala.math.Ordering[T]\n  val Ordering \u003d scala.math.Ordering\n\n  type PartialOrdering[T] \u003d scala.math.PartialOrdering[T]\n  type PartiallyOrdered[T] \u003d scala.math.PartiallyOrdered[T]\n\n  type Either[+A, +B] \u003d scala.util.Either[A, B]\n  val Either \u003d scala.util.Either\n\n  type Left[+A, +B] \u003d scala.util.Left[A, B]\n  val Left \u003d scala.util.Left\n\n  type Right[+A, +B] \u003d scala.util.Right[A, B]\n  val Right \u003d scala.util.Right\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:18:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Predef.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Predef.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:18:45 INFO  compiling root (1 scala source)
2024.04.26 03:18:45 INFO  time: compiled root in 0.12s
2024.04.26 03:18:52 INFO  compiling root (1 scala source)
2024.04.26 03:18:52 INFO  time: compiled root in 0.28s
2024.04.26 03:18:52 INFO  compiling root (1 scala source)
2024.04.26 03:18:52 INFO  time: compiled root in 0.14s
2024.04.26 03:20:35 INFO  compiling root (1 scala source)
2024.04.26 03:20:35 INFO  time: compiled root in 0.22s
2024.04.26 03:20:35 INFO  compiling root (1 scala source)
2024.04.26 03:20:35 INFO  time: compiled root in 0.14s
2024.04.26 03:20:35 INFO  compiling root (1 scala source)
2024.04.26 03:20:35 INFO  time: compiled root in 0.29s
2024.04.26 03:20:35 INFO  compiling root (1 scala source)
2024.04.26 03:20:35 INFO  time: compiled root in 0.17s
2024.04.26 03:20:59 INFO  compiling root (1 scala source)
2024.04.26 03:20:59 INFO  time: compiled root in 0.21s
2024.04.26 03:21:15 INFO  compiling root (1 scala source)
2024.04.26 03:21:15 INFO  time: compiled root in 0.29s
2024.04.26 03:21:16 INFO  compiling root (1 scala source)
2024.04.26 03:21:16 INFO  time: compiled root in 0.38s
2024.04.26 03:21:24 INFO  compiling root (1 scala source)
2024.04.26 03:21:24 INFO  time: compiled root in 0.2s
2024.04.26 03:21:24 INFO  compiling root (1 scala source)
2024.04.26 03:21:25 INFO  time: compiled root in 0.24s
Apr. 26, 2024 3:21:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/package.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/package.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:21:30 INFO  compiling root (1 scala source)
2024.04.26 03:21:30 INFO  time: compiled root in 0.2s
2024.04.26 03:21:30 INFO  compiling root (1 scala source)
2024.04.26 03:21:30 INFO  time: compiled root in 0.19s
Apr. 26, 2024 3:22:17 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 7053
2024.04.26 03:22:59 INFO  compiling root (1 scala source)
2024.04.26 03:22:59 INFO  time: compiled root in 0.1s
2024.04.26 03:23:07 INFO  compiling root (1 scala source)
2024.04.26 03:23:07 INFO  time: compiled root in 0.2s
2024.04.26 03:23:07 INFO  compiling root (1 scala source)
2024.04.26 03:23:07 INFO  time: compiled root in 93ms
Apr. 26, 2024 3:23:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 7342
2024.04.26 03:23:57 INFO  compiling root (1 scala source)
2024.04.26 03:23:57 INFO  time: compiled root in 0.19s
2024.04.26 03:25:05 INFO  compiling root (1 scala source)
2024.04.26 03:25:05 INFO  time: compiled root in 0.25s
2024.04.26 03:25:05 INFO  compiling root (1 scala source)
2024.04.26 03:25:05 INFO  time: compiled root in 0.11s
Apr. 26, 2024 3:25:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 7547
2024.04.26 03:25:47 INFO  compiling root (1 scala source)
2024.04.26 03:25:47 INFO  time: compiled root in 0.19s
2024.04.26 03:25:47 INFO  compiling root (1 scala source)
2024.04.26 03:25:47 INFO  time: compiled root in 0.11s
2024.04.26 03:26:16 INFO  Canceling debug proxy for [Chess.ChessGame]
2024.04.26 03:26:16 INFO  Closing debug server tcp://0.0.0.0:56609
2024.04.26 03:26:30 INFO  compiling root (2 scala sources)
2024.04.26 03:26:30 INFO  time: compiled root in 0.2s
2024.04.26 03:27:19 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:27:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/mutable/StringBuilder.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala.collection.mutable\n\nimport scala.collection.{IterableFactoryDefaults, IterableOnce}\nimport scala.collection.immutable.WrappedString\n\nimport scala.Predef.{ // unimport char-related implicit conversions to avoid triggering them accidentally\n  genericArrayOps \u003d\u003e _,\n  charArrayOps \u003d\u003e _,\n  genericWrapArray \u003d\u003e _,\n  wrapCharArray \u003d\u003e _,\n  wrapString \u003d\u003e _,\n //_\n}\n\n/** A builder of `String` which is also a mutable sequence of characters.\n *\n *  This class provides an API mostly compatible with `java.lang.StringBuilder`,\n *  except where there are conflicts with the Scala collections API, such as the `reverse` method:\n *  [[reverse]] produces a new `StringBuilder`, and [[reverseInPlace]] mutates this builder.\n *\n *  Mutating operations return either `this.type`, i.e., the current builder, or `Unit`.\n *\n *  Other methods extract data or information from the builder without mutating it.\n *\n *  The distinction is also reflected in naming conventions used by collections,\n *  such as `append`, which mutates, and `appended`, which does not, or `reverse`,\n *  which does not mutate, and `reverseInPlace`, which does.\n *\n *  The `String` result may be obtained using either `result()` or `toString`.\n *\n *  $multipleResults\n *\n *  @see [[https://docs.scala-lang.org/overviews/collections-2.13/concrete-mutable-collection-classes.html#stringbuilders \"Scala\u0027s Collection Library overview\"]]\n *  section on `StringBuilders` for more information.\n *\n *  @define Coll `mutable.IndexedSeq`\n *  @define coll string builder\n */\n@SerialVersionUID(3L)\nfinal class StringBuilder(val underlying: java.lang.StringBuilder) extends AbstractSeq[Char]\n  with ReusableBuilder[Char, String]\n  with IndexedSeq[Char]\n  with IndexedSeqOps[Char, IndexedSeq, StringBuilder]\n  with IterableFactoryDefaults[Char, IndexedSeq]\n  with java.lang.CharSequence\n  with Serializable {\n\n  def this() \u003d this(new java.lang.StringBuilder)\n\n  /** Constructs a string builder with no characters in it and an\n    *  initial capacity specified by the `capacity` argument.\n    *\n    *  @param  capacity  the initial capacity.\n    *  @throws java.lang.NegativeArraySizeException  if capacity \u003c 0.\n    */\n  def this(capacity: Int) \u003d this(new java.lang.StringBuilder(capacity))\n\n  /** Constructs a string builder with initial characters\n    *  equal to characters of `str`.\n    */\n  def this(str: String) \u003d this(new java.lang.StringBuilder(str))\n\n  /** Constructs a string builder initialized with string value `initValue`\n    *  and with additional character capacity `initCapacity`.\n    */\n  def this(initCapacity: Int, initValue: String) \u003d\n    this(new java.lang.StringBuilder(initValue.length + initCapacity) append initValue)\n\n  // Methods required to make this an IndexedSeq:\n  def apply(i: Int): Char \u003d underlying.charAt(i)\n\n  override protected def fromSpecific(coll: scala.collection.IterableOnce[Char]): StringBuilder \u003d\n    new StringBuilder() appendAll coll\n\n  override protected def newSpecificBuilder: Builder[Char, StringBuilder] \u003d\n    new GrowableBuilder(new StringBuilder())\n\n  override def empty: StringBuilder \u003d new StringBuilder()\n\n  @inline def length: Int \u003d underlying.length\n\n  def length_\u003d(n: Int): Unit \u003d underlying.setLength(n)\n\n  override def knownSize: Int \u003d super[IndexedSeqOps].knownSize\n\n  def addOne(x: Char): this.type \u003d { underlying.append(x); this }\n\n  def clear(): Unit \u003d underlying.setLength(0)\n\n  /** Overloaded version of `addAll` that takes a string */\n  def addAll(s: String): this.type \u003d { underlying.append(s); this }\n\n  /** Alias for `addAll` */\n  def ++\u003d (s: String): this.type \u003d addAll(s)\n\n  def result() \u003d underlying.toString\n\n  override def toString: String \u003d result()\n\n  override def toArray[B \u003e: Char](implicit ct: scala.reflect.ClassTag[B]) \u003d\n    ct.runtimeClass match {\n      case java.lang.Character.TYPE \u003d\u003e toCharArray.asInstanceOf[Array[B]]\n      case _ \u003d\u003e super.toArray\n    }\n\n  /** Returns the contents of this StringBuilder as an `Array[Char]`.\n   *\n   *  @return  An array with the characters from this builder.\n   */\n  def toCharArray: Array[Char] \u003d {\n    val len \u003d underlying.length\n    val arr \u003d new Array[Char](len)\n    underlying.getChars(0, len, arr, 0)\n    arr\n  }\n\n  // append* methods delegate to the underlying java.lang.StringBuilder:\n\n  def appendAll(xs: String): this.type \u003d {\n    underlying append xs\n    this\n  }\n\n  /** Appends the string representation of the given argument,\n    *  which is converted to a String with `String.valueOf`.\n    *\n    *  @param  x   an `Any` object.\n    *  @return     this StringBuilder.\n    */\n  def append(x: Any): this.type \u003d {\n    underlying append String.valueOf(x)\n    this\n  }\n\n  /** Appends the given String to this sequence.\n    *\n    *  @param  s   a String.\n    *  @return     this StringBuilder.\n    */\n  def append(s: String): this.type \u003d {\n    underlying append s\n    this\n  }\n\n  /** Appends the given CharSequence to this sequence.\n    *\n    *  @param  cs   a CharSequence.\n    *  @return     this StringBuilder.\n    */\n  def append(cs: java.lang.CharSequence): this.type \u003d {\n    underlying.append(cs match {\n      // Both cases call into append(\u003cCharSequence\u003e), but java SB\n      // looks up type at runtime and has fast path for SB.\n      case s: StringBuilder \u003d\u003e s.underlying\n      case _                \u003d\u003e cs\n    })\n    this\n  }\n\n  /** Appends the specified string builder to this sequence.\n    *\n    *  @param s\n    *  @return\n    */\n  def append(s: StringBuilder): this.type \u003d {\n    underlying append s.underlying\n    this\n  }\n\n  /** Appends all the Chars in the given IterableOnce[Char] to this sequence.\n    *\n    *  @param  xs  the characters to be appended.\n    *  @return     this StringBuilder.\n    */\n  def appendAll(xs: IterableOnce[Char]): this.type \u003d {\n    xs match {\n      case x: WrappedString \u003d\u003e underlying append x.unwrap\n      case x: ArraySeq.ofChar \u003d\u003e underlying append x.array\n      case x: StringBuilder \u003d\u003e underlying append x.underlying\n      case _ \u003d\u003e\n        val ks \u003d xs.knownSize\n        if (ks !\u003d 0) {\n          val b \u003d underlying\n          if (ks \u003e 0) b.ensureCapacity(b.length + ks)\n          val it \u003d xs.iterator\n          while (it.hasNext) { b append it.next() }\n        }\n    }\n    this\n  }\n\n  /** Appends all the Chars in the given Array[Char] to this sequence.\n    *\n    *  @param  xs  the characters to be appended.\n    *  @return     a reference to this object.\n    */\n  def appendAll(xs: Array[Char]): this.type \u003d {\n    underlying append xs\n    this\n  }\n\n  /** Appends a portion of the given Array[Char] to this sequence.\n    *\n    *  @param  xs      the Array containing Chars to be appended.\n    *  @param  offset  the index of the first Char to append.\n    *  @param  len     the numbers of Chars to append.\n    *  @return         this StringBuilder.\n    */\n  def appendAll(xs: Array[Char], offset: Int, len: Int): this.type \u003d {\n    underlying.append(xs, offset, len)\n    this\n  }\n\n  /** Append the String representation of the given primitive type\n    *  to this sequence.  The argument is converted to a String with\n    *  String.valueOf.\n    *\n    *  @param   x  a primitive value\n    *  @return     This StringBuilder.\n    */\n  def append(x: Boolean): this.type \u003d { underlying append x ; this }\n  def append(x: Byte): this.type \u003d append(x.toInt)\n  def append(x: Short): this.type \u003d append(x.toInt)\n  def append(x: Int): this.type \u003d { underlying append x ; this }\n  def append(x: Long): this.type \u003d { underlying append x ; this }\n  def append(x: Float): this.type \u003d { underlying append x ; this }\n  def append(x: Double): this.type \u003d { underlying append x ; this }\n  def append(x: Char): this.type \u003d { underlying append x ; this }\n\n  /** Remove a subsequence of Chars from this sequence, starting at the\n    *  given start index (inclusive) and extending to the end index (exclusive)\n    *  or to the end of the String, whichever comes first.\n    *\n    *  @param  start  The beginning index, inclusive.\n    *  @param  end    The ending index, exclusive.\n    *  @return        This StringBuilder.\n    *  @throws StringIndexOutOfBoundsException   if start \u003c 0 || start \u003e end\n    */\n  def delete(start: Int, end: Int): this.type \u003d {\n    underlying.delete(start, end)\n    this\n  }\n\n  /** Replaces a subsequence of Chars with the given String.  The semantics\n    *  are as in delete, with the String argument then inserted at index \u0027start\u0027.\n    *\n    *  @param  start  The beginning index, inclusive.\n    *  @param  end    The ending index, exclusive.\n    *  @param  str    The String to be inserted at the start index.\n    *  @return        This StringBuilder.\n    *  @throws StringIndexOutOfBoundsException if start \u003c 0, start \u003e length, or start \u003e end\n    */\n  def replace(start: Int, end: Int, str: String): this.type \u003d {\n    underlying.replace(start, end, str)\n    this\n  }\n\n  /** Inserts a subarray of the given Array[Char] at the given index\n    *  of this sequence.\n    *\n    * @param  index   index at which to insert the subarray.\n    * @param  str     the Array from which Chars will be taken.\n    * @param  offset  the index of the first Char to insert.\n    * @param  len     the number of Chars from \u0027str\u0027 to insert.\n    * @return         This StringBuilder.\n    *\n    * @throws StringIndexOutOfBoundsException  if index \u003c 0, index \u003e length,\n    *         offset \u003c 0, len \u003c 0, or (offset + len) \u003e str.length.\n    */\n  def insertAll(index: Int, str: Array[Char], offset: Int, len: Int): this.type \u003d {\n    underlying.insert(index, str, offset, len)\n    this\n  }\n\n  /** Inserts the String representation (via String.valueOf) of the given\n    *  argument into this sequence at the given index.\n    *\n    *  @param  index   the index at which to insert.\n    *  @param  x       a value.\n    *  @return         this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insert(index: Int, x: Any): this.type \u003d insert(index, String.valueOf(x))\n\n  /** Inserts the String into this character sequence.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  x     a String.\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insert(index: Int, x: String): this.type \u003d {\n    underlying.insert(index, x)\n    this\n  }\n\n  /** Inserts the given Seq[Char] into this sequence at the given index.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  xs    the Seq[Char].\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insertAll(index: Int, xs: IterableOnce[Char]): this.type \u003d\n    insertAll(index, (ArrayBuilder.make[Char] ++\u003d xs).result())\n\n  /** Inserts the given Array[Char] into this sequence at the given index.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  xs    the Array[Char].\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insertAll(index: Int, xs: Array[Char]): this.type \u003d {\n    underlying.insert(index, xs)\n    this\n  }\n\n  /** Calls String.valueOf on the given primitive value, and inserts the\n    *  String at the given index.\n    *\n    *  @param  index the offset position.\n    *  @param  x     a primitive value.\n    *  @return       this StringBuilder.\n    */\n  def insert(index: Int, x: Boolean): this.type \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Byte): this.type    \u003d insert(index, x.toInt)\n  def insert(index: Int, x: Short): this.type   \u003d insert(index, x.toInt)\n  def insert(index: Int, x: Int): this.type     \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Long): this.type    \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Float): this.type   \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Double): this.type  \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Char): this.type    \u003d insert(index, String.valueOf(x))\n\n  /** Sets the length of the character sequence.  If the current sequence\n    *  is shorter than the given length, it is padded with nulls; if it is\n    *  longer, it is truncated.\n    *\n    *  @param  len  the new length\n    *  @throws IndexOutOfBoundsException if the argument is negative.\n    */\n  def setLength(len: Int): Unit \u003d underlying.setLength(len)\n\n  def update(idx: Int, elem: Char): Unit \u003d underlying.setCharAt(idx, elem)\n\n\n  /** Like reverse, but destructively updates the target StringBuilder.\n   *\n   *  @return   the reversed StringBuilder (same as the target StringBuilder)\n   */\n  @deprecated(\"Use reverseInPlace instead\", \"2.13.0\")\n  final def reverseContents(): this.type \u003d reverseInPlace()\n\n  /** Like reverse, but destructively updates the target StringBuilder.\n   *\n   *  @return   the reversed StringBuilder (same as the target StringBuilder)\n   */\n  def reverseInPlace(): this.type \u003d {\n    underlying.reverse()\n    this\n  }\n\n\n  /** Returns the current capacity, which is the size of the underlying array.\n   *  A new array will be allocated if the current capacity is exceeded.\n   *\n   *  @return  the capacity\n   */\n  def capacity: Int \u003d underlying.capacity\n\n  /** Ensure that the capacity is at least the given argument.\n   *  If the argument is greater than the current capacity, new\n   *  storage will be allocated with size equal to the given\n   *  argument or to `(2 * capacity + 2)`, whichever is larger.\n   *\n   *  @param newCapacity    the minimum desired capacity.\n   */\n  def ensureCapacity(newCapacity: Int): Unit \u003d { underlying.ensureCapacity(newCapacity) }\n\n  /** Returns the Char at the specified index, counting from 0 as in Arrays.\n   *\n   *  @param  index   the index to look up\n   *  @return         the Char at the given index.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def charAt(index: Int): Char \u003d underlying.charAt(index)\n\n  /** Removes the Char at the specified index.  The sequence is\n   *  shortened by one.\n   *\n   *  @param  index  The index to remove.\n   *  @return        This StringBuilder.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def deleteCharAt(index: Int): this.type \u003d {\n    underlying.deleteCharAt(index)\n    this\n  }\n\n  /** Update the sequence at the given index to hold the specified Char.\n   *\n   *  @param  index   the index to modify.\n   *  @param  ch      the new Char.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def setCharAt(index: Int, ch: Char): this.type \u003d {\n    underlying.setCharAt(index, ch)\n    this\n  }\n\n  /** Returns a new String made up of a subsequence of this sequence,\n   *  beginning at the given index and extending to the end of the sequence.\n   *\n   *  target.substring(start)  is equivalent to  target.drop(start)\n   *\n   *  @param  start  The starting index, inclusive.\n   *  @return        The new String.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def substring(start: Int): String \u003d underlying.substring(start, length)\n\n  /** Returns a new String made up of a subsequence of this sequence,\n   *  beginning at the start index (inclusive) and extending to the\n   *  end index (exclusive).\n   *\n   *  target.substring(start, end)  is equivalent to  target.slice(start, end).mkString\n   *\n   *  @param  start  The beginning index, inclusive.\n   *  @param  end    The ending index, exclusive.\n   *  @return The new String.\n   *  @throws StringIndexOutOfBoundsException If either index is out of bounds,\n   *          or if start \u003e end.\n   */\n  def substring(start: Int, end: Int): String \u003d underlying.substring(start, end)\n\n  /** For implementing CharSequence.\n   */\n  def subSequence(start: Int, end: Int): java.lang.CharSequence \u003d\n    underlying.substring(start, end)\n\n  /** Finds the index of the first occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @return             the first applicable index where target occurs, or -1 if not found.\n   */\n  def indexOf(str: String): Int \u003d underlying.indexOf(str)\n\n  /** Finds the index of the first occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @param    fromIndex the smallest index in the source string to consider\n   *  @return             the first applicable index where target occurs, or -1 if not found.\n   */\n  def indexOf(str: String, fromIndex: Int): Int \u003d underlying.indexOf(str, fromIndex)\n\n  /** Finds the index of the last occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @return             the last applicable index where target occurs, or -1 if not found.\n   */\n  def lastIndexOf(str: String): Int \u003d underlying.lastIndexOf(str)\n\n  /** Finds the index of the last occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @param    fromIndex the smallest index in the source string to consider\n   *  @return             the last applicable index where target occurs, or -1 if not found.\n   */\n  def lastIndexOf(str: String, fromIndex: Int): Int \u003d underlying.lastIndexOf(str, fromIndex)\n\n  /** Tests whether this builder is empty.\n   *\n   *  This method is required for JDK15+ compatibility\n   *\n   *  @return  `true` if this builder contains nothing, `false` otherwise.\n   */\n  override def isEmpty: Boolean \u003d underlying.length() \u003d\u003d 0\n}\n\nobject StringBuilder {\n  @deprecated(\"Use `new StringBuilder()` instead of `StringBuilder.newBuilder`\", \"2.13.0\")\n  def newBuilder \u003d new StringBuilder\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:27:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/mutable/StringBuilder.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:27:19 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:27:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/mutable/StringBuilder.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala.collection.mutable\n\nimport scala.collection.{IterableFactoryDefaults, IterableOnce}\nimport scala.collection.immutable.WrappedString\n\nimport scala.Predef.{ // unimport char-related implicit conversions to avoid triggering them accidentally\n  genericArrayOps \u003d\u003e _,\n  charArrayOps \u003d\u003e _,\n  genericWrapArray \u003d\u003e _,\n  wrapCharArray \u003d\u003e _,\n  wrapString \u003d\u003e _,\n //_\n}\n\n/** A builder of `String` which is also a mutable sequence of characters.\n *\n *  This class provides an API mostly compatible with `java.lang.StringBuilder`,\n *  except where there are conflicts with the Scala collections API, such as the `reverse` method:\n *  [[reverse]] produces a new `StringBuilder`, and [[reverseInPlace]] mutates this builder.\n *\n *  Mutating operations return either `this.type`, i.e., the current builder, or `Unit`.\n *\n *  Other methods extract data or information from the builder without mutating it.\n *\n *  The distinction is also reflected in naming conventions used by collections,\n *  such as `append`, which mutates, and `appended`, which does not, or `reverse`,\n *  which does not mutate, and `reverseInPlace`, which does.\n *\n *  The `String` result may be obtained using either `result()` or `toString`.\n *\n *  $multipleResults\n *\n *  @see [[https://docs.scala-lang.org/overviews/collections-2.13/concrete-mutable-collection-classes.html#stringbuilders \"Scala\u0027s Collection Library overview\"]]\n *  section on `StringBuilders` for more information.\n *\n *  @define Coll `mutable.IndexedSeq`\n *  @define coll string builder\n */\n@SerialVersionUID(3L)\nfinal class StringBuilder(val underlying: java.lang.StringBuilder) extends AbstractSeq[Char]\n  with ReusableBuilder[Char, String]\n  with IndexedSeq[Char]\n  with IndexedSeqOps[Char, IndexedSeq, StringBuilder]\n  with IterableFactoryDefaults[Char, IndexedSeq]\n  with java.lang.CharSequence\n  with Serializable {\n\n  def this() \u003d this(new java.lang.StringBuilder)\n\n  /** Constructs a string builder with no characters in it and an\n    *  initial capacity specified by the `capacity` argument.\n    *\n    *  @param  capacity  the initial capacity.\n    *  @throws java.lang.NegativeArraySizeException  if capacity \u003c 0.\n    */\n  def this(capacity: Int) \u003d this(new java.lang.StringBuilder(capacity))\n\n  /** Constructs a string builder with initial characters\n    *  equal to characters of `str`.\n    */\n  def this(str: String) \u003d this(new java.lang.StringBuilder(str))\n\n  /** Constructs a string builder initialized with string value `initValue`\n    *  and with additional character capacity `initCapacity`.\n    */\n  def this(initCapacity: Int, initValue: String) \u003d\n    this(new java.lang.StringBuilder(initValue.length + initCapacity) append initValue)\n\n  // Methods required to make this an IndexedSeq:\n  def apply(i: Int): Char \u003d underlying.charAt(i)\n\n  override protected def fromSpecific(coll: scala.collection.IterableOnce[Char]): StringBuilder \u003d\n    new StringBuilder() appendAll coll\n\n  override protected def newSpecificBuilder: Builder[Char, StringBuilder] \u003d\n    new GrowableBuilder(new StringBuilder())\n\n  override def empty: StringBuilder \u003d new StringBuilder()\n\n  @inline def length: Int \u003d underlying.length\n\n  def length_\u003d(n: Int): Unit \u003d underlying.setLength(n)\n\n  override def knownSize: Int \u003d super[IndexedSeqOps].knownSize\n\n  def addOne(x: Char): this.type \u003d { underlying.append(x); this }\n\n  def clear(): Unit \u003d underlying.setLength(0)\n\n  /** Overloaded version of `addAll` that takes a string */\n  def addAll(s: String): this.type \u003d { underlying.append(s); this }\n\n  /** Alias for `addAll` */\n  def ++\u003d (s: String): this.type \u003d addAll(s)\n\n  def result() \u003d underlying.toString\n\n  override def toString: String \u003d result()\n\n  override def toArray[B \u003e: Char](implicit ct: scala.reflect.ClassTag[B]) \u003d\n    ct.runtimeClass match {\n      case java.lang.Character.TYPE \u003d\u003e toCharArray.asInstanceOf[Array[B]]\n      case _ \u003d\u003e super.toArray\n    }\n\n  /** Returns the contents of this StringBuilder as an `Array[Char]`.\n   *\n   *  @return  An array with the characters from this builder.\n   */\n  def toCharArray: Array[Char] \u003d {\n    val len \u003d underlying.length\n    val arr \u003d new Array[Char](len)\n    underlying.getChars(0, len, arr, 0)\n    arr\n  }\n\n  // append* methods delegate to the underlying java.lang.StringBuilder:\n\n  def appendAll(xs: String): this.type \u003d {\n    underlying append xs\n    this\n  }\n\n  /** Appends the string representation of the given argument,\n    *  which is converted to a String with `String.valueOf`.\n    *\n    *  @param  x   an `Any` object.\n    *  @return     this StringBuilder.\n    */\n  def append(x: Any): this.type \u003d {\n    underlying append String.valueOf(x)\n    this\n  }\n\n  /** Appends the given String to this sequence.\n    *\n    *  @param  s   a String.\n    *  @return     this StringBuilder.\n    */\n  def append(s: String): this.type \u003d {\n    underlying append s\n    this\n  }\n\n  /** Appends the given CharSequence to this sequence.\n    *\n    *  @param  cs   a CharSequence.\n    *  @return     this StringBuilder.\n    */\n  def append(cs: java.lang.CharSequence): this.type \u003d {\n    underlying.append(cs match {\n      // Both cases call into append(\u003cCharSequence\u003e), but java SB\n      // looks up type at runtime and has fast path for SB.\n      case s: StringBuilder \u003d\u003e s.underlying\n      case _                \u003d\u003e cs\n    })\n    this\n  }\n\n  /** Appends the specified string builder to this sequence.\n    *\n    *  @param s\n    *  @return\n    */\n  def append(s: StringBuilder): this.type \u003d {\n    underlying append s.underlying\n    this\n  }\n\n  /** Appends all the Chars in the given IterableOnce[Char] to this sequence.\n    *\n    *  @param  xs  the characters to be appended.\n    *  @return     this StringBuilder.\n    */\n  def appendAll(xs: IterableOnce[Char]): this.type \u003d {\n    xs match {\n      case x: WrappedString \u003d\u003e underlying append x.unwrap\n      case x: ArraySeq.ofChar \u003d\u003e underlying append x.array\n      case x: StringBuilder \u003d\u003e underlying append x.underlying\n      case _ \u003d\u003e\n        val ks \u003d xs.knownSize\n        if (ks !\u003d 0) {\n          val b \u003d underlying\n          if (ks \u003e 0) b.ensureCapacity(b.length + ks)\n          val it \u003d xs.iterator\n          while (it.hasNext) { b append it.next() }\n        }\n    }\n    this\n  }\n\n  /** Appends all the Chars in the given Array[Char] to this sequence.\n    *\n    *  @param  xs  the characters to be appended.\n    *  @return     a reference to this object.\n    */\n  def appendAll(xs: Array[Char]): this.type \u003d {\n    underlying append xs\n    this\n  }\n\n  /** Appends a portion of the given Array[Char] to this sequence.\n    *\n    *  @param  xs      the Array containing Chars to be appended.\n    *  @param  offset  the index of the first Char to append.\n    *  @param  len     the numbers of Chars to append.\n    *  @return         this StringBuilder.\n    */\n  def appendAll(xs: Array[Char], offset: Int, len: Int): this.type \u003d {\n    underlying.append(xs, offset, len)\n    this\n  }\n\n  /** Append the String representation of the given primitive type\n    *  to this sequence.  The argument is converted to a String with\n    *  String.valueOf.\n    *\n    *  @param   x  a primitive value\n    *  @return     This StringBuilder.\n    */\n  def append(x: Boolean): this.type \u003d { underlying append x ; this }\n  def append(x: Byte): this.type \u003d append(x.toInt)\n  def append(x: Short): this.type \u003d append(x.toInt)\n  def append(x: Int): this.type \u003d { underlying append x ; this }\n  def append(x: Long): this.type \u003d { underlying append x ; this }\n  def append(x: Float): this.type \u003d { underlying append x ; this }\n  def append(x: Double): this.type \u003d { underlying append x ; this }\n  def append(x: Char): this.type \u003d { underlying append x ; this }\n\n  /** Remove a subsequence of Chars from this sequence, starting at the\n    *  given start index (inclusive) and extending to the end index (exclusive)\n    *  or to the end of the String, whichever comes first.\n    *\n    *  @param  start  The beginning index, inclusive.\n    *  @param  end    The ending index, exclusive.\n    *  @return        This StringBuilder.\n    *  @throws StringIndexOutOfBoundsException   if start \u003c 0 || start \u003e end\n    */\n  def delete(start: Int, end: Int): this.type \u003d {\n    underlying.delete(start, end)\n    this\n  }\n\n  /** Replaces a subsequence of Chars with the given String.  The semantics\n    *  are as in delete, with the String argument then inserted at index \u0027start\u0027.\n    *\n    *  @param  start  The beginning index, inclusive.\n    *  @param  end    The ending index, exclusive.\n    *  @param  str    The String to be inserted at the start index.\n    *  @return        This StringBuilder.\n    *  @throws StringIndexOutOfBoundsException if start \u003c 0, start \u003e length, or start \u003e end\n    */\n  def replace(start: Int, end: Int, str: String): this.type \u003d {\n    underlying.replace(start, end, str)\n    this\n  }\n\n  /** Inserts a subarray of the given Array[Char] at the given index\n    *  of this sequence.\n    *\n    * @param  index   index at which to insert the subarray.\n    * @param  str     the Array from which Chars will be taken.\n    * @param  offset  the index of the first Char to insert.\n    * @param  len     the number of Chars from \u0027str\u0027 to insert.\n    * @return         This StringBuilder.\n    *\n    * @throws StringIndexOutOfBoundsException  if index \u003c 0, index \u003e length,\n    *         offset \u003c 0, len \u003c 0, or (offset + len) \u003e str.length.\n    */\n  def insertAll(index: Int, str: Array[Char], offset: Int, len: Int): this.type \u003d {\n    underlying.insert(index, str, offset, len)\n    this\n  }\n\n  /** Inserts the String representation (via String.valueOf) of the given\n    *  argument into this sequence at the given index.\n    *\n    *  @param  index   the index at which to insert.\n    *  @param  x       a value.\n    *  @return         this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insert(index: Int, x: Any): this.type \u003d insert(index, String.valueOf(x))\n\n  /** Inserts the String into this character sequence.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  x     a String.\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insert(index: Int, x: String): this.type \u003d {\n    underlying.insert(index, x)\n    this\n  }\n\n  /** Inserts the given Seq[Char] into this sequence at the given index.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  xs    the Seq[Char].\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insertAll(index: Int, xs: IterableOnce[Char]): this.type \u003d\n    insertAll(index, (ArrayBuilder.make[Char] ++\u003d xs).result())\n\n  /** Inserts the given Array[Char] into this sequence at the given index.\n    *\n    *  @param  index the index at which to insert.\n    *  @param  xs    the Array[Char].\n    *  @return       this StringBuilder.\n    *  @throws StringIndexOutOfBoundsException  if the index is out of bounds.\n    */\n  def insertAll(index: Int, xs: Array[Char]): this.type \u003d {\n    underlying.insert(index, xs)\n    this\n  }\n\n  /** Calls String.valueOf on the given primitive value, and inserts the\n    *  String at the given index.\n    *\n    *  @param  index the offset position.\n    *  @param  x     a primitive value.\n    *  @return       this StringBuilder.\n    */\n  def insert(index: Int, x: Boolean): this.type \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Byte): this.type    \u003d insert(index, x.toInt)\n  def insert(index: Int, x: Short): this.type   \u003d insert(index, x.toInt)\n  def insert(index: Int, x: Int): this.type     \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Long): this.type    \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Float): this.type   \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Double): this.type  \u003d insert(index, String.valueOf(x))\n  def insert(index: Int, x: Char): this.type    \u003d insert(index, String.valueOf(x))\n\n  /** Sets the length of the character sequence.  If the current sequence\n    *  is shorter than the given length, it is padded with nulls; if it is\n    *  longer, it is truncated.\n    *\n    *  @param  len  the new length\n    *  @throws IndexOutOfBoundsException if the argument is negative.\n    */\n  def setLength(len: Int): Unit \u003d underlying.setLength(len)\n\n  def update(idx: Int, elem: Char): Unit \u003d underlying.setCharAt(idx, elem)\n\n\n  /** Like reverse, but destructively updates the target StringBuilder.\n   *\n   *  @return   the reversed StringBuilder (same as the target StringBuilder)\n   */\n  @deprecated(\"Use reverseInPlace instead\", \"2.13.0\")\n  final def reverseContents(): this.type \u003d reverseInPlace()\n\n  /** Like reverse, but destructively updates the target StringBuilder.\n   *\n   *  @return   the reversed StringBuilder (same as the target StringBuilder)\n   */\n  def reverseInPlace(): this.type \u003d {\n    underlying.reverse()\n    this\n  }\n\n\n  /** Returns the current capacity, which is the size of the underlying array.\n   *  A new array will be allocated if the current capacity is exceeded.\n   *\n   *  @return  the capacity\n   */\n  def capacity: Int \u003d underlying.capacity\n\n  /** Ensure that the capacity is at least the given argument.\n   *  If the argument is greater than the current capacity, new\n   *  storage will be allocated with size equal to the given\n   *  argument or to `(2 * capacity + 2)`, whichever is larger.\n   *\n   *  @param newCapacity    the minimum desired capacity.\n   */\n  def ensureCapacity(newCapacity: Int): Unit \u003d { underlying.ensureCapacity(newCapacity) }\n\n  /** Returns the Char at the specified index, counting from 0 as in Arrays.\n   *\n   *  @param  index   the index to look up\n   *  @return         the Char at the given index.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def charAt(index: Int): Char \u003d underlying.charAt(index)\n\n  /** Removes the Char at the specified index.  The sequence is\n   *  shortened by one.\n   *\n   *  @param  index  The index to remove.\n   *  @return        This StringBuilder.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def deleteCharAt(index: Int): this.type \u003d {\n    underlying.deleteCharAt(index)\n    this\n  }\n\n  /** Update the sequence at the given index to hold the specified Char.\n   *\n   *  @param  index   the index to modify.\n   *  @param  ch      the new Char.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def setCharAt(index: Int, ch: Char): this.type \u003d {\n    underlying.setCharAt(index, ch)\n    this\n  }\n\n  /** Returns a new String made up of a subsequence of this sequence,\n   *  beginning at the given index and extending to the end of the sequence.\n   *\n   *  target.substring(start)  is equivalent to  target.drop(start)\n   *\n   *  @param  start  The starting index, inclusive.\n   *  @return        The new String.\n   *  @throws IndexOutOfBoundsException  if the index is out of bounds.\n   */\n  def substring(start: Int): String \u003d underlying.substring(start, length)\n\n  /** Returns a new String made up of a subsequence of this sequence,\n   *  beginning at the start index (inclusive) and extending to the\n   *  end index (exclusive).\n   *\n   *  target.substring(start, end)  is equivalent to  target.slice(start, end).mkString\n   *\n   *  @param  start  The beginning index, inclusive.\n   *  @param  end    The ending index, exclusive.\n   *  @return The new String.\n   *  @throws StringIndexOutOfBoundsException If either index is out of bounds,\n   *          or if start \u003e end.\n   */\n  def substring(start: Int, end: Int): String \u003d underlying.substring(start, end)\n\n  /** For implementing CharSequence.\n   */\n  def subSequence(start: Int, end: Int): java.lang.CharSequence \u003d\n    underlying.substring(start, end)\n\n  /** Finds the index of the first occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @return             the first applicable index where target occurs, or -1 if not found.\n   */\n  def indexOf(str: String): Int \u003d underlying.indexOf(str)\n\n  /** Finds the index of the first occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @param    fromIndex the smallest index in the source string to consider\n   *  @return             the first applicable index where target occurs, or -1 if not found.\n   */\n  def indexOf(str: String, fromIndex: Int): Int \u003d underlying.indexOf(str, fromIndex)\n\n  /** Finds the index of the last occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @return             the last applicable index where target occurs, or -1 if not found.\n   */\n  def lastIndexOf(str: String): Int \u003d underlying.lastIndexOf(str)\n\n  /** Finds the index of the last occurrence of the specified substring.\n   *\n   *  @param    str       the target string to search for\n   *  @param    fromIndex the smallest index in the source string to consider\n   *  @return             the last applicable index where target occurs, or -1 if not found.\n   */\n  def lastIndexOf(str: String, fromIndex: Int): Int \u003d underlying.lastIndexOf(str, fromIndex)\n\n  /** Tests whether this builder is empty.\n   *\n   *  This method is required for JDK15+ compatibility\n   *\n   *  @return  `true` if this builder contains nothing, `false` otherwise.\n   */\n  override def isEmpty: Boolean \u003d underlying.length() \u003d\u003d 0\n}\n\nobject StringBuilder {\n  @deprecated(\"Use `new StringBuilder()` instead of `StringBuilder.newBuilder`\", \"2.13.0\")\n  def newBuilder \u003d new StringBuilder\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:27:19 INFO  compiling root (2 scala sources)
2024.04.26 03:27:19 INFO  time: compiled root in 0.17s
2024.04.26 03:27:24 INFO  compiling root (2 scala sources)
2024.04.26 03:27:24 INFO  time: compiled root in 0.15s
2024.04.26 03:28:58 INFO  compiling root (2 scala sources)
2024.04.26 03:28:58 INFO  time: compiled root in 0.16s
2024.04.26 03:29:16 INFO  compiling root (2 scala sources)
2024.04.26 03:29:16 INFO  time: compiled root in 0.17s
2024.04.26 03:29:49 INFO  compiling root (2 scala sources)
2024.04.26 03:29:49 INFO  time: compiled root in 0.21s
Apr. 26, 2024 3:30:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/collection/mutable/StringBuilder.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/collection/mutable/StringBuilder.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:30:26 WARN  Using indexes to guess the definition of setupBoard
2024.04.26 03:30:26 WARN  Using indexes to guess the definition of setupBoard
2024.04.26 03:30:51 INFO  compiling root (2 scala sources)
2024.04.26 03:30:51 INFO  time: compiled root in 0.12s
2024.04.26 03:30:52 WARN  Using indexes to guess the definition of setupBoard
2024.04.26 03:31:09 INFO  compiling root (2 scala sources)
2024.04.26 03:31:09 INFO  time: compiled root in 0.12s
2024.04.26 03:31:20 INFO  compiling root (2 scala sources)
2024.04.26 03:31:20 INFO  time: compiled root in 0.2s
2024.04.26 03:31:23 INFO  compiling root (2 scala sources)
2024.04.26 03:31:23 INFO  time: compiled root in 0.13s
2024.04.26 03:31:41 INFO  compiling root (2 scala sources)
2024.04.26 03:31:41 INFO  time: compiled root in 0.23s
Apr. 26, 2024 3:31:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8592
2024.04.26 03:32:07 INFO  compiling root (2 scala sources)
2024.04.26 03:32:07 INFO  time: compiled root in 0.23s
2024.04.26 03:32:09 INFO  compiling root (2 scala sources)
2024.04.26 03:32:09 INFO  time: compiled root in 0.23s
2024.04.26 03:32:09 INFO  compiling root (2 scala sources)
2024.04.26 03:32:09 INFO  time: compiled root in 0.24s
2024.04.26 03:32:09 INFO  compiling root (2 scala sources)
2024.04.26 03:32:09 INFO  time: compiled root in 0.25s
2024.04.26 03:32:09 INFO  compiling root (2 scala sources)
2024.04.26 03:32:10 INFO  time: compiled root in 0.29s
2024.04.26 03:32:10 INFO  compiling root (2 scala sources)
2024.04.26 03:32:10 INFO  time: compiled root in 0.23s
2024.04.26 03:32:10 INFO  compiling root (2 scala sources)
2024.04.26 03:32:10 INFO  time: compiled root in 0.31s
2024.04.26 03:32:25 INFO  compiling root (2 scala sources)
2024.04.26 03:32:25 INFO  time: compiled root in 0.12s
Apr. 26, 2024 3:33:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 8846
2024.04.26 03:33:38 INFO  compiling root (2 scala sources)
2024.04.26 03:33:38 INFO  time: compiled root in 0.61s
2024.04.26 03:33:39 INFO  compiling root (2 scala sources)
2024.04.26 03:33:39 INFO  time: compiled root in 0.15s
2024.04.26 03:34:15 INFO  compiling root (2 scala sources)
2024.04.26 03:34:15 INFO  time: compiled root in 0.12s
2024.04.26 03:34:33 INFO  compiling root (2 scala sources)
2024.04.26 03:34:33 INFO  time: compiled root in 0.11s
2024.04.26 03:34:37 INFO  compiling root (5 scala sources)
2024.04.26 03:34:37 INFO  time: compiled root in 0.21s
2024.04.26 03:35:05 INFO  compiling root (5 scala sources)
2024.04.26 03:35:05 INFO  time: compiled root in 0.14s
Apr. 26, 2024 3:35:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
java.util.concurrent.CompletionException: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptNow(CompletableFuture.java:747)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptStage(CompletableFuture.java:735)
	at java.base/java.util.concurrent.CompletableFuture.thenAcceptAsync(CompletableFuture.java:2218)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.thenAccept(FutureConvertersImpl.scala:37)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:279)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$.<clinit>(DebugProvider.scala:1024)
	at scala.meta.internal.metals.debug.DebugProvider.debugDiscovery(DebugProvider.scala:586)
	at scala.meta.internal.metals.debug.DebugProvider.runCommandDiscovery(DebugProvider.scala:522)
	at scala.meta.internal.metals.MetalsLspService.discoverMainClasses(MetalsLspService.scala:1825)
	at scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:731)
	at scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	... 9 more

Apr. 26, 2024 3:35:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
java.util.concurrent.CompletionException: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptNow(CompletableFuture.java:747)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptStage(CompletableFuture.java:735)
	at java.base/java.util.concurrent.CompletableFuture.thenAcceptAsync(CompletableFuture.java:2218)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.thenAccept(FutureConvertersImpl.scala:37)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:279)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$.<clinit>(DebugProvider.scala:1024)
	at scala.meta.internal.metals.debug.DebugProvider.debugDiscovery(DebugProvider.scala:586)
	at scala.meta.internal.metals.debug.DebugProvider.runCommandDiscovery(DebugProvider.scala:522)
	at scala.meta.internal.metals.MetalsLspService.discoverMainClasses(MetalsLspService.scala:1825)
	at scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:731)
	at scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	... 9 more

2024.04.26 03:35:20 INFO  compiling root (5 scala sources)
2024.04.26 03:35:20 INFO  time: compiled root in 0.13s
2024.04.26 03:35:20 INFO  compiling root (5 scala sources)
2024.04.26 03:35:20 INFO  time: compiled root in 0.2s
Apr. 26, 2024 3:35:21 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9121
2024.04.26 03:35:22 INFO  compiling root (5 scala sources)
2024.04.26 03:35:22 INFO  time: compiled root in 0.17s
2024.04.26 03:35:36 INFO  compiling root (5 scala sources)
2024.04.26 03:35:36 INFO  time: compiled root in 0.34s
Apr. 26, 2024 3:35:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java"
  ]
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:639)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:35:41 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:391)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

2024.04.26 03:35:41 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:35:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1727)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1726)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 25 more

2024.04.26 03:35:41 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:408)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:35:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1511)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 13 more

2024.04.26 03:35:41 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:35:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1727)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1726)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:483)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 25 more

2024.04.26 03:35:41 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:493)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:35:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.Compilers.semanticTokens(Compilers.scala:482)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$semanticTokensFull$2(MetalsLspService.scala:1649)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 12 more

2024.04.26 03:35:41 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.hover(WorkspaceLspService.scala:386)
	scala.meta.metals.lsp.DelegatingScalaService.hover(DelegatingScalaService.scala:82)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:35:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.Compilers.withPCAndAdjustLsp(Compilers.scala:1189)
	at scala.meta.internal.metals.Compilers.hover(Compilers.scala:811)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$hover$1(MetalsLspService.scala:1455)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.hover(MetalsLspService.scala:1453)
	at scala.meta.internal.metals.WorkspaceLspService.hover(WorkspaceLspService.scala:386)
	at scala.meta.metals.lsp.DelegatingScalaService.hover(DelegatingScalaService.scala:82)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 27 more

Apr. 26, 2024 3:35:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-19/lib/src.zip%21/java.base/java/lang/StringBuilder.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-19/lib/src.zip!/java.base/java/lang/StringBuilder.java
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:35:44 INFO  compiling root-test (3 scala sources)
2024.04.26 03:35:44 INFO  time: compiled root-test in 0.21s
Apr. 26, 2024 3:36:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 9330
2024.04.26 03:36:29 INFO  compiling root (1 scala source)
2024.04.26 03:36:29 INFO  time: compiled root in 0.17s
2024.04.26 03:36:49 INFO  compiling root (1 scala source)
2024.04.26 03:36:49 INFO  time: compiled root in 0.2s
2024.04.26 03:41:05 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: Non-zero integral values may not have a leading zero.
      U+0041
        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInt$1(LegacyScanner.scala:847)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInteger$1(LegacyScanner.scala:858)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:875)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:336)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:339)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 03:41:07 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: Non-zero integral values may not have a leading zero.
      valU+0041
           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInt$1(LegacyScanner.scala:847)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInteger$1(LegacyScanner.scala:858)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:875)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:336)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:339)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 03:41:08 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: Non-zero integral values may not have a leading zero.
      val U+0041
            ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInt$1(LegacyScanner.scala:847)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInteger$1(LegacyScanner.scala:858)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:875)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:336)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:339)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 03:41:12 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: Non-zero integral values may not have a leading zero.
      val code U+0041
                 ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInt$1(LegacyScanner.scala:847)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInteger$1(LegacyScanner.scala:858)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:875)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:336)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:339)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 03:41:14 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: Non-zero integral values may not have a leading zero.
      val code = U+0041
                   ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInt$1(LegacyScanner.scala:847)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInteger$1(LegacyScanner.scala:858)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:875)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:336)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:339)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 03:41:17 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: Non-zero integral values may not have a leading zero.
      val code = U+0041"
                   ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInt$1(LegacyScanner.scala:847)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInteger$1(LegacyScanner.scala:858)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:875)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:336)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:339)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 03:41:30 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: Non-zero integral values may not have a leading zero.
      val code = U+0041"
                   ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInt$1(LegacyScanner.scala:847)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInteger$1(LegacyScanner.scala:858)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:875)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:336)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:339)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 03:41:32 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: Non-zero integral values may not have a leading zero.
      val code =U+0041
                  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInt$1(LegacyScanner.scala:847)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInteger$1(LegacyScanner.scala:858)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:875)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:336)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:339)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 03:41:32 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\Board.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: Non-zero integral values may not have a leading zero.
      U+0041
        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInt$1(LegacyScanner.scala:847)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInteger$1(LegacyScanner.scala:858)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:875)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:336)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:339)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 03:41:45 INFO  compiling root-test (3 scala sources)
2024.04.26 03:41:45 INFO  time: compiled root-test in 0.2s
2024.04.26 03:42:24 INFO  compiling root (1 scala source)
2024.04.26 03:42:24 INFO  time: compiled root in 0.17s
Apr. 26, 2024 3:42:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SCHWERWIEGEND: Internal error: scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$: There is nothing to run or test in the current file.
java.util.concurrent.CompletionException: scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$: There is nothing to run or test in the current file.
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptNow(CompletableFuture.java:747)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptStage(CompletableFuture.java:735)
	at java.base/java.util.concurrent.CompletableFuture.thenAcceptAsync(CompletableFuture.java:2218)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.thenAccept(FutureConvertersImpl.scala:37)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:279)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$: There is nothing to run or test in the current file.
	at scala.meta.internal.metals.debug.DebugProvider$NoRunOptionException$.<clinit>(DebugProvider.scala:1028)
	at scala.meta.internal.metals.debug.DebugProvider.$anonfun$resolveInFile$2(DebugProvider.scala:478)
	at scala.Option.fold(Option.scala:263)
	at scala.meta.internal.metals.debug.DebugProvider.resolveInFile(DebugProvider.scala:449)
	at scala.meta.internal.metals.debug.DebugProvider.debugDiscovery(DebugProvider.scala:594)
	at scala.meta.internal.metals.debug.DebugProvider.runCommandDiscovery(DebugProvider.scala:522)
	at scala.meta.internal.metals.MetalsLspService.discoverMainClasses(MetalsLspService.scala:1825)
	at scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:731)
	at scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	... 9 more

2024.04.26 03:42:45 ERROR Failed to tokenize input for semantic tokens for C:\Users\Gewin Singh\Desktop\S\AIN3\SE\CHESS-SE-HTWG\src\main\scala\Chess\TUI.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: Invalid literal number, followed by identifier character
        val 2column1 = letter1.head - 'a'
             ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:834)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInteger$1(LegacyScanner.scala:857)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:875)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:342)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1589)

2024.04.26 03:43:11 INFO  compiling root (1 scala source)
2024.04.26 03:43:11 INFO  time: compiled root in 0.16s
Apr. 26, 2024 3:44:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 10056
2024.04.26 03:45:15 INFO  compiling root (1 scala source)
2024.04.26 03:45:15 INFO  time: compiled root in 0.22s
Apr. 26, 2024 3:46:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 10311
2024.04.26 03:47:09 INFO  compiling root (1 scala source)
2024.04.26 03:47:09 INFO  time: compiled root in 0.2s
2024.04.26 03:47:22 INFO  compiling root (1 scala source)
2024.04.26 03:47:22 INFO  time: compiled root in 0.18s
2024.04.26 03:47:22 INFO  compiling root (1 scala source)
2024.04.26 03:47:22 INFO  time: compiled root in 0.21s
2024.04.26 03:50:08 INFO  compiling root (1 scala source)
2024.04.26 03:50:08 INFO  time: compiled root in 0.24s
Apr. 26, 2024 3:50:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 10673
2024.04.26 03:52:01 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:52:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// DO NOT EDIT, CHANGES WILL BE LOST\n// This auto-generated code can be modified in \"project/GenerateAnyVals.scala\".\n// Afterwards, running \"sbt generateSources\" regenerates this source file.\n\npackage scala\n\n/** `Int`, a 32-bit signed integer (equivalent to Java\u0027s `int` primitive type) is a\n *  subtype of [[scala.AnyVal]]. Instances of `Int` are not\n *  represented by an object in the underlying runtime system.\n *\n *  There is an implicit conversion from [[scala.Int]] \u003d\u003e [[scala.runtime.RichInt]]\n *  which provides useful non-primitive operations.\n */\nfinal abstract class Int private extends AnyVal {\n  def toByte: Byte\n  def toShort: Short\n  def toChar: Char\n  def toInt: Int\n  def toLong: Long\n  def toFloat: Float\n  def toDouble: Double\n\n  /**\n * Returns the bitwise negation of this value.\n * @example {{{\n * ~5 \u003d\u003d -6\n * // in binary: ~00000101 \u003d\u003d\n * //             11111010\n * }}}\n */\n  def unary_~ : Int\n  /** Returns this value, unmodified. */\n  def unary_+ : Int\n  /** Returns the negation of this value. */\n  def unary_- : Int\n\n  @deprecated(\"Adding a number and a String is deprecated. Use the string interpolation `s\\\"$num$str\\\"`\", \"2.13.0\")\n  def +(x: String): String\n\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  def \u003c\u003c(x: Int): Int\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003c\u003c(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e\u003e(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e(x: Long): Int\n\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Short): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Char): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Int): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Long): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Float): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Short): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Char): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Int): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Long): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Float): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Byte): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Short): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Char): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Int): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Long): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Float): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Double): Boolean\n\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Short): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Char): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Int): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Long): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Float): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Byte): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Short): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Char): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Int): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Long): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Float): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Short): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Char): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Int): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Long): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Float): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Double): Boolean\n\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Byte): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Short): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Char): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Int): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Long): Long\n\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Byte): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Short): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Char): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Int): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Long): Long\n\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Byte): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Short): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Char): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Int): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Long): Long\n\n  /** Returns the sum of this value and `x`. */\n  def +(x: Byte): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Short): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Char): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Int): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Long): Long\n  /** Returns the sum of this value and `x`. */\n  def +(x: Float): Float\n  /** Returns the sum of this value and `x`. */\n  def +(x: Double): Double\n\n  /** Returns the difference of this value and `x`. */\n  def -(x: Byte): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Short): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Char): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Int): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Long): Long\n  /** Returns the difference of this value and `x`. */\n  def -(x: Float): Float\n  /** Returns the difference of this value and `x`. */\n  def -(x: Double): Double\n\n  /** Returns the product of this value and `x`. */\n  def *(x: Byte): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Short): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Char): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Int): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Long): Long\n  /** Returns the product of this value and `x`. */\n  def *(x: Float): Float\n  /** Returns the product of this value and `x`. */\n  def *(x: Double): Double\n\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Byte): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Short): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Char): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Int): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Long): Long\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Float): Float\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Double): Double\n\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Byte): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Short): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Char): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Int): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Long): Long\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Float): Float\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Double): Double\n\n  // Provide a more specific return type for Scaladoc\n  override def getClass(): Class[Int] \u003d ???\n}\n\nobject Int extends AnyValCompanion {\n  /** The smallest value representable as an Int. */\n  final val MinValue \u003d java.lang.Integer.MIN_VALUE\n\n  /** The largest value representable as an Int. */\n  final val MaxValue \u003d java.lang.Integer.MAX_VALUE\n\n  /** Transform a value type into a boxed reference type.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.boxToInteger`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the Int to be boxed\n   *  @return     a java.lang.Integer offering `x` as its underlying value.\n   */\n  def box(x: Int): java.lang.Integer \u003d ???\n\n  /** Transform a boxed type into a value type.  Note that this\n   *  method is not typesafe: it accepts any Object, but will throw\n   *  an exception if the argument is not a java.lang.Integer.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.unboxToInt`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the java.lang.Integer to be unboxed.\n   *  @throws     ClassCastException  if the argument is not a java.lang.Integer\n   *  @return     the Int resulting from calling intValue() on `x`\n   */\n  def unbox(x: java.lang.Object): Int \u003d ???\n\n  /** The String representation of the scala.Int companion object. */\n  override def toString \u003d \"object scala.Int\"\n  /** Language mandated coercions from Int to \"wider\" types. */\n  import scala.language.implicitConversions\n  @deprecated(\"Implicit conversion from Int to Float is dangerous because it loses precision. Write `.toFloat` instead.\", \"2.13.1\")\n  implicit def int2float(x: Int): Float \u003d x.toFloat\n  implicit def int2long(x: Int): Long \u003d x.toLong\n  implicit def int2double(x: Int): Double \u003d x.toDouble\n}\n\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:52:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:52:01 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:52:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/Int.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// DO NOT EDIT, CHANGES WILL BE LOST\n// This auto-generated code can be modified in \"project/GenerateAnyVals.scala\".\n// Afterwards, running \"sbt generateSources\" regenerates this source file.\n\npackage scala\n\n/** `Int`, a 32-bit signed integer (equivalent to Java\u0027s `int` primitive type) is a\n *  subtype of [[scala.AnyVal]]. Instances of `Int` are not\n *  represented by an object in the underlying runtime system.\n *\n *  There is an implicit conversion from [[scala.Int]] \u003d\u003e [[scala.runtime.RichInt]]\n *  which provides useful non-primitive operations.\n */\nfinal abstract class Int private extends AnyVal {\n  def toByte: Byte\n  def toShort: Short\n  def toChar: Char\n  def toInt: Int\n  def toLong: Long\n  def toFloat: Float\n  def toDouble: Double\n\n  /**\n * Returns the bitwise negation of this value.\n * @example {{{\n * ~5 \u003d\u003d -6\n * // in binary: ~00000101 \u003d\u003d\n * //             11111010\n * }}}\n */\n  def unary_~ : Int\n  /** Returns this value, unmodified. */\n  def unary_+ : Int\n  /** Returns the negation of this value. */\n  def unary_- : Int\n\n  @deprecated(\"Adding a number and a String is deprecated. Use the string interpolation `s\\\"$num$str\\\"`\", \"2.13.0\")\n  def +(x: String): String\n\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  def \u003c\u003c(x: Int): Int\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003c\u003c(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e\u003e(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e(x: Long): Int\n\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Short): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Char): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Int): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Long): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Float): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Short): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Char): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Int): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Long): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Float): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Byte): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Short): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Char): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Int): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Long): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Float): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Double): Boolean\n\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Short): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Char): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Int): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Long): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Float): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Byte): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Short): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Char): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Int): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Long): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Float): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Short): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Char): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Int): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Long): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Float): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Double): Boolean\n\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Byte): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Short): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Char): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Int): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Long): Long\n\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Byte): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Short): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Char): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Int): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Long): Long\n\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Byte): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Short): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Char): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Int): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Long): Long\n\n  /** Returns the sum of this value and `x`. */\n  def +(x: Byte): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Short): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Char): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Int): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Long): Long\n  /** Returns the sum of this value and `x`. */\n  def +(x: Float): Float\n  /** Returns the sum of this value and `x`. */\n  def +(x: Double): Double\n\n  /** Returns the difference of this value and `x`. */\n  def -(x: Byte): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Short): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Char): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Int): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Long): Long\n  /** Returns the difference of this value and `x`. */\n  def -(x: Float): Float\n  /** Returns the difference of this value and `x`. */\n  def -(x: Double): Double\n\n  /** Returns the product of this value and `x`. */\n  def *(x: Byte): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Short): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Char): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Int): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Long): Long\n  /** Returns the product of this value and `x`. */\n  def *(x: Float): Float\n  /** Returns the product of this value and `x`. */\n  def *(x: Double): Double\n\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Byte): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Short): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Char): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Int): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Long): Long\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Float): Float\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Double): Double\n\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Byte): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Short): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Char): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Int): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Long): Long\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Float): Float\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Double): Double\n\n  // Provide a more specific return type for Scaladoc\n  override def getClass(): Class[Int] \u003d ???\n}\n\nobject Int extends AnyValCompanion {\n  /** The smallest value representable as an Int. */\n  final val MinValue \u003d java.lang.Integer.MIN_VALUE\n\n  /** The largest value representable as an Int. */\n  final val MaxValue \u003d java.lang.Integer.MAX_VALUE\n\n  /** Transform a value type into a boxed reference type.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.boxToInteger`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the Int to be boxed\n   *  @return     a java.lang.Integer offering `x` as its underlying value.\n   */\n  def box(x: Int): java.lang.Integer \u003d ???\n\n  /** Transform a boxed type into a value type.  Note that this\n   *  method is not typesafe: it accepts any Object, but will throw\n   *  an exception if the argument is not a java.lang.Integer.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.unboxToInt`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the java.lang.Integer to be unboxed.\n   *  @throws     ClassCastException  if the argument is not a java.lang.Integer\n   *  @return     the Int resulting from calling intValue() on `x`\n   */\n  def unbox(x: java.lang.Object): Int \u003d ???\n\n  /** The String representation of the scala.Int companion object. */\n  override def toString \u003d \"object scala.Int\"\n  /** Language mandated coercions from Int to \"wider\" types. */\n  import scala.language.implicitConversions\n  @deprecated(\"Implicit conversion from Int to Float is dangerous because it loses precision. Write `.toFloat` instead.\", \"2.13.1\")\n  implicit def int2float(x: Int): Float \u003d x.toFloat\n  implicit def int2long(x: Int): Long \u003d x.toLong\n  implicit def int2double(x: Int): Double \u003d x.toDouble\n}\n\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/Int.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:52:03 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/util/matching/Regex.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/util/matching/Regex.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:52:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/util/matching/Regex.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n/**\n * This package is concerned with regular expression (regex) matching against strings,\n * with the main goal of pulling out information from those matches, or replacing\n * them with something else.\n *\n * [[scala.util.matching.Regex]] is the class users instantiate to do regular expression matching.\n *\n * The companion object to [[scala.util.matching.Regex]] contains supporting members:\n * * [[scala.util.matching.Regex.Match]] makes more information about a match available.\n * * [[scala.util.matching.Regex.MatchIterator]] is used to iterate over matched strings.\n * * [[scala.util.matching.Regex.MatchData]] is just a base trait for the above classes.\n * * [[scala.util.matching.Regex.Groups]] extracts group from a [[scala.util.matching.Regex.Match]]\n *   without recomputing the match.\n */\npackage scala.util.matching\n\nimport scala.collection.AbstractIterator\nimport java.util.regex.{ Pattern, Matcher }\n\n/** A regular expression is used to determine whether a string matches a pattern\n *  and, if it does, to extract or transform the parts that match.\n *\n *  \u003d\u003d\u003d Usage \u003d\u003d\u003d\n\n *  This class delegates to the [[https://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html java.util.regex]] package of the Java Platform.\n *  See the documentation for [[java.util.regex.Pattern]] for details about\n *  the regular expression syntax for pattern strings.\n *\n *  An instance of `Regex` represents a compiled regular expression pattern.\n *  Since compilation is expensive, frequently used `Regex`es should be constructed\n *  once, outside of loops and perhaps in a companion object.\n *\n *  The canonical way to create a `Regex` is by using the method `r`, provided\n *  implicitly for strings:\n *\n *  {{{\n *  val date \u003d raw\"(\\d{4})-(\\d{2})-(\\d{2})\".r\n *  }}}\n *\n *  Since escapes are not processed in multi-line string literals, using triple quotes\n *  avoids having to escape the backslash character, so that `\"\\\\d\"` can be written `\"\"\"\\d\"\"\"`.\n *  The same result is achieved with certain interpolators, such as `raw\"\\d\".r` or\n *  a custom interpolator `r\"\\d\"` that also compiles the `Regex`.\n *\n *  \u003d\u003d\u003d Extraction \u003d\u003d\u003d\n *  To extract the capturing groups when a `Regex` is matched, use it as\n *  an extractor in a pattern match:\n *\n *  {{{\n *  \"2004-01-20\" match {\n *    case date(year, month, day) \u003d\u003e s\"\\$year was a good year for PLs.\"\n *  }\n *  }}}\n *\n *  To check only whether the `Regex` matches, ignoring any groups,\n *  use a sequence wildcard:\n *\n *  {{{\n *  \"2004-01-20\" match {\n *    case date(_*) \u003d\u003e \"It\u0027s a date!\"\n *  }\n *  }}}\n *\n *  That works because a `Regex` extractor produces a sequence of strings.\n *  Extracting only the year from a date could also be expressed with\n *  a sequence wildcard:\n *\n *  {{{\n *  \"2004-01-20\" match {\n *    case date(year, _*) \u003d\u003e s\"\\$year was a good year for PLs.\"\n *  }\n *  }}}\n *\n *  In a pattern match, `Regex` normally matches the entire input.\n *  However, an unanchored `Regex` finds the pattern anywhere\n *  in the input.\n *\n *  {{{\n *  val embeddedDate \u003d date.unanchored\n *  \"Date: 2004-01-20 17:25:18 GMT (10 years, 28 weeks, 5 days, 17 hours and 51 minutes ago)\" match {\n *    case embeddedDate(\"2004\", \"01\", \"20\") \u003d\u003e \"A Scala is born.\"\n *  }\n *  }}}\n *\n *  \u003d\u003d\u003d Find Matches \u003d\u003d\u003d\n *  To find or replace matches of the pattern, use the various find and replace methods.\n *  For each method, there is a version for working with matched strings and\n *  another for working with `Match` objects.\n *\n *  For example, pattern matching with an unanchored `Regex`, as in the previous example,\n *  can also be accomplished using `findFirstMatchIn`. The `findFirst` methods return an `Option`\n *  which is non-empty if a match is found, or `None` for no match:\n *\n *  {{{\n *  val dates \u003d \"Important dates in history: 2004-01-20, 1958-09-05, 2010-10-06, 2011-07-15\"\n *  val firstDate \u003d date.findFirstIn(dates).getOrElse(\"No date found.\")\n *  val firstYear \u003d for (m \u003c- date.findFirstMatchIn(dates)) yield m.group(1)\n *  }}}\n *\n *  To find all matches:\n *\n *  {{{\n *  val allYears \u003d for (m \u003c- date.findAllMatchIn(dates)) yield m.group(1)\n *  }}}\n *\n *  To check whether input is matched by the regex:\n *\n *  {{{\n *  date.matches(\"2018-03-01\")                     // true\n *  date.matches(\"Today is 2018-03-01\")            // false\n *  date.unanchored.matches(\"Today is 2018-03-01\") // true\n *  }}}\n *\n *  To iterate over the matched strings, use `findAllIn`, which returns a special iterator\n *  that can be queried for the `MatchData` of the last match:\n *\n *  {{{\n *  val mi \u003d date.findAllIn(dates)\n *  while (mi.hasNext) {\n *    val d \u003d mi.next\n *    if (mi.group(1).toInt \u003c 1960) println(s\"\\$d: An oldie but goodie.\")\n *  }\n *  }}}\n *\n *  Although the `MatchIterator` returned by `findAllIn` is used like any `Iterator`,\n *  with alternating calls to `hasNext` and `next`, `hasNext` has the additional\n *  side effect of advancing the underlying matcher to the next unconsumed match.\n *  This effect is visible in the `MatchData` representing the \"current match\".\n *\n *  {{{\n *  val r \u003d \"(ab+c)\".r\n *  val s \u003d \"xxxabcyyyabbczzz\"\n *  r.findAllIn(s).start    // 3\n *  val mi \u003d r.findAllIn(s)\n *  mi.hasNext              // true\n *  mi.start                // 3\n *  mi.next()               // \"abc\"\n *  mi.start                // 3\n *  mi.hasNext              // true\n *  mi.start                // 9\n *  mi.next()               // \"abbc\"\n *  }}}\n *\n *  The example shows that methods on `MatchData` such as `start` will advance to\n *  the first match, if necessary. It also shows that `hasNext` will advance to\n *  the next unconsumed match, if `next` has already returned the current match.\n *\n *  The current `MatchData` can be captured using the `matchData` method.\n *  Alternatively, `findAllMatchIn` returns an `Iterator[Match]`, where there\n *  is no interaction between the iterator and `Match` objects it has already produced.\n *\n *  Note that `findAllIn` finds matches that don\u0027t overlap. (See [[findAllIn]] for more examples.)\n *\n *  {{{\n *  val num \u003d raw\"(\\d+)\".r\n *  val all \u003d num.findAllIn(\"123\").toList  // List(\"123\"), not List(\"123\", \"23\", \"3\")\n *  }}}\n *\n *  \u003d\u003d\u003d Replace Text \u003d\u003d\u003d\n *  Text replacement can be performed unconditionally or as a function of the current match:\n *\n *  {{{\n *  val redacted    \u003d date.replaceAllIn(dates, \"XXXX-XX-XX\")\n *  val yearsOnly   \u003d date.replaceAllIn(dates, m \u003d\u003e m.group(1))\n *  val months      \u003d (0 to 11).map { i \u003d\u003e val c \u003d Calendar.getInstance; c.set(2014, i, 1); f\"\\$c%tb\" }\n *  val reformatted \u003d date.replaceAllIn(dates, _ match { case date(y,m,d) \u003d\u003e f\"\\${months(m.toInt - 1)} \\$d, \\$y\" })\n *  }}}\n *\n *  Pattern matching the `Match` against the `Regex` that created it does not reapply the `Regex`.\n *  In the expression for `reformatted`, each `date` match is computed once. But it is possible to apply a\n *  `Regex` to a `Match` resulting from a different pattern:\n *\n *  {{{\n *  val docSpree \u003d \"\"\"2011(?:-\\d{2}){2}\"\"\".r\n *  val docView  \u003d date.replaceAllIn(dates, _ match {\n *    case docSpree() \u003d\u003e \"Historic doc spree!\"\n *    case _          \u003d\u003e \"Something else happened\"\n *  })\n *  }}}\n *\n *  @see [[java.util.regex.Pattern]]\n *\n *  @param pattern    The compiled pattern\n *  @param groupNames A mapping from names to indices in capture groups\n *\n *  @define replacementString\n *  In the replacement String, a dollar sign (`\\$`) followed by a number will be\n *  interpreted as a reference to a group in the matched pattern, with numbers\n *  1 through 9 corresponding to the first nine groups, and 0 standing for the\n *  whole match. Any other character is an error. The backslash (`\\`) character\n *  will be interpreted as an escape character and can be used to escape the\n *  dollar sign. Use `Regex.quoteReplacement` to escape these characters.\n */\n@SerialVersionUID(-2094783597747625537L)\nclass Regex private[matching](val pattern: Pattern, groupNames: String*) extends Serializable {\n  outer \u003d\u003e\n\n  import Regex._\n\n  /** Compile a regular expression, supplied as a string, into a pattern that\n   *  can be matched against inputs.\n   *\n   *  If group names are supplied, they can be used this way:\n   *\n   *  {{{\n   *  val namedDate  \u003d new Regex(\"\"\"(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)\"\"\", \"year\", \"month\", \"day\")\n   *  val namedYears \u003d for (m \u003c- namedDate findAllMatchIn dates) yield m group \"year\"\n   *  }}}\n   *\n   *  Inline group names are preferred over group names supplied to the constructor\n   *  when retrieving matched groups by name. Group names supplied to the constructor\n   *  should be considered deprecated.\n   *\n   *  This constructor does not support options as flags, which must be\n   *  supplied as inline flags in the pattern string: `(?idmsuxU)`.\n   *\n   *  @param regex      The regular expression to compile.\n   *  @param groupNames Names of capturing groups.\n   */\n  // we cannot add the alternative `def this(regex: String)` in a forward binary compatible way:\n  // @deprecated(\"use inline group names like (?\u003cyear\u003eX) instead\", \"2.13.7\")\n  def this(regex: String, groupNames: String*) \u003d this(Pattern.compile(regex), groupNames: _*)\n\n  /** Tries to match a [[java.lang.CharSequence]].\n   *\n   *  If the match succeeds, the result is a list of the matching\n   *  groups (or a `null` element if a group did not match any input).\n   *  If the pattern specifies no groups, then the result will be an empty list\n   *  on a successful match.\n   *\n   *  This method attempts to match the entire input by default; to find the next\n   *  matching subsequence, use an unanchored `Regex`.\n   *\n   *  For example:\n   *\n   *  {{{\n   *  val p1 \u003d \"ab*c\".r\n   *  val p1Matches \u003d \"abbbc\" match {\n   *    case p1() \u003d\u003e true               // no groups\n   *    case _    \u003d\u003e false\n   *  }\n   *  val p2 \u003d \"a(b*)c\".r\n   *  val p2Matches \u003d \"abbbc\" match {\n   *    case p2(_*) \u003d\u003e true             // any groups\n   *    case _      \u003d\u003e false\n   *  }\n   *  val numberOfB \u003d \"abbbc\" match {\n   *    case p2(b) \u003d\u003e Some(b.length)    // one group\n   *    case _     \u003d\u003e None\n   *  }\n   *  val p3 \u003d \"b*\".r.unanchored\n   *  val p3Matches \u003d \"abbbc\" match {\n   *    case p3() \u003d\u003e true               // find the b\u0027s\n   *    case _    \u003d\u003e false\n   *  }\n   *  val p4 \u003d \"a(b*)(c+)\".r\n   *  val p4Matches \u003d \"abbbcc\" match {\n   *    case p4(_*) \u003d\u003e true             // multiple groups\n   *    case _      \u003d\u003e false\n   *  }\n   *  val allGroups \u003d \"abbbcc\" match {\n   *    case p4(all @ _*) \u003d\u003e all mkString \"/\" // \"bbb/cc\"\n   *    case _            \u003d\u003e \"\"\n   *  }\n   *  val cGroup \u003d \"abbbcc\" match {\n   *    case p4(_, c) \u003d\u003e c\n   *    case _        \u003d\u003e \"\"\n   *  }\n   *  }}}\n   *\n   *  @param  s     The string to match\n   *  @return       The matches\n   */\n  def unapplySeq(s: CharSequence): Option[List[String]] \u003d {\n    val m \u003d pattern.matcher(s)\n    if (runMatcher(m)) Some(List.tabulate(m.groupCount) { i \u003d\u003e m.group(i + 1) })\n    else None\n  }\n\n  /** Tries to match the String representation of a [[scala.Char]].\n   *\n   *  If the match succeeds, the result is the first matching\n   *  group if any groups are defined, or an empty Sequence otherwise.\n   *\n   *  For example:\n   *\n   *  {{{\n   *  val cat \u003d \"cat\"\n   *  // the case must consume the group to match\n   *  val r \u003d \"\"\"(\\p{Lower})\"\"\".r\n   *  cat(0) match { case r(x) \u003d\u003e true }\n   *  cat(0) match { case r(_) \u003d\u003e true }\n   *  cat(0) match { case r(_*) \u003d\u003e true }\n   *  cat(0) match { case r() \u003d\u003e true }     // no match\n   *\n   *  // there is no group to extract\n   *  val r \u003d \"\"\"\\p{Lower}\"\"\".r\n   *  cat(0) match { case r(x) \u003d\u003e true }    // no match\n   *  cat(0) match { case r(_) \u003d\u003e true }    // no match\n   *  cat(0) match { case r(_*) \u003d\u003e true }   // matches\n   *  cat(0) match { case r() \u003d\u003e true }     // matches\n   *\n   *  // even if there are multiple groups, only one is returned\n   *  val r \u003d \"\"\"((.))\"\"\".r\n   *  cat(0) match { case r(_) \u003d\u003e true }    // matches\n   *  cat(0) match { case r(_,_) \u003d\u003e true }  // no match\n   *  }}}\n   *\n   *  @param  c     The Char to match\n   *  @return       The match\n   */\n  def unapplySeq(c: Char): Option[List[Char]] \u003d {\n    val m \u003d pattern matcher c.toString\n    if (runMatcher(m)) {\n      if (m.groupCount \u003e 0) Some((m group 1).toList) else Some(Nil)\n    } else None\n  }\n\n  /** Tries to match on a [[scala.util.matching.Regex.Match]].\n   *\n   *  A previously failed match results in None.\n   *\n   *  If a successful match was made against the current pattern, then that result is used.\n   *\n   *  Otherwise, this Regex is applied to the previously matched input,\n   *  and the result of that match is used.\n   */\n  def unapplySeq(m: Match): Option[List[String]] \u003d\n    if (m.matched \u003d\u003d null) None\n    else if (m.matcher.pattern \u003d\u003d this.pattern) Regex.extractGroupsFromMatch(m)\n    else unapplySeq(m.matched)\n\n  //  @see UnanchoredRegex\n  protected def runMatcher(m: Matcher): Boolean \u003d m.matches()\n\n  /** Return all non-overlapping matches of this `Regex` in the given character\n   *  sequence as a [[scala.util.matching.Regex.MatchIterator]],\n   *  which is a special [[scala.collection.Iterator]] that returns the\n   *  matched strings but can also be queried for more data about the last match,\n   *  such as capturing groups and start position.\n   *\n   *  A `MatchIterator` can also be converted into an iterator\n   *  that returns objects of type [[scala.util.matching.Regex.Match]],\n   *  such as is normally returned by `findAllMatchIn`.\n   *\n   *  Where potential matches overlap, the first possible match is returned,\n   *  followed by the next match that follows the input consumed by the\n   *  first match:\n   *\n   *  {{{\n   *  val hat  \u003d \"hat[^a]+\".r\n   *  val hathaway \u003d \"hathatthattthatttt\"\n   *  val hats \u003d hat.findAllIn(hathaway).toList                     // List(hath, hattth)\n   *  val pos  \u003d hat.findAllMatchIn(hathaway).map(_.start).toList   // List(0, 7)\n   *  }}}\n   *\n   *  To return overlapping matches, it is possible to formulate a regular expression\n   *  with lookahead (`?\u003d`) that does not consume the overlapping region.\n   *\n   *  {{{\n   *  val madhatter \u003d \"(h)(?\u003d(at[^a]+))\".r\n   *  val madhats   \u003d madhatter.findAllMatchIn(hathaway).map {\n   *    case madhatter(x,y) \u003d\u003e s\"\\$x\\$y\"\n   *  }.toList                                       // List(hath, hatth, hattth, hatttt)\n   *  }}}\n   *\n   *  Attempting to retrieve match information after exhausting the iterator\n   *  results in [[java.lang.IllegalStateException]].\n   *  See [[scala.util.matching.Regex.MatchIterator]] for details.\n   *\n   *  @param source The text to match against.\n   *  @return       A [[scala.util.matching.Regex.MatchIterator]] of matched substrings.\n   *  @example      {{{for (words \u003c- \"\"\"\\w+\"\"\".r findAllIn \"A simple example.\") yield words}}}\n   */\n  def findAllIn(source: CharSequence): MatchIterator \u003d new Regex.MatchIterator(source, this, groupNames)\n\n  /** Return all non-overlapping matches of this regexp in given character sequence as a\n   *  [[scala.collection.Iterator]] of [[scala.util.matching.Regex.Match]].\n   *\n   *  @param source The text to match against.\n   *  @return       A [[scala.collection.Iterator]] of [[scala.util.matching.Regex.Match]] for all matches.\n   *  @example      {{{for (words \u003c- \"\"\"\\w+\"\"\".r findAllMatchIn \"A simple example.\") yield words.start}}}\n   */\n  def findAllMatchIn(source: CharSequence): Iterator[Match] \u003d {\n    val matchIterator \u003d findAllIn(source)\n    new AbstractIterator[Match] {\n      def hasNext \u003d matchIterator.hasNext\n      def next(): Match \u003d {\n        matchIterator.next()\n        new Match(matchIterator.source, matchIterator.matcher, matchIterator._groupNames).force\n      }\n    }\n  }\n\n  /** Return an optional first matching string of this `Regex` in the given character sequence,\n   *  or None if there is no match.\n   *\n   *  @param source The text to match against.\n   *  @return       An [[scala.Option]] of the first matching string in the text.\n   *  @example      {{{\"\"\"\\w+\"\"\".r findFirstIn \"A simple example.\" foreach println // prints \"A\"}}}\n   */\n  def findFirstIn(source: CharSequence): Option[String] \u003d {\n    val m \u003d pattern.matcher(source)\n    if (m.find) Some(m.group) else None\n  }\n\n  /** Return an optional first match of this `Regex` in the given character sequence,\n   *  or None if it does not exist.\n   *\n   *  If the match is successful, the [[scala.util.matching.Regex.Match]] can be queried for\n   *  more data.\n   *\n   *  @param source The text to match against.\n   *  @return       A [[scala.Option]] of [[scala.util.matching.Regex.Match]] of the first matching string in the text.\n   *  @example      {{{(\"\"\"[a-z]\"\"\".r findFirstMatchIn \"A simple example.\") map (_.start) // returns Some(2), the index of the first match in the text}}}\n   */\n  def findFirstMatchIn(source: CharSequence): Option[Match] \u003d {\n    val m \u003d pattern.matcher(source)\n    if (m.find) Some(new Match(source, m, groupNames)) else None\n  }\n\n  /** Return an optional match of this `Regex` at the beginning of the\n   *  given character sequence, or None if it matches no prefix\n   *  of the character sequence.\n   *\n   *  Unlike `findFirstIn`, this method will only return a match at\n   *  the beginning of the input.\n   *\n   *  @param source The text to match against.\n   *  @return       A [[scala.Option]] of the matched prefix.\n   *  @example      {{{\"\"\"\\p{Lower}\"\"\".r findPrefixOf \"A simple example.\" // returns None, since the text does not begin with a lowercase letter}}}\n   */\n  def findPrefixOf(source: CharSequence): Option[String] \u003d {\n    val m \u003d pattern.matcher(source)\n    if (m.lookingAt) Some(m.group) else None\n  }\n\n  /** Return an optional match of this `Regex` at the beginning of the\n   *  given character sequence, or None if it matches no prefix\n   *  of the character sequence.\n   *\n   *  Unlike `findFirstMatchIn`, this method will only return a match at\n   *  the beginning of the input.\n   *\n   *  @param source The text to match against.\n   *  @return       A [[scala.Option]] of the [[scala.util.matching.Regex.Match]] of the matched string.\n   *  @example      {{{\"\"\"\\w+\"\"\".r findPrefixMatchOf \"A simple example.\" map (_.after) // returns Some(\" simple example.\")}}}\n   */\n  def findPrefixMatchOf(source: CharSequence): Option[Match] \u003d {\n    val m \u003d pattern.matcher(source)\n    if (m.lookingAt) Some(new Match(source, m, groupNames)) else None\n  }\n\n  /** Returns whether this `Regex` matches the given character sequence.\n    *\n    * Like the extractor, this method takes anchoring into account.\n    *\n    * @param source The text to match against\n    * @return       true if and only if `source` matches this `Regex`.\n    * @see          [[Regex#unanchored]]\n    * @example      {{{\"\"\"\\d+\"\"\".r matches \"123\" // returns true}}}\n    */\n  def matches(source: CharSequence): Boolean \u003d\n    runMatcher(pattern.matcher(source))\n\n  /** Replaces all matches by a string.\n   *\n   *  $replacementString\n   *\n   *  @param target      The string to match\n   *  @param replacement The string that will replace each match\n   *  @return            The resulting string\n   *  @example           {{{\"\"\"\\d+\"\"\".r replaceAllIn (\"July 15\", \"\u003cNUMBER\u003e\") // returns \"July \u003cNUMBER\u003e\"}}}\n   */\n  def replaceAllIn(target: CharSequence, replacement: String): String \u003d {\n    val m \u003d pattern.matcher(target)\n    m.replaceAll(replacement)\n  }\n\n  /**\n   * Replaces all matches using a replacer function. The replacer function takes a\n   * [[scala.util.matching.Regex.Match]] so that extra information can be obtained\n   * from the match. For example:\n   *\n   * {{{\n   * import scala.util.matching.Regex\n   * val datePattern \u003d new Regex(\"\"\"(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)\"\"\", \"year\", \"month\", \"day\")\n   * val text \u003d \"From 2011-07-15 to 2011-07-17\"\n   * val repl \u003d datePattern replaceAllIn (text, m \u003d\u003e s\"\\${m group \"month\"}/\\${m group \"day\"}\")\n   * }}}\n   *\n   * $replacementString\n   *\n   * @param target      The string to match.\n   * @param replacer    The function which maps a match to another string.\n   * @return            The target string after replacements.\n   */\n  def replaceAllIn(target: CharSequence, replacer: Match \u003d\u003e String): String \u003d {\n    val it \u003d new Regex.MatchIterator(target, this, groupNames).replacementData\n    it foreach (md \u003d\u003e it replace replacer(md))\n    it.replaced\n  }\n\n  /**\n   * Replaces some of the matches using a replacer function that returns an [[scala.Option]].\n   * The replacer function takes a [[scala.util.matching.Regex.Match]] so that extra\n   * information can be obtained from the match. For example:\n   *\n   * {{{\n   * import scala.util.matching.Regex._\n   *\n   * val vars \u003d Map(\"x\" -\u003e \"a var\", \"y\" -\u003e \"\"\"some \\$ and \\ signs\"\"\")\n   * val text \u003d \"A text with variables %x, %y and %z.\"\n   * val varPattern \u003d \"\"\"%(\\w+)\"\"\".r\n   * val mapper \u003d (m: Match) \u003d\u003e vars get (m group 1) map (quoteReplacement(_))\n   * val repl \u003d varPattern replaceSomeIn (text, mapper)\n   * }}}\n   *\n   * $replacementString\n   *\n   * @param target      The string to match.\n   * @param replacer    The function which optionally maps a match to another string.\n   * @return            The target string after replacements.\n   */\n  def replaceSomeIn(target: CharSequence, replacer: Match \u003d\u003e Option[String]): String \u003d {\n    val it \u003d new Regex.MatchIterator(target, this, groupNames).replacementData\n    for (matchdata \u003c- it ; replacement \u003c- replacer(matchdata))\n      it replace replacement\n\n    it.replaced\n  }\n\n  /** Replaces the first match by a string.\n   *\n   *  $replacementString\n   *\n   *  @param target      The string to match\n   *  @param replacement The string that will replace the match\n   *  @return            The resulting string\n   */\n  def replaceFirstIn(target: CharSequence, replacement: String): String \u003d {\n    val m \u003d pattern.matcher(target)\n    m.replaceFirst(replacement)\n  }\n\n  /** Splits the provided character sequence around matches of this regexp.\n   *\n   *  @param toSplit The character sequence to split\n   *  @return        The array of strings computed by splitting the\n   *                 input around matches of this regexp\n   */\n  def split(toSplit: CharSequence): Array[String] \u003d\n    pattern.split(toSplit)\n\n  /** Create a new Regex with the same pattern, but no requirement that\n   *  the entire String matches in extractor patterns and [[Regex#matches]].\n   *\n   *  Normally, matching on `date` behaves as though the pattern were\n   *  enclosed in anchors, `\"^pattern\\$\"`.\n   *\n   *  The unanchored `Regex` behaves as though those anchors were removed.\n   *\n   *  Note that this method does not actually strip any matchers from the pattern.\n   *\n   *  Calling `anchored` returns the original `Regex`.\n   *\n   *  {{{\n   *  val date \u003d \"\"\"(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)\"\"\".r.unanchored\n   *\n   *  val date(year, month, day) \u003d \"Date 2011-07-15\"                       // OK\n   *\n   *  val copyright: String \u003d \"Date of this document: 2011-07-15\" match {\n   *    case date(year, month, day) \u003d\u003e s\"Copyright \\$year\"                  // OK\n   *    case _                      \u003d\u003e \"No copyright\"\n   *  }\n   *  }}}\n   *\n   *  @return        The new unanchored regex\n   */\n  def unanchored: UnanchoredRegex \u003d new Regex(pattern, groupNames: _*) with UnanchoredRegex { override def anchored \u003d outer }\n  def anchored: Regex             \u003d this\n\n  def regex: String \u003d pattern.pattern\n\n  /** The string defining the regular expression */\n  override def toString: String \u003d regex\n}\n\n/** A [[Regex]] that finds the first match when used in a pattern match.\n *\n *  @see [[Regex#unanchored]]\n */\ntrait UnanchoredRegex extends Regex {\n  override protected def runMatcher(m: Matcher): Boolean \u003d m.find()\n  override def unanchored: UnanchoredRegex \u003d this\n}\n\n/** This object defines inner classes that describe\n *  regex matches and helper objects.\n */\nobject Regex {\n\n  /** This class provides methods to access\n   *  the details of a match.\n   */\n  trait MatchData {\n\n    /** Basically, wraps a platform Matcher. */\n    protected def matcher: Matcher\n\n    /** The source from which the match originated */\n    val source: CharSequence\n\n    /** The names of the groups, or an empty sequence if none defined */\n    @deprecated(\"groupNames does not include inline group names, and should not be used anymore\", \"2.13.7\")\n    val groupNames: Seq[String]\n\n    /** The number of capturing groups in the pattern.\n     *  (For a given successful match, some of those groups may not have matched any input.)\n     */\n    def groupCount: Int\n\n    /** The index of the first matched character, or -1 if nothing was matched */\n    def start: Int\n\n    /** The index of the first matched character in group `i`,\n     *  or -1 if nothing was matched for that group.\n     */\n    def start(i: Int): Int\n\n    /** The index following the last matched character, or -1 if nothing was matched. */\n    def end: Int\n\n    /** The index following the last matched character in group `i`,\n     *  or -1 if nothing was matched for that group.\n     */\n    def end(i: Int): Int\n\n    /** The matched string, or `null` if nothing was matched. */\n    def matched: String \u003d\n      if (start \u003e\u003d 0) source.subSequence(start, end).toString\n      else null\n\n    /** The matched string in group `i`,\n     *  or `null` if nothing was matched.\n     */\n    def group(i: Int): String \u003d\n      if (start(i) \u003e\u003d 0) source.subSequence(start(i), end(i)).toString\n      else null\n\n    /** All capturing groups, i.e., not including group(0). */\n    def subgroups: List[String] \u003d (1 to groupCount).toList map group\n\n    /** The char sequence before first character of match,\n     *  or `null` if nothing was matched.\n     */\n    def before: CharSequence \u003d\n      if (start \u003e\u003d 0) source.subSequence(0, start)\n      else null\n\n    /** The char sequence before first character of match in group `i`,\n     *  or `null` if nothing was matched for that group.\n     */\n    def before(i: Int): CharSequence \u003d\n      if (start(i) \u003e\u003d 0) source.subSequence(0, start(i))\n      else null\n\n    /** Returns char sequence after last character of match,\n     *  or `null` if nothing was matched.\n     */\n    def after: CharSequence \u003d\n      if (end \u003e\u003d 0) source.subSequence(end, source.length)\n      else null\n\n    /** The char sequence after last character of match in group `i`,\n     *  or `null` if nothing was matched for that group.\n     */\n    def after(i: Int): CharSequence \u003d\n      if (end(i) \u003e\u003d 0) source.subSequence(end(i), source.length)\n      else null\n\n    @scala.annotation.nowarn(\"msg\u003ddeprecated\")\n    private def groupNamesNowarn: Seq[String] \u003d groupNames\n\n    private[this] lazy val nameToIndex: Map[String, Int] \u003d\n      Map[String, Int]() ++ (\"\" :: groupNamesNowarn.toList).zipWithIndex\n\n    /** Returns the group with the given name.\n     *\n     *  Uses explicit group names when supplied; otherwise,\n     *  queries the underlying implementation for inline named groups.\n     *  Not all platforms support inline group names.\n     *\n     *  @param id The group name\n     *  @return   The requested group\n     *  @throws   IllegalArgumentException if the requested group name is not defined\n     */\n    def group(id: String): String \u003d (\n      if (groupNamesNowarn.isEmpty)\n        matcher group id\n      else\n        nameToIndex.get(id) match {\n          case Some(index) \u003d\u003e group(index)\n          case None        \u003d\u003e matcher group id\n        }\n    )\n\n    /** The matched string; equivalent to `matched.toString`. */\n    override def toString: String \u003d matched\n  }\n\n  /** Provides information about a successful match. */\n  class Match(val source: CharSequence,\n              protected[matching] val matcher: Matcher,\n              _groupNames: Seq[String]) extends MatchData {\n\n    @deprecated(\"groupNames does not include inline group names, and should not be used anymore\", \"2.13.7\")\n    val groupNames: Seq[String] \u003d _groupNames\n\n    /** The index of the first matched character. */\n    val start: Int \u003d matcher.start\n\n    /** The index following the last matched character. */\n    val end: Int \u003d matcher.end\n\n    /** The number of subgroups. */\n    def groupCount: Int \u003d matcher.groupCount\n\n    private[this] lazy val starts: Array[Int] \u003d\n      Array.tabulate(groupCount + 1) { matcher.start }\n    private[this] lazy val ends: Array[Int] \u003d\n      Array.tabulate(groupCount + 1) { matcher.end }\n\n    /** The index of the first matched character in group `i`. */\n    def start(i: Int): Int \u003d starts(i)\n\n    /** The index following the last matched character in group `i`. */\n    def end(i: Int): Int \u003d ends(i)\n\n    /** The match itself with matcher-dependent lazy vals forced,\n     *  so that match is valid even once matcher is advanced.\n     */\n    def force: this.type \u003d { starts; ends; this }\n  }\n\n  /** An extractor object for Matches, yielding the matched string.\n   *\n   *  This can be used to help writing replacer functions when you\n   *  are not interested in match data. For example:\n   *\n   *  {{{\n   *  import scala.util.matching.Regex.Match\n   *  \"\"\"\\w+\"\"\".r replaceAllIn (\"A simple example.\", _ match { case Match(s) \u003d\u003e s.toUpperCase })\n   *  }}}\n   *\n   */\n  object Match {\n    def unapply(m: Match): Some[String] \u003d Some(m.matched)\n  }\n\n  /** An extractor object that yields the groups in the match. Using this extractor\n   *  rather than the original `Regex` ensures that the match is not recomputed.\n   *\n   *  {{{\n   *  import scala.util.matching.Regex.Groups\n   *\n   *  val date \u003d \"\"\"(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)\"\"\".r\n   *  val text \u003d \"The doc spree happened on 2011-07-15.\"\n   *  val day \u003d date replaceAllIn(text, _ match { case Groups(_, month, day) \u003d\u003e s\"\\$month/\\$day\" })\n   *  }}}\n   */\n  object Groups {\n    def unapplySeq(m: Match): Option[Seq[String]] \u003d {\n      if (m.groupCount \u003e 0) extractGroupsFromMatch(m) else None\n    }\n  }\n\n  @inline private def extractGroupsFromMatch(m: Match): Option[List[String]] \u003d\n     Some(List.tabulate(m.groupCount) { i \u003d\u003e m.group(i + 1) })\n\n  /** A class to step through a sequence of regex matches.\n   *\n   *  This is an iterator that returns the matched strings.\n   *\n   *  Queries about match data pertain to the current state of the underlying\n   *  matcher, which is advanced by calling `hasNext` or `next`.\n   *\n   *  When matches are exhausted, queries about match data will throw\n   *  [[java.lang.IllegalStateException]].\n   *\n   *  @see [[java.util.regex.Matcher]]\n   */\n  class MatchIterator(val source: CharSequence, val regex: Regex, private[Regex] val _groupNames: Seq[String])\n  extends AbstractIterator[String] with MatchData { self \u003d\u003e\n\n    @deprecated(\"groupNames does not include inline group names, and should not be used anymore\", \"2.13.7\")\n    val groupNames: Seq[String] \u003d _groupNames\n\n    protected[Regex] val matcher \u003d regex.pattern.matcher(source)\n\n    // 0 \u003d not yet matched, 1 \u003d matched, 2 \u003d advanced to match, 3 \u003d no more matches\n    private[this] var nextSeen \u003d 0\n\n    /** Return true if `next` will find a match.\n     *  As a side effect, advance the underlying matcher if necessary;\n     *  queries about the current match data pertain to the underlying matcher.\n     */\n    def hasNext: Boolean \u003d {\n      nextSeen match {\n        case 0 \u003d\u003e nextSeen \u003d if (matcher.find()) 1 else 3\n        case 1 \u003d\u003e ()\n        case 2 \u003d\u003e nextSeen \u003d 0 ; hasNext\n        case 3 \u003d\u003e ()\n      }\n      nextSeen \u003d\u003d 1      // otherwise, 3\n    }\n\n    /** The next matched substring of `source`.\n     *  As a side effect, advance the underlying matcher if necessary.\n     */\n    def next(): String \u003d {\n      nextSeen match {\n        case 0 \u003d\u003e if (!hasNext) throw new NoSuchElementException ; next()\n        case 1 \u003d\u003e nextSeen \u003d 2\n        case 2 \u003d\u003e nextSeen \u003d 0 ; next()\n        case 3 \u003d\u003e throw new NoSuchElementException\n      }\n      matcher.group\n    }\n\n    /** Report emptiness. */\n    override def toString: String \u003d super[AbstractIterator].toString\n\n    // ensure we\u0027re at a match\n    private[this] def ensure(): Unit \u003d nextSeen match {\n      case 0 \u003d\u003e if (!hasNext) throw new IllegalStateException\n      case 1 \u003d\u003e ()\n      case 2 \u003d\u003e ()\n      case 3 \u003d\u003e throw new IllegalStateException\n    }\n\n    /** The index of the first matched character. */\n    def start: Int \u003d { ensure() ; matcher.start }\n\n    /** The index of the first matched character in group `i`. */\n    def start(i: Int): Int \u003d { ensure() ; matcher.start(i) }\n\n    /** The index of the last matched character. */\n    def end: Int \u003d { ensure() ; matcher.end }\n\n    /** The index following the last matched character in group `i`. */\n    def end(i: Int): Int \u003d { ensure() ; matcher.end(i) }\n\n    /** The number of subgroups. */\n    def groupCount: Int \u003d { ensure() ; matcher.groupCount }\n\n    /** Convert to an iterator that yields MatchData elements instead of Strings. */\n    def matchData: Iterator[Match] \u003d new AbstractIterator[Match] {\n      def hasNext \u003d self.hasNext\n      def next() \u003d { self.next(); new Match(source, matcher, _groupNames).force }\n    }\n\n    /** Convert to an iterator that yields MatchData elements instead of Strings and has replacement support. */\n    private[matching] def replacementData \u003d new AbstractIterator[Match] with Replacement {\n      def matcher \u003d self.matcher\n      def hasNext \u003d self.hasNext\n      def next() \u003d { self.next(); new Match(source, matcher, _groupNames).force }\n    }\n  }\n\n  /**\n   * A trait able to build a string with replacements assuming it has a matcher.\n   * Meant to be mixed in with iterators.\n   */\n  private[matching] trait Replacement {\n    protected def matcher: Matcher\n\n    private[this] val sb \u003d new java.lang.StringBuffer\n\n    def replaced \u003d {\n      val newsb \u003d new java.lang.StringBuffer(sb)\n      matcher.appendTail(newsb)\n      newsb.toString\n    }\n\n    def replace(rs: String) \u003d matcher.appendReplacement(sb, rs)\n  }\n\n  /** Quotes strings to be used literally in regex patterns.\n   *\n   *  All regex metacharacters in the input match themselves literally in the output.\n   *\n   *  @example {{{List(\"US\\$\", \"CAN\\$\").map(Regex.quote).mkString(\"|\").r}}}\n   */\n  def quote(text: String): String \u003d Pattern quote text\n\n  /** Quotes replacement strings to be used in replacement methods.\n   *\n   *  Replacement methods give special meaning to backslashes (`\\`) and\n   *  dollar signs (`\\$`) in replacement strings, so they are not treated\n   *  as literals. This method escapes these characters so the resulting\n   *  string can be used as a literal replacement representing the input\n   *  string.\n   *\n   *  @param text The string one wishes to use as literal replacement.\n   *  @return A string that can be used to replace matches with `text`.\n   *  @example {{{\"CURRENCY\".r.replaceAllIn(input, Regex quoteReplacement \"US\\$\")}}}\n   */\n  def quoteReplacement(text: String): String \u003d Matcher quoteReplacement text\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/util/matching/Regex.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/util/matching/Regex.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:52:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/util/matching/Regex.scala"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/util/matching/Regex.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/util/matching/Regex.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

2024.04.26 03:52:03 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/util/matching/Regex.scala

Uri: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/util/matching/Regex.scala


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:903)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	java.base/java.lang.reflect.Method.invoke(Method.java:578)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1589)
```

Apr. 26, 2024 3:52:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Gewin%20Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar%21/scala/util/matching/Regex.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n/**\n * This package is concerned with regular expression (regex) matching against strings,\n * with the main goal of pulling out information from those matches, or replacing\n * them with something else.\n *\n * [[scala.util.matching.Regex]] is the class users instantiate to do regular expression matching.\n *\n * The companion object to [[scala.util.matching.Regex]] contains supporting members:\n * * [[scala.util.matching.Regex.Match]] makes more information about a match available.\n * * [[scala.util.matching.Regex.MatchIterator]] is used to iterate over matched strings.\n * * [[scala.util.matching.Regex.MatchData]] is just a base trait for the above classes.\n * * [[scala.util.matching.Regex.Groups]] extracts group from a [[scala.util.matching.Regex.Match]]\n *   without recomputing the match.\n */\npackage scala.util.matching\n\nimport scala.collection.AbstractIterator\nimport java.util.regex.{ Pattern, Matcher }\n\n/** A regular expression is used to determine whether a string matches a pattern\n *  and, if it does, to extract or transform the parts that match.\n *\n *  \u003d\u003d\u003d Usage \u003d\u003d\u003d\n\n *  This class delegates to the [[https://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html java.util.regex]] package of the Java Platform.\n *  See the documentation for [[java.util.regex.Pattern]] for details about\n *  the regular expression syntax for pattern strings.\n *\n *  An instance of `Regex` represents a compiled regular expression pattern.\n *  Since compilation is expensive, frequently used `Regex`es should be constructed\n *  once, outside of loops and perhaps in a companion object.\n *\n *  The canonical way to create a `Regex` is by using the method `r`, provided\n *  implicitly for strings:\n *\n *  {{{\n *  val date \u003d raw\"(\\d{4})-(\\d{2})-(\\d{2})\".r\n *  }}}\n *\n *  Since escapes are not processed in multi-line string literals, using triple quotes\n *  avoids having to escape the backslash character, so that `\"\\\\d\"` can be written `\"\"\"\\d\"\"\"`.\n *  The same result is achieved with certain interpolators, such as `raw\"\\d\".r` or\n *  a custom interpolator `r\"\\d\"` that also compiles the `Regex`.\n *\n *  \u003d\u003d\u003d Extraction \u003d\u003d\u003d\n *  To extract the capturing groups when a `Regex` is matched, use it as\n *  an extractor in a pattern match:\n *\n *  {{{\n *  \"2004-01-20\" match {\n *    case date(year, month, day) \u003d\u003e s\"\\$year was a good year for PLs.\"\n *  }\n *  }}}\n *\n *  To check only whether the `Regex` matches, ignoring any groups,\n *  use a sequence wildcard:\n *\n *  {{{\n *  \"2004-01-20\" match {\n *    case date(_*) \u003d\u003e \"It\u0027s a date!\"\n *  }\n *  }}}\n *\n *  That works because a `Regex` extractor produces a sequence of strings.\n *  Extracting only the year from a date could also be expressed with\n *  a sequence wildcard:\n *\n *  {{{\n *  \"2004-01-20\" match {\n *    case date(year, _*) \u003d\u003e s\"\\$year was a good year for PLs.\"\n *  }\n *  }}}\n *\n *  In a pattern match, `Regex` normally matches the entire input.\n *  However, an unanchored `Regex` finds the pattern anywhere\n *  in the input.\n *\n *  {{{\n *  val embeddedDate \u003d date.unanchored\n *  \"Date: 2004-01-20 17:25:18 GMT (10 years, 28 weeks, 5 days, 17 hours and 51 minutes ago)\" match {\n *    case embeddedDate(\"2004\", \"01\", \"20\") \u003d\u003e \"A Scala is born.\"\n *  }\n *  }}}\n *\n *  \u003d\u003d\u003d Find Matches \u003d\u003d\u003d\n *  To find or replace matches of the pattern, use the various find and replace methods.\n *  For each method, there is a version for working with matched strings and\n *  another for working with `Match` objects.\n *\n *  For example, pattern matching with an unanchored `Regex`, as in the previous example,\n *  can also be accomplished using `findFirstMatchIn`. The `findFirst` methods return an `Option`\n *  which is non-empty if a match is found, or `None` for no match:\n *\n *  {{{\n *  val dates \u003d \"Important dates in history: 2004-01-20, 1958-09-05, 2010-10-06, 2011-07-15\"\n *  val firstDate \u003d date.findFirstIn(dates).getOrElse(\"No date found.\")\n *  val firstYear \u003d for (m \u003c- date.findFirstMatchIn(dates)) yield m.group(1)\n *  }}}\n *\n *  To find all matches:\n *\n *  {{{\n *  val allYears \u003d for (m \u003c- date.findAllMatchIn(dates)) yield m.group(1)\n *  }}}\n *\n *  To check whether input is matched by the regex:\n *\n *  {{{\n *  date.matches(\"2018-03-01\")                     // true\n *  date.matches(\"Today is 2018-03-01\")            // false\n *  date.unanchored.matches(\"Today is 2018-03-01\") // true\n *  }}}\n *\n *  To iterate over the matched strings, use `findAllIn`, which returns a special iterator\n *  that can be queried for the `MatchData` of the last match:\n *\n *  {{{\n *  val mi \u003d date.findAllIn(dates)\n *  while (mi.hasNext) {\n *    val d \u003d mi.next\n *    if (mi.group(1).toInt \u003c 1960) println(s\"\\$d: An oldie but goodie.\")\n *  }\n *  }}}\n *\n *  Although the `MatchIterator` returned by `findAllIn` is used like any `Iterator`,\n *  with alternating calls to `hasNext` and `next`, `hasNext` has the additional\n *  side effect of advancing the underlying matcher to the next unconsumed match.\n *  This effect is visible in the `MatchData` representing the \"current match\".\n *\n *  {{{\n *  val r \u003d \"(ab+c)\".r\n *  val s \u003d \"xxxabcyyyabbczzz\"\n *  r.findAllIn(s).start    // 3\n *  val mi \u003d r.findAllIn(s)\n *  mi.hasNext              // true\n *  mi.start                // 3\n *  mi.next()               // \"abc\"\n *  mi.start                // 3\n *  mi.hasNext              // true\n *  mi.start                // 9\n *  mi.next()               // \"abbc\"\n *  }}}\n *\n *  The example shows that methods on `MatchData` such as `start` will advance to\n *  the first match, if necessary. It also shows that `hasNext` will advance to\n *  the next unconsumed match, if `next` has already returned the current match.\n *\n *  The current `MatchData` can be captured using the `matchData` method.\n *  Alternatively, `findAllMatchIn` returns an `Iterator[Match]`, where there\n *  is no interaction between the iterator and `Match` objects it has already produced.\n *\n *  Note that `findAllIn` finds matches that don\u0027t overlap. (See [[findAllIn]] for more examples.)\n *\n *  {{{\n *  val num \u003d raw\"(\\d+)\".r\n *  val all \u003d num.findAllIn(\"123\").toList  // List(\"123\"), not List(\"123\", \"23\", \"3\")\n *  }}}\n *\n *  \u003d\u003d\u003d Replace Text \u003d\u003d\u003d\n *  Text replacement can be performed unconditionally or as a function of the current match:\n *\n *  {{{\n *  val redacted    \u003d date.replaceAllIn(dates, \"XXXX-XX-XX\")\n *  val yearsOnly   \u003d date.replaceAllIn(dates, m \u003d\u003e m.group(1))\n *  val months      \u003d (0 to 11).map { i \u003d\u003e val c \u003d Calendar.getInstance; c.set(2014, i, 1); f\"\\$c%tb\" }\n *  val reformatted \u003d date.replaceAllIn(dates, _ match { case date(y,m,d) \u003d\u003e f\"\\${months(m.toInt - 1)} \\$d, \\$y\" })\n *  }}}\n *\n *  Pattern matching the `Match` against the `Regex` that created it does not reapply the `Regex`.\n *  In the expression for `reformatted`, each `date` match is computed once. But it is possible to apply a\n *  `Regex` to a `Match` resulting from a different pattern:\n *\n *  {{{\n *  val docSpree \u003d \"\"\"2011(?:-\\d{2}){2}\"\"\".r\n *  val docView  \u003d date.replaceAllIn(dates, _ match {\n *    case docSpree() \u003d\u003e \"Historic doc spree!\"\n *    case _          \u003d\u003e \"Something else happened\"\n *  })\n *  }}}\n *\n *  @see [[java.util.regex.Pattern]]\n *\n *  @param pattern    The compiled pattern\n *  @param groupNames A mapping from names to indices in capture groups\n *\n *  @define replacementString\n *  In the replacement String, a dollar sign (`\\$`) followed by a number will be\n *  interpreted as a reference to a group in the matched pattern, with numbers\n *  1 through 9 corresponding to the first nine groups, and 0 standing for the\n *  whole match. Any other character is an error. The backslash (`\\`) character\n *  will be interpreted as an escape character and can be used to escape the\n *  dollar sign. Use `Regex.quoteReplacement` to escape these characters.\n */\n@SerialVersionUID(-2094783597747625537L)\nclass Regex private[matching](val pattern: Pattern, groupNames: String*) extends Serializable {\n  outer \u003d\u003e\n\n  import Regex._\n\n  /** Compile a regular expression, supplied as a string, into a pattern that\n   *  can be matched against inputs.\n   *\n   *  If group names are supplied, they can be used this way:\n   *\n   *  {{{\n   *  val namedDate  \u003d new Regex(\"\"\"(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)\"\"\", \"year\", \"month\", \"day\")\n   *  val namedYears \u003d for (m \u003c- namedDate findAllMatchIn dates) yield m group \"year\"\n   *  }}}\n   *\n   *  Inline group names are preferred over group names supplied to the constructor\n   *  when retrieving matched groups by name. Group names supplied to the constructor\n   *  should be considered deprecated.\n   *\n   *  This constructor does not support options as flags, which must be\n   *  supplied as inline flags in the pattern string: `(?idmsuxU)`.\n   *\n   *  @param regex      The regular expression to compile.\n   *  @param groupNames Names of capturing groups.\n   */\n  // we cannot add the alternative `def this(regex: String)` in a forward binary compatible way:\n  // @deprecated(\"use inline group names like (?\u003cyear\u003eX) instead\", \"2.13.7\")\n  def this(regex: String, groupNames: String*) \u003d this(Pattern.compile(regex), groupNames: _*)\n\n  /** Tries to match a [[java.lang.CharSequence]].\n   *\n   *  If the match succeeds, the result is a list of the matching\n   *  groups (or a `null` element if a group did not match any input).\n   *  If the pattern specifies no groups, then the result will be an empty list\n   *  on a successful match.\n   *\n   *  This method attempts to match the entire input by default; to find the next\n   *  matching subsequence, use an unanchored `Regex`.\n   *\n   *  For example:\n   *\n   *  {{{\n   *  val p1 \u003d \"ab*c\".r\n   *  val p1Matches \u003d \"abbbc\" match {\n   *    case p1() \u003d\u003e true               // no groups\n   *    case _    \u003d\u003e false\n   *  }\n   *  val p2 \u003d \"a(b*)c\".r\n   *  val p2Matches \u003d \"abbbc\" match {\n   *    case p2(_*) \u003d\u003e true             // any groups\n   *    case _      \u003d\u003e false\n   *  }\n   *  val numberOfB \u003d \"abbbc\" match {\n   *    case p2(b) \u003d\u003e Some(b.length)    // one group\n   *    case _     \u003d\u003e None\n   *  }\n   *  val p3 \u003d \"b*\".r.unanchored\n   *  val p3Matches \u003d \"abbbc\" match {\n   *    case p3() \u003d\u003e true               // find the b\u0027s\n   *    case _    \u003d\u003e false\n   *  }\n   *  val p4 \u003d \"a(b*)(c+)\".r\n   *  val p4Matches \u003d \"abbbcc\" match {\n   *    case p4(_*) \u003d\u003e true             // multiple groups\n   *    case _      \u003d\u003e false\n   *  }\n   *  val allGroups \u003d \"abbbcc\" match {\n   *    case p4(all @ _*) \u003d\u003e all mkString \"/\" // \"bbb/cc\"\n   *    case _            \u003d\u003e \"\"\n   *  }\n   *  val cGroup \u003d \"abbbcc\" match {\n   *    case p4(_, c) \u003d\u003e c\n   *    case _        \u003d\u003e \"\"\n   *  }\n   *  }}}\n   *\n   *  @param  s     The string to match\n   *  @return       The matches\n   */\n  def unapplySeq(s: CharSequence): Option[List[String]] \u003d {\n    val m \u003d pattern.matcher(s)\n    if (runMatcher(m)) Some(List.tabulate(m.groupCount) { i \u003d\u003e m.group(i + 1) })\n    else None\n  }\n\n  /** Tries to match the String representation of a [[scala.Char]].\n   *\n   *  If the match succeeds, the result is the first matching\n   *  group if any groups are defined, or an empty Sequence otherwise.\n   *\n   *  For example:\n   *\n   *  {{{\n   *  val cat \u003d \"cat\"\n   *  // the case must consume the group to match\n   *  val r \u003d \"\"\"(\\p{Lower})\"\"\".r\n   *  cat(0) match { case r(x) \u003d\u003e true }\n   *  cat(0) match { case r(_) \u003d\u003e true }\n   *  cat(0) match { case r(_*) \u003d\u003e true }\n   *  cat(0) match { case r() \u003d\u003e true }     // no match\n   *\n   *  // there is no group to extract\n   *  val r \u003d \"\"\"\\p{Lower}\"\"\".r\n   *  cat(0) match { case r(x) \u003d\u003e true }    // no match\n   *  cat(0) match { case r(_) \u003d\u003e true }    // no match\n   *  cat(0) match { case r(_*) \u003d\u003e true }   // matches\n   *  cat(0) match { case r() \u003d\u003e true }     // matches\n   *\n   *  // even if there are multiple groups, only one is returned\n   *  val r \u003d \"\"\"((.))\"\"\".r\n   *  cat(0) match { case r(_) \u003d\u003e true }    // matches\n   *  cat(0) match { case r(_,_) \u003d\u003e true }  // no match\n   *  }}}\n   *\n   *  @param  c     The Char to match\n   *  @return       The match\n   */\n  def unapplySeq(c: Char): Option[List[Char]] \u003d {\n    val m \u003d pattern matcher c.toString\n    if (runMatcher(m)) {\n      if (m.groupCount \u003e 0) Some((m group 1).toList) else Some(Nil)\n    } else None\n  }\n\n  /** Tries to match on a [[scala.util.matching.Regex.Match]].\n   *\n   *  A previously failed match results in None.\n   *\n   *  If a successful match was made against the current pattern, then that result is used.\n   *\n   *  Otherwise, this Regex is applied to the previously matched input,\n   *  and the result of that match is used.\n   */\n  def unapplySeq(m: Match): Option[List[String]] \u003d\n    if (m.matched \u003d\u003d null) None\n    else if (m.matcher.pattern \u003d\u003d this.pattern) Regex.extractGroupsFromMatch(m)\n    else unapplySeq(m.matched)\n\n  //  @see UnanchoredRegex\n  protected def runMatcher(m: Matcher): Boolean \u003d m.matches()\n\n  /** Return all non-overlapping matches of this `Regex` in the given character\n   *  sequence as a [[scala.util.matching.Regex.MatchIterator]],\n   *  which is a special [[scala.collection.Iterator]] that returns the\n   *  matched strings but can also be queried for more data about the last match,\n   *  such as capturing groups and start position.\n   *\n   *  A `MatchIterator` can also be converted into an iterator\n   *  that returns objects of type [[scala.util.matching.Regex.Match]],\n   *  such as is normally returned by `findAllMatchIn`.\n   *\n   *  Where potential matches overlap, the first possible match is returned,\n   *  followed by the next match that follows the input consumed by the\n   *  first match:\n   *\n   *  {{{\n   *  val hat  \u003d \"hat[^a]+\".r\n   *  val hathaway \u003d \"hathatthattthatttt\"\n   *  val hats \u003d hat.findAllIn(hathaway).toList                     // List(hath, hattth)\n   *  val pos  \u003d hat.findAllMatchIn(hathaway).map(_.start).toList   // List(0, 7)\n   *  }}}\n   *\n   *  To return overlapping matches, it is possible to formulate a regular expression\n   *  with lookahead (`?\u003d`) that does not consume the overlapping region.\n   *\n   *  {{{\n   *  val madhatter \u003d \"(h)(?\u003d(at[^a]+))\".r\n   *  val madhats   \u003d madhatter.findAllMatchIn(hathaway).map {\n   *    case madhatter(x,y) \u003d\u003e s\"\\$x\\$y\"\n   *  }.toList                                       // List(hath, hatth, hattth, hatttt)\n   *  }}}\n   *\n   *  Attempting to retrieve match information after exhausting the iterator\n   *  results in [[java.lang.IllegalStateException]].\n   *  See [[scala.util.matching.Regex.MatchIterator]] for details.\n   *\n   *  @param source The text to match against.\n   *  @return       A [[scala.util.matching.Regex.MatchIterator]] of matched substrings.\n   *  @example      {{{for (words \u003c- \"\"\"\\w+\"\"\".r findAllIn \"A simple example.\") yield words}}}\n   */\n  def findAllIn(source: CharSequence): MatchIterator \u003d new Regex.MatchIterator(source, this, groupNames)\n\n  /** Return all non-overlapping matches of this regexp in given character sequence as a\n   *  [[scala.collection.Iterator]] of [[scala.util.matching.Regex.Match]].\n   *\n   *  @param source The text to match against.\n   *  @return       A [[scala.collection.Iterator]] of [[scala.util.matching.Regex.Match]] for all matches.\n   *  @example      {{{for (words \u003c- \"\"\"\\w+\"\"\".r findAllMatchIn \"A simple example.\") yield words.start}}}\n   */\n  def findAllMatchIn(source: CharSequence): Iterator[Match] \u003d {\n    val matchIterator \u003d findAllIn(source)\n    new AbstractIterator[Match] {\n      def hasNext \u003d matchIterator.hasNext\n      def next(): Match \u003d {\n        matchIterator.next()\n        new Match(matchIterator.source, matchIterator.matcher, matchIterator._groupNames).force\n      }\n    }\n  }\n\n  /** Return an optional first matching string of this `Regex` in the given character sequence,\n   *  or None if there is no match.\n   *\n   *  @param source The text to match against.\n   *  @return       An [[scala.Option]] of the first matching string in the text.\n   *  @example      {{{\"\"\"\\w+\"\"\".r findFirstIn \"A simple example.\" foreach println // prints \"A\"}}}\n   */\n  def findFirstIn(source: CharSequence): Option[String] \u003d {\n    val m \u003d pattern.matcher(source)\n    if (m.find) Some(m.group) else None\n  }\n\n  /** Return an optional first match of this `Regex` in the given character sequence,\n   *  or None if it does not exist.\n   *\n   *  If the match is successful, the [[scala.util.matching.Regex.Match]] can be queried for\n   *  more data.\n   *\n   *  @param source The text to match against.\n   *  @return       A [[scala.Option]] of [[scala.util.matching.Regex.Match]] of the first matching string in the text.\n   *  @example      {{{(\"\"\"[a-z]\"\"\".r findFirstMatchIn \"A simple example.\") map (_.start) // returns Some(2), the index of the first match in the text}}}\n   */\n  def findFirstMatchIn(source: CharSequence): Option[Match] \u003d {\n    val m \u003d pattern.matcher(source)\n    if (m.find) Some(new Match(source, m, groupNames)) else None\n  }\n\n  /** Return an optional match of this `Regex` at the beginning of the\n   *  given character sequence, or None if it matches no prefix\n   *  of the character sequence.\n   *\n   *  Unlike `findFirstIn`, this method will only return a match at\n   *  the beginning of the input.\n   *\n   *  @param source The text to match against.\n   *  @return       A [[scala.Option]] of the matched prefix.\n   *  @example      {{{\"\"\"\\p{Lower}\"\"\".r findPrefixOf \"A simple example.\" // returns None, since the text does not begin with a lowercase letter}}}\n   */\n  def findPrefixOf(source: CharSequence): Option[String] \u003d {\n    val m \u003d pattern.matcher(source)\n    if (m.lookingAt) Some(m.group) else None\n  }\n\n  /** Return an optional match of this `Regex` at the beginning of the\n   *  given character sequence, or None if it matches no prefix\n   *  of the character sequence.\n   *\n   *  Unlike `findFirstMatchIn`, this method will only return a match at\n   *  the beginning of the input.\n   *\n   *  @param source The text to match against.\n   *  @return       A [[scala.Option]] of the [[scala.util.matching.Regex.Match]] of the matched string.\n   *  @example      {{{\"\"\"\\w+\"\"\".r findPrefixMatchOf \"A simple example.\" map (_.after) // returns Some(\" simple example.\")}}}\n   */\n  def findPrefixMatchOf(source: CharSequence): Option[Match] \u003d {\n    val m \u003d pattern.matcher(source)\n    if (m.lookingAt) Some(new Match(source, m, groupNames)) else None\n  }\n\n  /** Returns whether this `Regex` matches the given character sequence.\n    *\n    * Like the extractor, this method takes anchoring into account.\n    *\n    * @param source The text to match against\n    * @return       true if and only if `source` matches this `Regex`.\n    * @see          [[Regex#unanchored]]\n    * @example      {{{\"\"\"\\d+\"\"\".r matches \"123\" // returns true}}}\n    */\n  def matches(source: CharSequence): Boolean \u003d\n    runMatcher(pattern.matcher(source))\n\n  /** Replaces all matches by a string.\n   *\n   *  $replacementString\n   *\n   *  @param target      The string to match\n   *  @param replacement The string that will replace each match\n   *  @return            The resulting string\n   *  @example           {{{\"\"\"\\d+\"\"\".r replaceAllIn (\"July 15\", \"\u003cNUMBER\u003e\") // returns \"July \u003cNUMBER\u003e\"}}}\n   */\n  def replaceAllIn(target: CharSequence, replacement: String): String \u003d {\n    val m \u003d pattern.matcher(target)\n    m.replaceAll(replacement)\n  }\n\n  /**\n   * Replaces all matches using a replacer function. The replacer function takes a\n   * [[scala.util.matching.Regex.Match]] so that extra information can be obtained\n   * from the match. For example:\n   *\n   * {{{\n   * import scala.util.matching.Regex\n   * val datePattern \u003d new Regex(\"\"\"(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)\"\"\", \"year\", \"month\", \"day\")\n   * val text \u003d \"From 2011-07-15 to 2011-07-17\"\n   * val repl \u003d datePattern replaceAllIn (text, m \u003d\u003e s\"\\${m group \"month\"}/\\${m group \"day\"}\")\n   * }}}\n   *\n   * $replacementString\n   *\n   * @param target      The string to match.\n   * @param replacer    The function which maps a match to another string.\n   * @return            The target string after replacements.\n   */\n  def replaceAllIn(target: CharSequence, replacer: Match \u003d\u003e String): String \u003d {\n    val it \u003d new Regex.MatchIterator(target, this, groupNames).replacementData\n    it foreach (md \u003d\u003e it replace replacer(md))\n    it.replaced\n  }\n\n  /**\n   * Replaces some of the matches using a replacer function that returns an [[scala.Option]].\n   * The replacer function takes a [[scala.util.matching.Regex.Match]] so that extra\n   * information can be obtained from the match. For example:\n   *\n   * {{{\n   * import scala.util.matching.Regex._\n   *\n   * val vars \u003d Map(\"x\" -\u003e \"a var\", \"y\" -\u003e \"\"\"some \\$ and \\ signs\"\"\")\n   * val text \u003d \"A text with variables %x, %y and %z.\"\n   * val varPattern \u003d \"\"\"%(\\w+)\"\"\".r\n   * val mapper \u003d (m: Match) \u003d\u003e vars get (m group 1) map (quoteReplacement(_))\n   * val repl \u003d varPattern replaceSomeIn (text, mapper)\n   * }}}\n   *\n   * $replacementString\n   *\n   * @param target      The string to match.\n   * @param replacer    The function which optionally maps a match to another string.\n   * @return            The target string after replacements.\n   */\n  def replaceSomeIn(target: CharSequence, replacer: Match \u003d\u003e Option[String]): String \u003d {\n    val it \u003d new Regex.MatchIterator(target, this, groupNames).replacementData\n    for (matchdata \u003c- it ; replacement \u003c- replacer(matchdata))\n      it replace replacement\n\n    it.replaced\n  }\n\n  /** Replaces the first match by a string.\n   *\n   *  $replacementString\n   *\n   *  @param target      The string to match\n   *  @param replacement The string that will replace the match\n   *  @return            The resulting string\n   */\n  def replaceFirstIn(target: CharSequence, replacement: String): String \u003d {\n    val m \u003d pattern.matcher(target)\n    m.replaceFirst(replacement)\n  }\n\n  /** Splits the provided character sequence around matches of this regexp.\n   *\n   *  @param toSplit The character sequence to split\n   *  @return        The array of strings computed by splitting the\n   *                 input around matches of this regexp\n   */\n  def split(toSplit: CharSequence): Array[String] \u003d\n    pattern.split(toSplit)\n\n  /** Create a new Regex with the same pattern, but no requirement that\n   *  the entire String matches in extractor patterns and [[Regex#matches]].\n   *\n   *  Normally, matching on `date` behaves as though the pattern were\n   *  enclosed in anchors, `\"^pattern\\$\"`.\n   *\n   *  The unanchored `Regex` behaves as though those anchors were removed.\n   *\n   *  Note that this method does not actually strip any matchers from the pattern.\n   *\n   *  Calling `anchored` returns the original `Regex`.\n   *\n   *  {{{\n   *  val date \u003d \"\"\"(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)\"\"\".r.unanchored\n   *\n   *  val date(year, month, day) \u003d \"Date 2011-07-15\"                       // OK\n   *\n   *  val copyright: String \u003d \"Date of this document: 2011-07-15\" match {\n   *    case date(year, month, day) \u003d\u003e s\"Copyright \\$year\"                  // OK\n   *    case _                      \u003d\u003e \"No copyright\"\n   *  }\n   *  }}}\n   *\n   *  @return        The new unanchored regex\n   */\n  def unanchored: UnanchoredRegex \u003d new Regex(pattern, groupNames: _*) with UnanchoredRegex { override def anchored \u003d outer }\n  def anchored: Regex             \u003d this\n\n  def regex: String \u003d pattern.pattern\n\n  /** The string defining the regular expression */\n  override def toString: String \u003d regex\n}\n\n/** A [[Regex]] that finds the first match when used in a pattern match.\n *\n *  @see [[Regex#unanchored]]\n */\ntrait UnanchoredRegex extends Regex {\n  override protected def runMatcher(m: Matcher): Boolean \u003d m.find()\n  override def unanchored: UnanchoredRegex \u003d this\n}\n\n/** This object defines inner classes that describe\n *  regex matches and helper objects.\n */\nobject Regex {\n\n  /** This class provides methods to access\n   *  the details of a match.\n   */\n  trait MatchData {\n\n    /** Basically, wraps a platform Matcher. */\n    protected def matcher: Matcher\n\n    /** The source from which the match originated */\n    val source: CharSequence\n\n    /** The names of the groups, or an empty sequence if none defined */\n    @deprecated(\"groupNames does not include inline group names, and should not be used anymore\", \"2.13.7\")\n    val groupNames: Seq[String]\n\n    /** The number of capturing groups in the pattern.\n     *  (For a given successful match, some of those groups may not have matched any input.)\n     */\n    def groupCount: Int\n\n    /** The index of the first matched character, or -1 if nothing was matched */\n    def start: Int\n\n    /** The index of the first matched character in group `i`,\n     *  or -1 if nothing was matched for that group.\n     */\n    def start(i: Int): Int\n\n    /** The index following the last matched character, or -1 if nothing was matched. */\n    def end: Int\n\n    /** The index following the last matched character in group `i`,\n     *  or -1 if nothing was matched for that group.\n     */\n    def end(i: Int): Int\n\n    /** The matched string, or `null` if nothing was matched. */\n    def matched: String \u003d\n      if (start \u003e\u003d 0) source.subSequence(start, end).toString\n      else null\n\n    /** The matched string in group `i`,\n     *  or `null` if nothing was matched.\n     */\n    def group(i: Int): String \u003d\n      if (start(i) \u003e\u003d 0) source.subSequence(start(i), end(i)).toString\n      else null\n\n    /** All capturing groups, i.e., not including group(0). */\n    def subgroups: List[String] \u003d (1 to groupCount).toList map group\n\n    /** The char sequence before first character of match,\n     *  or `null` if nothing was matched.\n     */\n    def before: CharSequence \u003d\n      if (start \u003e\u003d 0) source.subSequence(0, start)\n      else null\n\n    /** The char sequence before first character of match in group `i`,\n     *  or `null` if nothing was matched for that group.\n     */\n    def before(i: Int): CharSequence \u003d\n      if (start(i) \u003e\u003d 0) source.subSequence(0, start(i))\n      else null\n\n    /** Returns char sequence after last character of match,\n     *  or `null` if nothing was matched.\n     */\n    def after: CharSequence \u003d\n      if (end \u003e\u003d 0) source.subSequence(end, source.length)\n      else null\n\n    /** The char sequence after last character of match in group `i`,\n     *  or `null` if nothing was matched for that group.\n     */\n    def after(i: Int): CharSequence \u003d\n      if (end(i) \u003e\u003d 0) source.subSequence(end(i), source.length)\n      else null\n\n    @scala.annotation.nowarn(\"msg\u003ddeprecated\")\n    private def groupNamesNowarn: Seq[String] \u003d groupNames\n\n    private[this] lazy val nameToIndex: Map[String, Int] \u003d\n      Map[String, Int]() ++ (\"\" :: groupNamesNowarn.toList).zipWithIndex\n\n    /** Returns the group with the given name.\n     *\n     *  Uses explicit group names when supplied; otherwise,\n     *  queries the underlying implementation for inline named groups.\n     *  Not all platforms support inline group names.\n     *\n     *  @param id The group name\n     *  @return   The requested group\n     *  @throws   IllegalArgumentException if the requested group name is not defined\n     */\n    def group(id: String): String \u003d (\n      if (groupNamesNowarn.isEmpty)\n        matcher group id\n      else\n        nameToIndex.get(id) match {\n          case Some(index) \u003d\u003e group(index)\n          case None        \u003d\u003e matcher group id\n        }\n    )\n\n    /** The matched string; equivalent to `matched.toString`. */\n    override def toString: String \u003d matched\n  }\n\n  /** Provides information about a successful match. */\n  class Match(val source: CharSequence,\n              protected[matching] val matcher: Matcher,\n              _groupNames: Seq[String]) extends MatchData {\n\n    @deprecated(\"groupNames does not include inline group names, and should not be used anymore\", \"2.13.7\")\n    val groupNames: Seq[String] \u003d _groupNames\n\n    /** The index of the first matched character. */\n    val start: Int \u003d matcher.start\n\n    /** The index following the last matched character. */\n    val end: Int \u003d matcher.end\n\n    /** The number of subgroups. */\n    def groupCount: Int \u003d matcher.groupCount\n\n    private[this] lazy val starts: Array[Int] \u003d\n      Array.tabulate(groupCount + 1) { matcher.start }\n    private[this] lazy val ends: Array[Int] \u003d\n      Array.tabulate(groupCount + 1) { matcher.end }\n\n    /** The index of the first matched character in group `i`. */\n    def start(i: Int): Int \u003d starts(i)\n\n    /** The index following the last matched character in group `i`. */\n    def end(i: Int): Int \u003d ends(i)\n\n    /** The match itself with matcher-dependent lazy vals forced,\n     *  so that match is valid even once matcher is advanced.\n     */\n    def force: this.type \u003d { starts; ends; this }\n  }\n\n  /** An extractor object for Matches, yielding the matched string.\n   *\n   *  This can be used to help writing replacer functions when you\n   *  are not interested in match data. For example:\n   *\n   *  {{{\n   *  import scala.util.matching.Regex.Match\n   *  \"\"\"\\w+\"\"\".r replaceAllIn (\"A simple example.\", _ match { case Match(s) \u003d\u003e s.toUpperCase })\n   *  }}}\n   *\n   */\n  object Match {\n    def unapply(m: Match): Some[String] \u003d Some(m.matched)\n  }\n\n  /** An extractor object that yields the groups in the match. Using this extractor\n   *  rather than the original `Regex` ensures that the match is not recomputed.\n   *\n   *  {{{\n   *  import scala.util.matching.Regex.Groups\n   *\n   *  val date \u003d \"\"\"(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)\"\"\".r\n   *  val text \u003d \"The doc spree happened on 2011-07-15.\"\n   *  val day \u003d date replaceAllIn(text, _ match { case Groups(_, month, day) \u003d\u003e s\"\\$month/\\$day\" })\n   *  }}}\n   */\n  object Groups {\n    def unapplySeq(m: Match): Option[Seq[String]] \u003d {\n      if (m.groupCount \u003e 0) extractGroupsFromMatch(m) else None\n    }\n  }\n\n  @inline private def extractGroupsFromMatch(m: Match): Option[List[String]] \u003d\n     Some(List.tabulate(m.groupCount) { i \u003d\u003e m.group(i + 1) })\n\n  /** A class to step through a sequence of regex matches.\n   *\n   *  This is an iterator that returns the matched strings.\n   *\n   *  Queries about match data pertain to the current state of the underlying\n   *  matcher, which is advanced by calling `hasNext` or `next`.\n   *\n   *  When matches are exhausted, queries about match data will throw\n   *  [[java.lang.IllegalStateException]].\n   *\n   *  @see [[java.util.regex.Matcher]]\n   */\n  class MatchIterator(val source: CharSequence, val regex: Regex, private[Regex] val _groupNames: Seq[String])\n  extends AbstractIterator[String] with MatchData { self \u003d\u003e\n\n    @deprecated(\"groupNames does not include inline group names, and should not be used anymore\", \"2.13.7\")\n    val groupNames: Seq[String] \u003d _groupNames\n\n    protected[Regex] val matcher \u003d regex.pattern.matcher(source)\n\n    // 0 \u003d not yet matched, 1 \u003d matched, 2 \u003d advanced to match, 3 \u003d no more matches\n    private[this] var nextSeen \u003d 0\n\n    /** Return true if `next` will find a match.\n     *  As a side effect, advance the underlying matcher if necessary;\n     *  queries about the current match data pertain to the underlying matcher.\n     */\n    def hasNext: Boolean \u003d {\n      nextSeen match {\n        case 0 \u003d\u003e nextSeen \u003d if (matcher.find()) 1 else 3\n        case 1 \u003d\u003e ()\n        case 2 \u003d\u003e nextSeen \u003d 0 ; hasNext\n        case 3 \u003d\u003e ()\n      }\n      nextSeen \u003d\u003d 1      // otherwise, 3\n    }\n\n    /** The next matched substring of `source`.\n     *  As a side effect, advance the underlying matcher if necessary.\n     */\n    def next(): String \u003d {\n      nextSeen match {\n        case 0 \u003d\u003e if (!hasNext) throw new NoSuchElementException ; next()\n        case 1 \u003d\u003e nextSeen \u003d 2\n        case 2 \u003d\u003e nextSeen \u003d 0 ; next()\n        case 3 \u003d\u003e throw new NoSuchElementException\n      }\n      matcher.group\n    }\n\n    /** Report emptiness. */\n    override def toString: String \u003d super[AbstractIterator].toString\n\n    // ensure we\u0027re at a match\n    private[this] def ensure(): Unit \u003d nextSeen match {\n      case 0 \u003d\u003e if (!hasNext) throw new IllegalStateException\n      case 1 \u003d\u003e ()\n      case 2 \u003d\u003e ()\n      case 3 \u003d\u003e throw new IllegalStateException\n    }\n\n    /** The index of the first matched character. */\n    def start: Int \u003d { ensure() ; matcher.start }\n\n    /** The index of the first matched character in group `i`. */\n    def start(i: Int): Int \u003d { ensure() ; matcher.start(i) }\n\n    /** The index of the last matched character. */\n    def end: Int \u003d { ensure() ; matcher.end }\n\n    /** The index following the last matched character in group `i`. */\n    def end(i: Int): Int \u003d { ensure() ; matcher.end(i) }\n\n    /** The number of subgroups. */\n    def groupCount: Int \u003d { ensure() ; matcher.groupCount }\n\n    /** Convert to an iterator that yields MatchData elements instead of Strings. */\n    def matchData: Iterator[Match] \u003d new AbstractIterator[Match] {\n      def hasNext \u003d self.hasNext\n      def next() \u003d { self.next(); new Match(source, matcher, _groupNames).force }\n    }\n\n    /** Convert to an iterator that yields MatchData elements instead of Strings and has replacement support. */\n    private[matching] def replacementData \u003d new AbstractIterator[Match] with Replacement {\n      def matcher \u003d self.matcher\n      def hasNext \u003d self.hasNext\n      def next() \u003d { self.next(); new Match(source, matcher, _groupNames).force }\n    }\n  }\n\n  /**\n   * A trait able to build a string with replacements assuming it has a matcher.\n   * Meant to be mixed in with iterators.\n   */\n  private[matching] trait Replacement {\n    protected def matcher: Matcher\n\n    private[this] val sb \u003d new java.lang.StringBuffer\n\n    def replaced \u003d {\n      val newsb \u003d new java.lang.StringBuffer(sb)\n      matcher.appendTail(newsb)\n      newsb.toString\n    }\n\n    def replace(rs: String) \u003d matcher.appendReplacement(sb, rs)\n  }\n\n  /** Quotes strings to be used literally in regex patterns.\n   *\n   *  All regex metacharacters in the input match themselves literally in the output.\n   *\n   *  @example {{{List(\"US\\$\", \"CAN\\$\").map(Regex.quote).mkString(\"|\").r}}}\n   */\n  def quote(text: String): String \u003d Pattern quote text\n\n  /** Quotes replacement strings to be used in replacement methods.\n   *\n   *  Replacement methods give special meaning to backslashes (`\\`) and\n   *  dollar signs (`\\$`) in replacement strings, so they are not treated\n   *  as literals. This method escapes these characters so the resulting\n   *  string can be used as a literal replacement representing the input\n   *  string.\n   *\n   *  @param text The string one wishes to use as literal replacement.\n   *  @return A string that can be used to replace matches with `text`.\n   *  @example {{{\"CURRENCY\".r.replaceAllIn(input, Regex quoteReplacement \"US\\$\")}}}\n   */\n  def quoteReplacement(text: String): String \u003d Matcher quoteReplacement text\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:119)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/util/matching/Regex.scala
	at java.base/java.net.URI.create(URI.java:903)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 26: jar:file:///C:/Users/Gewin Singh/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12-sources.jar!/scala/util/matching/Regex.scala
	at java.base/java.net.URI$Parser.fail(URI.java:2970)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3141)
	at java.base/java.net.URI$Parser.parse(URI.java:3177)
	at java.base/java.net.URI.<init>(URI.java:620)
	at java.base/java.net.URI.create(URI.java:901)
	... 22 more

Apr. 26, 2024 3:52:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 10741
2024.04.26 03:52:04 INFO  compiling root-test (3 scala sources)
2024.04.26 03:52:04 INFO  time: compiled root-test in 0.22s
